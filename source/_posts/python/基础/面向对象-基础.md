---
title: python面向对象
date: 2019-11-04 22:36:03
categories:
  - python
  - 基础
tags:
  - 面向对象
---

## 类与实例

面向对象最重要的概念就是类（`Class`）和实例（`Instance`），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

仍以Student类为例，在Python中，定义类是通过`class`关键字：

```python
class Student(object):
    pass
```

`class`后面紧接着是类名，即`Student`，类名通常是大写开头的单词，紧接着是`(object)`，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用`object`类，这是所有类最终都会继承的类。

定义好了`Student`类，就可以根据`Student`类创建出`Student`的实例，创建实例是通过`类名+()`实现的：

```python
In [5]: s = Student()

In [6]: s
Out[6]: <__main__.Student at 0x107615860>

In [7]: Student
Out[7]: <class '__main__.Student'>
```

可以看到，变量`s`指向的就是一个`Student`的实例，后面的`0x107615860`是内存地址，每个object的地址都不一样，而`Student`本身则是一个类。

可以自由地给一个实例变量绑定属性，比如，给实例`s`绑定一个`name`属性：

```python
In [9]: s.name = 'Bart Simpson'

In [10]: s.name
Out[10]: 'Bart Simpson'
```

 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的`__init__`方法，在创建实例的时候，就把`name`，`score`等属性绑上去：

```python
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
```

> 注意：特殊方法“__init__”前后分别有两个下划线！！！

注意到`__init__`方法的第一个参数永远是`self`，表示创建的实例本身，因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。

有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去：

```python
In [14]: class Student(object):
    ...:
    ...:     def __init__(self, name, score):
    ...:         self.name = name
    ...:         self.score = score
    ...:

In [15]: s = Student('Bart Simpson', 59)

In [16]: s.name
Out[16]: 'Bart Simpson'

In [17]: s.score
Out[17]: 59
```

和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量`self`，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。

## 数据封装

面向对象编程的一个重要特点就是数据封装。在上面的`Student`类中，每个实例就拥有各自的`name`和`score`这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：

```python
In [19]: def print_score(std):
    ...:     print('%s: %s' % (std.name, std.score))
    ...:

In [20]: print_score(s)
Bart Simpson: 59
```

但是，既然`Student`实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在`Student`类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和`Student`类本身是关联起来的，我们称之为类的方法：

```python
In [23]: class Student(object):
    ...:
    ...:     def __init__(self, name, score):
    ...:         self.name = name
    ...:         self.score = score
    ...:
    ...:     def print_score(self):
    ...:         print('%s: %s' % (self.name, self.score))
    ...:
```

要定义一个方法，除了第一个参数是`self`外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了`self`不用传递，其他参数正常传入：

```python
In [24]: s = Student('Bart Simpson', 59)

In [25]: s.print_score()
Bart Simpson: 59
```

这样一来，我们从外部看`Student`类，就只需要知道，创建实例需要给出`name`和`score`，而如何打印，都是在`Student`类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。

封装的另一个好处是可以给`Student`类增加新的方法，比如`get_grade`：

```python
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def get_grade(self):
        if self.score >= 90:
            return 'A'
        elif self.score >= 60:
            return 'B'
        else:
            return 'C'
 
```

同样的，`get_grade`方法可以直接在实例变量上调用，不需要知道内部实现细节

```python
lisa = Student('Lisa', 99)
bart = Student('Bart', 59)
print(lisa.name, lisa.get_grade())
print(bart.name, bart.get_grade())
```

## 继承

- 在程序中，继承描述的是多个类之间的所属关系。
- 如果一个类A里面的属性和方法可以复用，则可以通过继承的方式，传递到类B里。那么类A就是基类，也叫做父类；类B就是派生类，也叫做子类。

### 1. 单继承

> 子类A只继承了一个父类B, 那么此时两者之间的关系就是单继承

- 单继承，子类直接继承父类的`__init__`方法
  
    ```python
    class User(object):  # 创建用户类
        def __init__(self, name):  # 给用户添加属性：name
            self.name = name
  
    class VipUser(User):
        # 子类继承父类的__init__方法，添加name属性
        pass
  
    vip = VipUser("xw")  # vip初始化时，自己本身没有实现__init__方法,而是直接调用继承自User的__init__方法，vip有name属性
    print(vip.name)
    ```

- 单继承，子类自己实现`__init__`方法
  
    ```python
    class User():  # 创建用户类
        def __init__(self, name):  # 给用户添加属性：name
            self.name = name
  
    class VipUser(User):
        # 子类自己实现__init__方法，并没有直接使用继承父类的__init__方法
        def __init__(self, name):  # 给vip用户添加属性：name
            self.name = name
  
    vip = VipUser("xw")  # vip初始化时，自己本身没有实现__init__方法,而是直接调用继承自User的__init__方法，vip有name属性
    print(vip.name)
    ```

- 单继承，子类在自己实现的`__init__`方法中，还调用了父类的`__init__`方法

    ```python
    # 对象初始化，__init__方法只会执行一次
    
    class User():  # 创建用户类
        def __init__(self, name):  # 给用户添加属性：name
            self.name = name
    
    class VipUser(User):
        def __init__(self, name, money):
            # self.name = name
            # User.__init__(self)   # 通过父类名直接调用父类的__init__方法实现name属性的添加
            super().__init__(name)  # 通过super()调用父类的__init__方法添加name属性
            self.money = money  # 自己添加money属性
    
    vip = VipUser("xw", 300)  # vip初始化时，__init__方法执行一次
    print(vip.name, vip.money)
    
    ```

### 2. 多继承

> 多继承可以继承多个父类，也继承了所有父类的属性和方法

 - 如果多个父类中有同名的 属性和方法，则默认使用第一个父类的属性和方法（根据类的魔法属性`__mro__`的顺序来查找）
 - 多个父类中，不重名的属性和方法，不会有任何影响。

    ```python
    class A():
        def __init__(self):
            self.name = "A"
    
    class B():
        def __init__(self):
            self.name = "B"
    
    class C(A, B):
        pass
    
    c = C()
    print(C.mro())  # [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
    print(c.name)  # A
    ```

### 3. 多层继承

>  多层继承主要说的是`super`的搜索顺序,而搜索顺序主要是根据类的魔法属性`__mro__`的顺序来查找

- `super()`调用方法顺序示例

    ```python
    class A():
        def run(self):
            print(">>>A<<<")
    
    class B1(A):
        def run(self):
            print(">>>B1<<<")
            super().run()
            
    class B2(A):
        def run(self):
            print(">>>B2<<<")
            super().run()
            
    class C(B1, B2):
        def run(self):
            print(">>>C<<<")
            super().run()
            
    c= C()
    print(C.mro())
    c.run()
    ```

    > 程序运行结果：

    ```shell
    [<class '__main__.C'>, <class '__main__.B1'>, <class '__main__.B2'>, <class '__main__.A'>, <class 'object'>]
    >>>C<<<
    >>>B1<<<
    >>>B2<<<
    >>>A<<<
    ```
- 参数传递示例

    ```python
    class Father(object):
        def __init__(self, name):
            print('father')
            self.name = name
    
    class Son1(Father):
        def __init__(self, name, age, *args):
            print('Son1')
            self.age = age
            super().__init__(name, *args)
    
    class Son2(Father):
        def __init__(self, name, gender):
            print('Son2')
            self.gender = gender
            super().__init__(name)
    
    class Grandson(Son1, Son2):
        def __init__(self, name, age, gender):
            print("Grandson")
            super().__init__(name, age, gender)
    
    print(Grandson.mro())
    print("+" * 30)
    
    grand_son = Grandson('王明', 14, '男')
    
    print("+" * 30)
    print(grand_son.name, grand_son.age, grand_son.gender)
    ```
    
    > 程序运行结果：
    
    ```shell
    ++++++++++++++++++++++++++++++
    Grandson
    Son1
    Son2
    father
    ++++++++++++++++++++++++++++++
    王明 14 男
    ```

## 多态

### 1. 多态

所谓的多态就是同一类事物有不同的形态,(一个抽象类有多个子类，因而多态的概念依赖于继承)

  - 序列类型有多种形态：字符串，列表，元组
  - 动物有多种形态：猫，狗

```python
# 多态：同一种事物的多种形态，动物分为猫类，狗类（在定义角度）
class Animal():
    def __init__(self, name, foods):
        self.name = name
        self.foods = foods

    def eat(self):
        print("%s的食物是%s" % (self.name, self.foods))

    def run(self):
        print("%s跑的很快" % self.name)

    def call(self):
        pass


class Dog(Animal):
    def call(self):
        print("%s:汪汪大叫" % self.name)


class Cat(Animal):
    def call(self):
        print("%s:喵喵大叫" % self.name)


dog = Dog("哈士奇", "狗粮")
dog.eat()
dog.call()

cat = Cat("九命妖猫", "仙露")
cat.eat()
cat.run()

```

### 2. 多态性

> 什么是多态性（注意：多态与多态性是两种概念）

- 多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。
- 在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。
- 也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。

```python
# 多态性依赖于：继承
##多态性：定义统一的接口，
#多态性：一种调用方式，不同的执行效果（多态性）
def func(obj): # obj这个参数没有类型限制，可以传入不同类型的值
	obj.eat()  #调用的逻辑都一样，执行的结果却不一样

func(dog)
func(cat)
```
> 为什么要用多态性（多态性的好处）

其实大家从上面多态性的例子可以看出，我们并没有增加上面新的知识，也就是说Python本身就是支持多态性的，这么做的好处是什么呢？

-  增加了程序的灵活性
以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal)
-  增加了程序额可扩展性
通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用

> - 多态：同一种事物的多种形态，动物分为猫类，狗类（在定义角度） 
> - 多态性：一种调用方式，不同的执行效果（多态性）

## 类型判断



## 访问权限



## 实例属性与类属性



## 实例方法、静态方法与类方法

### 1. 方法分类

先看语法，`python` 类语法中有三种方法，实例方法，静态方法，类方法。

> `python`中`self`，`cls`的区别:

   - 普通实例方法，第一个参数需要是`self`，它表示一个具体的实例本身。
   - 如果用了`staticmethod`，那么就可以无视这个`self`，而将这个方法当成一个普通的函数使用。
   - 而对于`classmethod`，它的第一个参数不是`self`，是`cls`，它表示这个类本身。

```python 
# coding:utf-8
class Foo(object):
    """类三种方法语法形式"""

    def instance_method(self):
        print("是类{}的实例方法，只能被实例对象调用".format(Foo))

    @staticmethod
    def static_method():
        print("是静态方法")

    @classmethod
    def class_method(cls):
        print("是类方法")


foo = Foo()
foo.instance_method()
foo.static_method()
foo.class_method()
print('----------------')
Foo.static_method()
Foo.class_method()

```

运行结果：
    
```shell
是类<class '__main__.Foo'>的实例方法，只能被实例对象调用
是静态方法
是类方法
----------------
是静态方法
是类方法
```

> 说明

- 调用
    - 实例方法只能被实例对象调用
    - 静态方法(由`@staticmethod`装饰的方法)、类方法(由`@classmethod`装饰的方法)，可以被类或类的实例对象调用。
- 参数
    - 实例方法，第一个参数必须要默认传实例对象，一般习惯用`self`。
    - 静态方法，参数没有要求。
    - 类方法，第一个参数必须要默认传类，一般习惯用`cls`。

### 2. 方法调用

> 静态方法调用另一个静态方法，如果改用类方法调用静态方法，可以让`cls`代替类，让代码看起来精简一些。也防止类名修改了，不用在类定义中修改原来的类名。

```python
# coding:utf-8
class Foo(object):
    X = 1
    Y = 2

    @staticmethod
    def averag(*mixes):
        return sum(mixes) / len(mixes)

    @staticmethod
    def static_method():  # 在静态方法中调用静态方法
        print("在静态方法中调用静态方法")
        return Foo.averag(Foo.X, Foo.Y)

    @classmethod
    def class_method(cls):  # 在类方法中使用静态方法
        print("在类方法中使用静态方法")
        return cls.averag(cls.X, cls.Y)

foo = Foo()
print(foo.static_method())
print(foo.class_method())
```
> 运行结果：

```shell
在静态方法中调用静态方法
1.5
在类方法中使用静态方法
1.5
```

### 3.继承类中的区别

从下面代码可以看出，如果子类继承父类的方法，子类覆盖了父类的静态方法:

- 子类的实例继承了父类的`static_method`静态方法，调用该方法，还是调用的父类的方法和类属性。
- 子类的实例继承了父类的`class_method`类方法，调用该方法，调用的是子类的方法和子类的类属性。

```python
class Foo(object):
    X = 1
    Y = 14

    @staticmethod
    def averag(*mixes):  # "父类中的静态方法"
        return sum(mixes) / len(mixes)

    @staticmethod
    def static_method():  # "父类中的静态方法"
        print("父类中的静态方法")
        return Foo.averag(Foo.X, Foo.Y)

    @classmethod
    def class_method(cls):  # 父类中的类方法
        print("父类中的类方法")
        return cls.averag(cls.X, cls.Y)


class Son(Foo):
    X = 3
    Y = 5

    @staticmethod
    def averag(*mixes):  # "子类中重载了父类的静态方法"
        print("子类中重载了父类的静态方法")
        return sum(mixes) / len(mixes)


p = Son()
print("result of p.averag(1,5)")
print(p.averag(1, 5))
print("result of p.static_method()")
print(p.static_method())
print("result of p.class_method()")
print(p.class_method())
```

> 运行结果：

```python
result of p.averag(1,5)
子类中重载了父类的静态方法
3.0
result of p.static_method()
父类中的静态方法
7.5
result of p.class_method()
父类中的类方法
子类中重载了父类的静态方法
4.0
```