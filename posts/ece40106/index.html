<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bookandmusic.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"ZMZD8LN6JF","apiKey":"c75e305c22fd4cf56b8f03aa6efec207","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git非常强大，可以说是开发人员必备技能。">
<meta property="og:type" content="article">
<meta property="og:title" content="版本控制工具Git">
<meta property="og:url" content="https://bookandmusic.cn/posts/ece40106/index.html">
<meta property="og:site_name" content="Bookandmusic">
<meta property="og:description" content="Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git非常强大，可以说是开发人员必备技能。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/Git%E6%93%8D%E4%BD%9C%20.jpg">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/center_stroe.svg">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/2021_3_28.svg">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/reset.svg">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/repo.svg">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/gitpull.svg">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/gitpush.svg">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/10/b31cec404eb42609abe8712064672714.svg">
<meta property="og:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/10/4b3d10b071e295b02fcb95215ebd5954.svg">
<meta property="article:published_time" content="2021-06-12T14:29:36.000Z">
<meta property="article:modified_time" content="2022-01-08T09:57:41.857Z">
<meta property="article:author" content="bookandmusic">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/Git%E6%93%8D%E4%BD%9C%20.jpg">

<link rel="canonical" href="https://bookandmusic.cn/posts/ece40106/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>版本控制工具Git | Bookandmusic</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bookandmusic</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">踮起脚尖，另一种高度</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bookandmusic.cn/posts/ece40106/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bookandmusic">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bookandmusic">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          版本控制工具Git
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-12 22:29:36" itemprop="dateCreated datePublished" datetime="2021-06-12T22:29:36+08:00">2021-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-08 17:57:41" itemprop="dateModified" datetime="2022-01-08T17:57:41+08:00">2022-01-08</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git非常强大，可以说是开发人员必备技能。</p>
<span id="more"></span>

<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul>
<li><p>windows：到git官网上下载, <a target="_blank" rel="noopener" href="https://gitforwindows.org/">Download</a> git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p>
</li>
<li><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>  安装好后，用<code>git --version</code> 来查看一下版本</p>
</li>
</ul>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/Git%E6%93%8D%E4%BD%9C%20.jpg" alt="Git操作"></p>
<h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p><code>git init</code> 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。大多数Git命令在未初始化的仓库中都是无法使用的，所以这就是你运行新项目的第一个命令了。</p>
<p>运行 <code>git init</code> 命令会在你项目的根目录下创建一个新的 <code>.git</code> 目录，其中包含了你项目必需的所有元数据。除了 <code>.git</code> 目录之外，已经存在的项目不会被改变（Git 不强制每个子目录中都有一个 <code>.git</code> 目录）。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>将当前的目录转换成一个 Git 仓库。它在当前的目录下增加了一个 <code>.git</code> 目录，于是就可以开始记录项目版本了。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p>在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 <code>directory</code>，只包含 <code>.git</code> 子目录的空目录。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p>初始化一个<strong>裸</strong>的 Git 仓库，但是忽略工作目录。共享的<strong>中心仓库</strong>应该总是用 <code>--bare</code> 标记创建。</p>
<p>一般来说，用 <code>—-bare</code> 标记初始化的仓库以 <code>.git</code> 结尾。比如，一个叫<code>repo</code>的仓库，它的空版本应该保存在 <code>repo.git</code> 目录下（这也是为什么我们从 GitHub clone 仓库的时候，地址都是 xxx.git 这样的形式的原因）。</p>
<p>并且这个仓库是可以被正常 <code>clone</code> 和 <code>push</code> 更新的， <strong>裸仓库</strong>不包含工作区，所以并不会存在在裸仓库上直接提交变更的情况。</p>
<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/center_stroe.svg" alt="center_stroe"></p>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p><code>git clone</code> 命令拷贝整个 Git 仓库。这个命令在本地创建一个完备的Git仓库——它包含自己的历史，管理自己的文件，以及环境和原仓库完全隔离。</p>
<p>为了方便起见，<code>clone</code> 自动创建了一个名为 <code>origin</code> 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt;</span><br></pre></td></tr></table></figure>

<p>将位于 <code>&lt;repo&gt;</code> 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p>将位于 <code>&lt;repo&gt;</code> 的仓库克隆到本地机器上的 <code>&lt;directory&gt;</code> 目录。</p>
<h2 id="保存更改"><a href="#保存更改" class="headerlink" title="保存更改"></a>保存更改</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add</code> 命令将工作目录中的变化添加到暂存区。它告诉 Git 你想要在下一次提交时包含这个文件的更新。但是，<code>git add</code> 不会实质上地影响你的仓库——在你运行 <code>git commit</code> 前更改都还没有真正被记录。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;file&gt;</code> 中的更改加入下次提交的缓存。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;directory&gt;</code> 下的更改加入下次提交的缓存。</p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit</code>命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 <code>git add</code> 一样，这是最重要的 Git 命令之一。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p>提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;&lt;message&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>提交已经缓存的快照。但将 <code>&lt;message&gt;</code> 作为提交信息，而不是运行文本编辑器。</p>
<h2 id="查看查看状态"><a href="#查看查看状态" class="headerlink" title="查看查看状态"></a>查看查看状态</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code> 命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被 Git 追踪。status 的输出 <em>不会</em> 告诉你任何已提交到项目历史的信息。如果你想看的话，应该使用 <code>git log</code> 命令。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p><code>git status</code> 是一个相对简单的命令。 它告诉你 <code>git add</code> 和 <code>git commit</code> 的进展。status 信息还包括了添加缓存和移除缓存的相关指令。</p>
<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>未追踪的文件通常有两类。它们要么是项目新增但还未提交的文件，要么是像 <code>.pyc</code>、<code>.obj</code>、<code>.exe</code> 等编译后的二进制文件。显然前者应该出现在 <code>git status</code> 的输出中，而后者会让我们困惑究竟发生了什么。</p>
<p>因此，Git 允许完全忽略这些文件，只需要将路径放在一个特定的 <code>.gitignore</code> 文件中。所有想要忽略的文件应该分别写在单独一行，<code>*</code> 字符用作通配符。比如，将下面这行加入项目根目录的<code>.gitignore</code>文件可以避免编译后的Python模块出现在<code>git status</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.pyc</span><br></pre></td></tr></table></figure>

<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log</code> 命令显示已提交的快照。你可以列出项目历史，筛选，以及搜索特定更改。<code>git status</code> 允许你查看工作目录和缓存区，而 <code>git log</code> 只作用于提交的项目历史。</p>
<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/2021_3_28.svg" alt="2021_3_28"></p>
<p>log 输出可以有很多种自定义的方式，从简单地筛选提交，到用完全自定义的格式显示。其中一些最常用的 <code>git log</code> 配置如下所示。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>使用默认格式显示完整地项目历史。如果输出超过一屏，你可以用 <code>空格键</code> 来滚动，按 <code>q</code> 退出。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n &lt;<span class="built_in">limit</span>&gt;</span><br></pre></td></tr></table></figure>

<p>用 <code>&lt;limit&gt;</code> 限制提交的数量。比如 <code>git log -n 3</code> 只会显示 3 个提交。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>

<p>将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>

<p>除了 <code>git log</code> 信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p</span><br></pre></td></tr></table></figure>

<p>显示代表每个提交的一堆信息。显示每个提交全部的差异（diff），这也是项目历史中最详细的视图。</p>
<h2 id="回滚错误提交"><a href="#回滚错误提交" class="headerlink" title="回滚错误提交"></a>回滚错误提交</h2><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><code>git revert</code> 命令用来撤销一个已经提交的快照。但是，它是通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的 <em>新</em> 提交，而不是从项目历史中移除这个提交。这避免了Git丢失项目历史，这一点对于你的版本历史和协作的可靠性来说是很重要的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p>生成一个撤消了 <code>&lt;commit&gt;</code> 引入的修改的新提交，然后应用到当前分支。</p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>如果说 <code>git revert</code> 是一个撤销更改安全的方式，你可以将 <code>git reset</code> 看做一个 <em>危险</em> 的方式。当你用 <code>git reset</code> 来重设更改时(提交不再被任何引用或引用日志所引用)，我们无法获得原来的样子——这个撤销是永远的。使用这个工具的时候务必要小心，因为这是少数几个可能会造成工作丢失的命令之一。</p>
<p>和 <code>git checkout</code> 一样，<code>git reset</code> 有很多种用法。它可以被用来移除提交快照，尽管它通常被用来撤销缓存区和工作目录的修改。不管是哪种情况，它应该只被用于 <em>本地</em> 修改——你永远不应该重设和其他开发者共享的快照。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>从缓存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不覆盖任何更改。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure>

<p>重设缓冲区，匹配最近的一次提交，但工作目录不变。它会取消 <em>所有</em> 文件的缓存，而不会覆盖任何修改，给你了一个重设缓存快照的机会。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>

<p>重设缓冲区和工作目录，匹配最近的一次提交。除了取消缓存之外，<code>--hard</code> 标记告诉 Git 还要重写所有工作目录中的更改。换句话说：它清除了所有未提交的更改，所以在使用前确定你想扔掉你所有本地的开发。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p>将当前分支的末端移到 <code>&lt;commit&gt;</code>，将缓存区重设到这个提交，但不改变工作目录。所有 <code>&lt;commit&gt;</code> 之后的更改会保留在工作目录中，这允许你用更干净、原子性的快照重新提交项目历史。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p>将当前分支的末端移到 <code>&lt;commit&gt;</code>，将缓存区和工作目录都重设到这个提交。它不仅清除了未提交的更改，同时还清除了 <code>&lt;commit&gt;</code> 之后的所有提交。</p>
<h3 id="revert-VS-reset"><a href="#revert-VS-reset" class="headerlink" title="revert VS reset"></a>revert VS reset</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/reset.svg" alt="reset"></p>
<p>撤销和重设相比有两个重要的优点。首先，它不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。</p>
<p>其次，<code>git revert</code> 可以针对历史中任何一个提交，而 <code>git reset</code>只能从当前提交向前回溯。比如，你想用 <code>git reset</code> 重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。不用说，这并不是一个优雅的回滚方案。</p>
<h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><p><code>git clean</code> 命令将未跟踪的文件从你的工作目录中移除。它只是提供了一条捷径，因为用 <code>git status</code> 查看哪些文件还未跟踪然后手动移除它们也很方便。和一般的 <code>rm</code> 命令一样，<code>git clean</code> 是无法撤消的，所以在删除未跟踪的文件之前想清楚，你是否真的要这么做。</p>
<p><code>git clean</code> 命令经常和 <code>git reset --hard</code> 一起使用。记住，reset 只影响被跟踪的文件，所以还需要一个单独的命令来清理未被跟踪的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -n</span><br></pre></td></tr></table></figure>

<p>执行一次git clean的『演习』。它会告诉你那些文件在命令执行后会被移除，而不是真的删除它。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f</span><br></pre></td></tr></table></figure>

<p>移除当前目录下未被跟踪的文件。<code>-f</code>（强制）标记是必需的，它 <em>不会</em> 删除 <code>.gitignore</code> 中指定的未跟踪的文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f &lt;path&gt;</span><br></pre></td></tr></table></figure>

<p>移除未跟踪的文件，但限制在某个路径下。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df</span><br></pre></td></tr></table></figure>

<p>移除未跟踪的文件，以及目录。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -xf</span><br></pre></td></tr></table></figure>

<p>移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件。</p>
<h2 id="代码同步"><a href="#代码同步" class="headerlink" title="代码同步"></a>代码同步</h2><p>Git 给予每个开发者一份自己的仓库拷贝，拥有自己完整的本地历史和分支结构。用户通常共享一系列的提交而不是单个变更集合。Git 允许你在仓库间共享整个分支，而不是从工作副本提交一个差异集合到中央仓库。</p>
<p>下面的命令让你管理仓库之间的连接，将分支「推送」到其他仓库来发布本地历史，或是将分支「拉取」到本地仓库来查看其它开发者的贡献。</p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p><code>git remote</code> 命令允许你创建、查看和删除和其它仓库之间的连接。远程连接更像是书签，而不是直接跳转到其他仓库的链接。它用方便记住的别名引用不那么方便记住的 URL，而不是提供其他仓库的实时连接。</p>
<p>例如，下图显示了你的仓库和中央仓库以及另一个开发者仓库之间的远程连接。你可以向 Git 命令传递 origin 和 john 的别名来引用这些仓库，替代完整的 URL。</p>
<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/repo.svg" alt="repo"></p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>列出你和其他仓库之间的远程连接。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>和上个命令相同，但同时显示每个连接的 URL。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure>

<p>创建一个新的远程仓库连接。在添加之后，你可以将 <code>&lt;name&gt;</code>作为 <code>&lt;url&gt;</code> 便捷的别名在其他 Git 命令中使用。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>移除名为的远程仓库的连接。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure>

<p>将远程连接从 <code>&lt;old-name&gt;</code> 重命名为 <code>&lt;new-name&gt;</code>。</p>
<blockquote>
<p>  <strong>名为 origin 的远程连接</strong></p>
</blockquote>
<p>当你用 <code>git clone</code> 克隆仓库时，它自动创建了一个名为 origin 的远程连接，指向被克隆的仓库。当开发者创建中央仓库的本地副本时非常有用，因为它提供了拉取上游更改和发布本地提交的快捷方式。这也是为什么大多数基于 Git 的项目将它们的中央仓库取名为 origin。</p>
<blockquote>
<p>  <strong>仓库的 URL</strong></p>
</blockquote>
<p>Git 支持多种方式来引用一个远程仓库。其中两种最简单的方式便是 HTTP 和 SSH 协议。HTTP 是允许匿名、只读访问仓库的简易方式。比如：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/path/to/repo.git</span><br></pre></td></tr></table></figure>

<p>但是，直接将提交推送到一个 HTTP 地址一般是不可行的（你不太可能希望匿名用户也能随意推送）。如果希望对仓库进行读写，你需要使用 SSH 协议：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh://user@host/path/to/repo.git</span><br></pre></td></tr></table></figure>

<p>你需要在托管的服务器上有一个有效的 SSH 账户，但不用麻烦了，Git 支持开箱即用的 SSH 认证连接。</p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p><code>git fetch</code> 命令将提交从远程仓库导入到你的本地仓库。拉取下来的提交储存为远程分支，而不是我们一直使用的普通的本地分支。你因此可以在整合进你的项目副本之前查看更改。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>拉取仓库中所有的分支。同时会从另一个仓库中下载所有需要的提交和文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>和上一个命令相同，但只拉取指定的分支。</p>
<p>当你希望查看其他人的工作进展时，你需要 fetch。fetch 下来的内容表示为一个远程分支，因此不会影响你的本地开发。这是一个安全的方式，在整合进你的本地仓库之前，检查那些提交。你可以看到中央仓库的历史进展如何，但它不会强制你将这些进展合并入你的仓库。</p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>在基于 Git 的协作工作流中，将上游更改合并到你的本地仓库是一个常见的工作。我们已经知道应该使用 <code>git fetch</code>，然后是 <code>git merge</code>，但是 <code>git pull</code> 将这两个命令合二为一。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>拉取当前分支对应的远程副本中的更改，并立即并入本地副本。效果和 <code>git fetch</code> 后接 <code>git merge origin/.</code> 一致。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>和上一个命令相同，但使用 <code>git rebase</code> 合并远程分支和本地分支，而不是使用 <code>git merge</code>。</p>
<p>下图揭示了 pull 过程中的每一步。</p>
<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/gitpull.svg" alt="gitpull"></p>
<p>你认为你的仓库已经同步了，但 <code>git fetch</code> 发现 origin 中 <code>master</code> 的版本在上次检查后已经有了新进展。 接着 <code>git merge</code> 立即将 <code>remote master</code> 并入本地的分支。</p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>Push 是你将本地仓库中的提交转移到远程仓库中时要做的事。它和 <code>git fetch</code> 正好相反，fetch 将提交导入到本地分支，而 push 将提交导出到远程分支。它可以覆盖已有的更改，所以你需要小心使用。这些情况请见下面的讨论。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>将指定的分支推送到 <code>&lt;remote&gt;</code> 上，包括所有需要的提交和提交对象。它会在目标仓库中创建一个本地分支。为了防止你覆盖已有的提交，如果会导致目标仓库非快速向前合并时，Git 不允许你 push。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; --force</span><br></pre></td></tr></table></figure>

<p>和上一个命令相同，但即使会导致非快速向前合并也强制推送。除非你确定你所做的事，否则不要使用 <code>--force</code> 标记。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; --all</span><br></pre></td></tr></table></figure>

<p>将所有本地分支推送到指定的远程仓库</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; --tags</span><br></pre></td></tr></table></figure>

<p>当你推送一个分支或是使用 <code>--all</code> 选项时，标签不会被自动推送上去。<code>--tags</code> 将你所有的本地标签推送到远程仓库中去。</p>
<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/03/gitpush.svg" alt="gitpush"></p>
<p>上图显示了当你本地的 master 分支进展超过了中央仓库的 <code>master</code> 分支，当你运行 <code>git push origin master</code> 发布更改时发生的事情。注意，<code>git push</code> 和在远程仓库内部运行 <code>git merge master</code> 事实上是一样的。</p>
<h2 id="分支协同开发"><a href="#分支协同开发" class="headerlink" title="分支协同开发"></a>分支协同开发</h2><p>首先，简单讲解如何创建分支，就像请求一份新的项目历史一样。然后，我们会看到 git checkout 是如何切换分支的。最后，学习一下 git merge 是如何整合独立分支的历史。</p>
<p>我们已经知道，Git 分支和 SVN 分支不同。SVN 分支只被用来记录偶尔大规模的开发效果，而 Git 分支是你日常工作流中不可缺失的一部分。</p>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>分支代表了一条独立的开发流水线。分支是我们之前讨论过的「编辑/缓存/提交」流程的抽象。你可以把它看作请求全新「工作目录、缓存区、项目历史」的一种方式。新的提交被存放在当前分支的历史中，导致了项目历史被 fork 了一份。</p>
<p><code>git branch</code> 命令允许你创建、列出、重命名和删除分支。它不允许你切换分支或是将被 fork 的历史放回去。因此，<code>git branch</code> 和 <code>git checkout</code>、<code>git merge</code> 这两个命令通常紧密地结合在一起使用。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>列出仓库中所有分支。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>创建一个名为 <code>&lt;branch&gt;</code> 的分支。<em>不会</em> 自动切换到那个分支去。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>删除指定分支。这是一个安全的操作，Git 会阻止你删除包含未合并更改的分支。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>强制删除指定分支，即使包含未合并更改。如果你希望永远删除某条开发线的所有提交，你应该用这个命令。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>将当前分支命名为 <code>&lt;branch&gt;</code>。</p>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><code>git checkout</code> 命令允许你切换用 <code>git branch</code> 创建的分支。查看一个分支会更新工作目录中的文件，以符合分支中的版本，它还告诉 Git 记录那个分支上的新提交。将它看作一个选中你正在进行的开发的一种方式。</p>
<p>在上一篇中，我们看到了如何用 <code>git checkout</code> 来查看旧的提交。「查看分支」和「将工作目录更新到选中的版本/修改」很类似；但是，新的更改 <em>会</em> 保存在项目历史中——这不是一个只读的操作。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;existing-branch&gt;</span><br></pre></td></tr></table></figure>

<p>查看特定分支，分支应该已经通过 <code>git branch</code> 创建。这使得 <code>&lt;existing-branch&gt;</code> 成为当前的分支，并更新工作目录的版本。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new-branch&gt;</span><br></pre></td></tr></table></figure>

<p>创建并查看 <code>&lt;new-branch&gt;</code>，<code>-b</code> 选项是一个方便的标记，告诉Git在运行 <code>git checkout &lt;new-branch&gt;</code> 之前运行 <code>git branch &lt;new-branch&gt;</code>。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new-branch&gt; &lt;existing-branch&gt;</span><br></pre></td></tr></table></figure>

<p>和上一条相同，但将 <code>&lt;existing-branch&gt;</code> 作为新分支的基，而不是当前分支。</p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>合并是 Git 将被 fork 的历史放回到一起的方式。<code>git merge</code> 命令允许你将 <code>git branch</code> 创建的多条分支合并成一个。</p>
<p>注意，下面所有命令将更改 <em>并入</em> 当前分支。当前分支会被更新，以响应合并操作，但目标分支完全不受影响。也就是说 <code>git merge</code> 经常和 <code>git checkout</code> 一起使用，选择当前分支，然后用 <code>git branch -d</code> 删除废弃的目标分支。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>将指定分支并入当前分支。Git 会决定使用哪种合并算法（下文讨论）。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>将指定分支并入当前分支，但 <em>总是</em> 生成一个合并提交（即使是快速向前合并）。这可以用来记录仓库中发生的所有合并。</p>
<h4 id="合并算法"><a href="#合并算法" class="headerlink" title="合并算法"></a>合并算法</h4><p>一旦你在单独的分支上完成了功能的开发，重要的是将它放回主代码库。取决于你的仓库结构，Git 有几种不同的算法来完成合并：<strong>快速向前合并</strong>或者<strong>三路合并</strong>。</p>
<p>当当前分支顶端到目标分支路径是线性之时，我们可以采取 <strong>快速向前合并</strong> 。Git 只需要将当前分支顶端（快速向前地）移动到目标分支顶端，即可整合两个分支的历史，而不需要“真正”合并分支。它在效果上合并了历史，因为目标分支上的提交现在在当前分支可以访问到。比如，<code>some-feature</code> 到 <code>master</code> 分支的快速向前合并会是这样的：</p>
<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/10/b31cec404eb42609abe8712064672714.svg" alt="b31cec404eb42609abe8712064672714"></p>
<p>但是，如果分支已经分叉了，那么就无法进行快速向前合并。当和目标分支之间的路径不是线性之时，Git 只能执行 <strong>三路合并</strong> 。三路合并使用一个专门的提交来合并两个分支的历史。这个术语取自这样一个事实，Git 使用 <em>三个</em> 提交来生成合并提交：两个分支顶端和它们共同的祖先。</p>
<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2021/10/4b3d10b071e295b02fcb95215ebd5954.svg" alt="4b3d10b071e295b02fcb95215ebd5954"></p>
<p>但你可以选择使用哪一种合并策略时，很多开发者喜欢使用快速向前合并（搭配 rebase 使用）来合并微小的功能或者修复 bug，使用三路合并来整合长期运行的功能。后者导致的合并提交作为两个分支的连接标志。</p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>如果你尝试合并的两个分支同一个文件的同一个部分，Git 将无法决定使用哪个版本。当这种情况发生时，它会停在合并提交，让你手动解决这些冲突。</p>
<p>Git 的合并流程令人称赞的一点是，它使用我们熟悉的「编辑/缓存/提交」工作流来解决冲突。当你遇到合并冲突时，运行 <code>git status</code> 命令来查看哪些文件存在需要解决的冲突。比如，如果两个分支都修改了 <code>hello.py</code> 的同一处，你会看到下面的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Unmerged paths:</span></span><br><span class="line"><span class="comment"># (use &quot;git add/rm ...&quot; as appropriate to mark resolution)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># both modified: hello.py</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>接下来，你可以自己修复这个合并。当你准备结束合并时，你只需对冲突的文件运行 <code>git add</code> 告诉 Git 冲突已解决。然后，运行 <code>git commit</code> 生成一个合并提交。这和提交一个普通的快照有着完全相同的流程，也就是说，开发者能够轻而易举地管理他们的合并。</p>
<p>注意，提交冲突只会出现在三路合并中。在快速向前合并中，我们不可能出现冲突的更改。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Git/" rel="tag"># Git</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/c6e6c35b/" rel="prev" title="JWS的python实现方案">
      <i class="fa fa-chevron-left"></i> JWS的python实现方案
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/fb84e519/" rel="next" title="Linux网络传输命令">
      Linux网络传输命令 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">1.</span> <span class="nav-text">环境配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">基本命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">命令详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93"><span class="nav-number">3.1.</span> <span class="nav-text">创建仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-init"><span class="nav-number">3.1.1.</span> <span class="nav-text">git init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clone"><span class="nav-number">3.1.2.</span> <span class="nav-text">git clone</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E6%9B%B4%E6%94%B9"><span class="nav-number">3.2.</span> <span class="nav-text">保存更改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-add"><span class="nav-number">3.2.1.</span> <span class="nav-text">git add</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-commit"><span class="nav-number">3.2.2.</span> <span class="nav-text">git commit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.3.</span> <span class="nav-text">查看查看状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-status"><span class="nav-number">3.3.1.</span> <span class="nav-text">git status</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">忽略文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-log"><span class="nav-number">3.3.2.</span> <span class="nav-text">git log</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E6%8F%90%E4%BA%A4"><span class="nav-number">3.4.</span> <span class="nav-text">回滚错误提交</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-revert"><span class="nav-number">3.4.1.</span> <span class="nav-text">git revert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-reset"><span class="nav-number">3.4.2.</span> <span class="nav-text">git reset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#revert-VS-reset"><span class="nav-number">3.4.3.</span> <span class="nav-text">revert VS reset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clean"><span class="nav-number">3.4.4.</span> <span class="nav-text">git clean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5"><span class="nav-number">3.5.</span> <span class="nav-text">代码同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-remote"><span class="nav-number">3.5.1.</span> <span class="nav-text">git remote</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-fetch"><span class="nav-number">3.5.2.</span> <span class="nav-text">git fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-pull"><span class="nav-number">3.5.3.</span> <span class="nav-text">git pull</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-push"><span class="nav-number">3.5.4.</span> <span class="nav-text">git push</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91"><span class="nav-number">3.6.</span> <span class="nav-text">分支协同开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-branch"><span class="nav-number">3.6.1.</span> <span class="nav-text">git branch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-checkout"><span class="nav-number">3.6.2.</span> <span class="nav-text">git checkout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-merge"><span class="nav-number">3.6.3.</span> <span class="nav-text">git merge</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">合并算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">解决冲突</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bookandmusic</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2021028097号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bookandmusic</span>
</div>

        




  <script src="https://www.gstatic.com/firebasejs/6.3.3/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/6.3.3/firebase-firestore.js"></script>
  <script>
    firebase.initializeApp({
      apiKey   : '',
      projectId: ''
    });

    function getCount(doc, increaseCount) {
      // IncreaseCount will be false when not in article page
      return doc.get().then(d => {
        var count = 0;
        if (!d.exists) { // Has no data, initialize count
          if (increaseCount) {
            doc.set({
              count: 1
            });
            count = 1;
          }
        } else { // Has data
          count = d.data().count;
          if (increaseCount) {
            // If first view this article
            doc.set({ // Increase count
              count: count + 1
            });
            count++;
          }
        }

        return count;
      });
    }

    function appendCountTo(el) {
      return count => {
        el.innerText = count;
      }
    }
  </script>
  <script>
    (function() {
      var db = firebase.firestore();
      var articles = db.collection('articles');

      if (CONFIG.page.isPost) { // Is article page
        var title = document.querySelector('.post-title').innerText.trim();
        var doc = articles.doc(title);
        var increaseCount = CONFIG.hostname === location.hostname;
        if (localStorage.getItem(title)) {
          increaseCount = false;
        } else {
          // Mark as visited
          localStorage.setItem(title, true);
        }
        getCount(doc, increaseCount).then(appendCountTo(document.querySelector('.firestore-visitors-count')));
      } else if (CONFIG.page.isHome) { // Is index page
        var promises = [...document.querySelectorAll('.post-title')].map(element => {
          var title = element.innerText.trim();
          var doc = articles.doc(title);
          return getCount(doc);
        });
        Promise.all(promises).then(counts => {
          var metas = document.querySelectorAll('.firestore-visitors-count');
          counts.forEach((val, idx) => {
            appendCountTo(metas[idx])(val);
          });
        });
      }
    })();
  </script>




      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
