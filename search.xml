<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>好用的CLI工具</title>
      <link href="/2020/12/27/gong-ju-hao-yong-de-cli-gong-ju/"/>
      <url>/2020/12/27/gong-ju-hao-yong-de-cli-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Starship"><a class="header-anchor" href="#1-Starship">¶</a>1 Starship</h2><p>如果必须要从本篇文章中选择一个我最喜欢的终端工具——那非 <code>Starship</code> 莫属。<code>Starship</code> 可以适用于任何 Shell。你只需要安装它，然后在相应的配置文件<code>.bashrc</code>/<code>.zshrc</code>添加一行配置，剩下的工作交给它来完成就好了。</p><pre class=" language-language-bash"><code class="language-language-bash">eval "$(starship init bash)"</code></pre><p>它可以做到：</p><ul><li><p>根据你是否在代码仓库中添加了新文件、是否修改了文件、是否暂存了文件等情况，用相应的符号表示 <code>git</code> 仓库的状态。</p></li><li><p>根据你所在的 <code>Python</code> 项目目录，展示 Python 的版本号，这也适用于 <code>Go</code>/<code>Node</code>/<code>Rust</code>/<code>Elm</code> 等其他编程语言环境。</p></li><li><p>展示上一个命令执行所用的时间，指令运行时间必须在毫秒级别。</p></li><li><p>如果上一个命令执行失败，会展示相应的错误提示符。</p></li></ul><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640.jpeg" alt=""></p><p>还有不计其数的其他信息可以展示。但是，它能以更加友好的形式智能地给你呈现!</p><pre class=" language-language-bash"><code class="language-language-bash"># startship 个性化配置[character]      # 正在配置的组件名称是“character”symbol = ">"  # 提示符中在输入文本之前显示的符号error_symbol = "✗" # 如果上一条命令失败，提示符中在输入文本之前显示的符号use_symbol_for_status = true # 指示是否改变显示符号来指出错误状态style_success = "bold green"# 上次命令成功时使用的样式style_failure = "bold red"# 上次命令失败时使用的样式# 当 starship 扫描当前目录下的文件和文件夹时，最多使用 10 毫秒scan_timeout = 10[battery]full_symbol = "🔋" # 电量满标志charging_symbol = "⚡️" # 充电标志discharging_symbol = "💀" # 放电标志[[battery.display]]  # 当电量在 0% 到 30% 时以 "bold red" 样式显示threshold = 30style = "bold red"[[battery.display]]  # 当电量在 30% 到 100% 时以 "bold yellow" 样式显示threshold = 100style = "bold yellow"[cmd_duration]min_time = 100 # 显示此组件所需的最短执行时长prefix = "underwent " # 直接在执行时长前显示的前缀style = "bold yellow" # 此组件的样式[directory] # 显示当前目录的路径truncation_length = 8 # 当前目录路径被截断后最多保留的父目录数量。truncate_to_repo = true # 是否只截断到您当前处于的 git 仓库根目录下。prefix = "in" # 直接在显示路径前显示的前缀。style = "bold cyan" # 此组件的样式。[time]disabled = false # 启用时间组件use_12hr = false # 禁用12小时制format = "🕙[ %T ]" # 时间格式time_range = "-" # 显示时间的范围，必须是24小时制</code></pre><p>官网地址：<a href="https://starship.rs/" target="_blank" rel="noopener">https://starship.rs/</a></p><h2 id="2-fzf"><a class="header-anchor" href="#2-fzf">¶</a>2 fzf</h2><p>fzf— fuzzy finder，即模糊查找器。它是一种通用工具，可让你使用模糊搜索来查找文件、历史命令、进程、git 提交等。你键入一些字母，它会尝试匹配结果列表中任何位置的字母。输入的字母越多，结果也就越准确。你可能在其他的代码编辑器中有过这种类型的搜索使用体验——当你想打开某个文件时，只键入文件名的一部分而不用输入完整路径就能进行查找——这就是模糊搜索。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220059861.jpeg" alt=""></p><p>我通过 fish fzf 插件插件使用它，因此我可以搜索命令历史记录或快速打开文件。这是可以每天为我节省不少时间的一个非常棒的工具。</p><p>fzf默认会以“extened-search&quot;模式启动， 这种模式下你可以输入多个以空格分隔的搜索关键词， 如<code>^music .mp3$</code>, <code>sbtrkt !fire</code>.</p><table><thead><tr><th>Token</th><th>Match type</th><th>Description</th></tr></thead><tbody><tr><td>sbtrkt</td><td>fuzzy-match</td><td>匹配sbtrkt</td></tr><tr><td>^music</td><td>prefix-exact-match</td><td>以music开头</td></tr><tr><td>.mp3^</td><td>suffix-exact-match</td><td>以.mp3结尾</td></tr><tr><td>'wild</td><td>exact-match(quoted)</td><td>精确包含wild</td></tr><tr><td>!fire</td><td>inverse-exact-match</td><td>不包含fire</td></tr><tr><td>!.mp3$</td><td>inverse-suffix-exact-match</td><td>不以.mp3结尾</td></tr></tbody></table><p>如果你不想用fuzzy match， 可以用<code>fzf -e</code>做精确匹配<br>符号&quot;|&quot;可以做or匹配， 比如</p><pre class=" language-language-bash"><code class="language-language-bash">^core go$|rb$|py$</code></pre><p>表示以core开头，以go或rb或py结尾的</p><p>下载地址：<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a></p><h2 id="3-fd"><a class="header-anchor" href="#3-fd">¶</a>3 fd</h2><p>类似于系统自带的 <code>find</code> 命令，但使用起来更简单，查找速度更快，并且具有良好的默认设置。</p><h3 id="简单搜索"><a class="header-anchor" href="#简单搜索">¶</a>简单搜索</h3><p><em>fd</em>设计用于查找文件系统中的条目. 你可以执行的最基本的搜索就是运行一个参数:搜索模式的<em>fd</em>. 例如,假设您想查找您的旧脚本 (包括<code>netflix</code>) :</p><pre class=" language-language-zsh"><code class="language-language-zsh">> fd netflSoftware/python/imdb-ratings/netflix-details.py</code></pre><p>如果只调用一个这样的参数,<em>fd</em>递归检索当前目录中, <em>包含</em>模式<code>netfl</code>的任何条目.</p><h3 id="正则表达式搜索"><a class="header-anchor" href="#正则表达式搜索">¶</a>正则表达式搜索</h3><p>搜索模式被视为正则表达式. 这里,我们搜索开始<code>x</code>并以<code>rc</code>结束的条目. :</p><pre class=" language-language-zsh"><code class="language-language-zsh">> cd /etc> fd '^x.*rc$'X11/xinit/xinitrcX11/xinit/xserverrc</code></pre><h3 id="指定根目录"><a class="header-anchor" href="#指定根目录">¶</a>指定根目录</h3><p>如果我们想搜索一个特定的目录,它可以作为第二个参数<em>fd</em>:</p><pre><code>&gt; fd passwd /etc/etc/default/passwd/etc/pam.d/passwd/etc/passwd</code></pre><h3 id="仅运行fd"><a class="header-anchor" href="#仅运行fd">¶</a>仅运行<em>fd</em></h3><p><em>fd</em>可以不带参数调用. 这是非常有用的,以便快速地查看当前目录中的所有条目,递归地 (类似于<code>ls -R</code>) :</p><pre class=" language-language-zsh"><code class="language-language-zsh">> cd fd/tests> fdtestenvtestenv/mod.rstests.rs</code></pre><h3 id="搜索特定的文件扩展名"><a class="header-anchor" href="#搜索特定的文件扩展名">¶</a>搜索特定的文件扩展名</h3><p>通常,我们对特定类型的所有文件感兴趣. 这可以用<code>-e</code> (或) <code>--extension</code>选择权. 在这里,我们搜索FD仓库中的所有md文件:</p><pre class=" language-language-zsh"><code class="language-language-zsh">> cd fd> fd -e mdCONTRIBUTING.mdREADME.md</code></pre><p>这个<code>-e</code>选项可以与搜索模式结合使用:</p><pre class=" language-language-zsh"><code class="language-language-zsh">> fd -e rs modsrc/fshelper/mod.rssrc/lscolors/mod.rstests/testenv/mod.rs</code></pre><p>下载地址：<a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener">https://github.com/sharkdp/fd</a></p><h2 id="4-ripgrep"><a class="header-anchor" href="#4-ripgrep">¶</a>4 ripgrep</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220618373.gif" alt=""></p><p>上图为 grep（左）与 rg（右）命令执行时的对比。</p><p>与上述<code>fd</code>指令类似，<code>ripgrep</code>是<code>grep</code>命令的替代方法， 不过<code>ripgrep</code>的执行速度更快，而且具有健全的默认配置以及丰富的彩色输出。</p><p>它同样会跳过被<code>.gitignore</code>忽略以及隐藏的文件，因此如果有特殊需要，我们可以设置指令别名：<code>rga ='rg -uuu'</code>。它会禁用所有智能筛选，并使<code>ripgrep</code>的表现与标准的 grep 指令一致。</p><h3 id="简单搜索-v2"><a class="header-anchor" href="#简单搜索-v2">¶</a>简单搜索</h3><pre class=" language-language-bash"><code class="language-language-bash">ls | rg App</code></pre><h3 id="正则表达式搜索-v2"><a class="header-anchor" href="#正则表达式搜索-v2">¶</a>正则表达式搜索</h3><pre class=" language-language-bash"><code class="language-language-bash">ls | rg ^App.*$</code></pre><h3 id="指定文件搜索"><a class="header-anchor" href="#指定文件搜索">¶</a>指定文件搜索</h3><pre class=" language-language-bash"><code class="language-language-bash">rg  ^def.*$ 01_two-sum.py</code></pre><p>下载地址：<a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">https://github.com/BurntSushi/ripgrep</a></p><h2 id="5-htop-和-glances"><a class="header-anchor" href="#5-htop-和-glances">¶</a>5 htop 和 glances</h2><p>在 Linux 或 Mac 上显示进程运行状态信息最常用工具是我们熟悉的<code>top</code>，它是每位系统管理员的好帮手。而且，即使是像我一样主要从事网络开发，查看计算机的运行状况也很有用。你知道，只是看一下当前到底是 Docker 进程还是 Chrome 进程吃掉了你所有的 RAM，应该如何做吗？</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220647892.jpeg" alt=""></p><p><code>htop</code>工具是<code>top</code>工具的绝佳替代品。</p><p><code>top</code>工具是非常基础的监控工具，提供的功能有限，因此很多人转去使用 htop。<code>htop</code>比起<code>top</code>，优势很明显——除了功能更加完善以外，它的色彩搭配也很丰富，整体上使用起来更加友好。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220657583.jpeg" alt=""></p><p>借助 glances，还可以让你一目了然地快速了解系统当前状态。</p><p>glances 是<code>htop</code>的补充工具。除了列出所有进程及其 CPU 和内存使用情况之外，它还可以显示有关系统的其他信息，比如：</p><ul><li><p>网络及磁盘使用情况</p></li><li><p>文件系统已使用的空间和总空间</p></li><li><p>来自不同传感器（例如电池）的数据</p></li><li><p>以及最近消耗过多资源的进程列表</p></li></ul><p>我选择使用<code>htop</code>来筛选和终止进程，因为对我来讲，效率提高了不少，我也使用 <code>glances</code>可以快速浏览一下计算机的运行状况。它提供 API 接口、Web UI 以及支持各种导出格式，因此你可以将系统监视提高到一个新 Level。因此我在这里强烈推荐一波！</p><p>htop 下载地址：<a href="https://hisham.hm/htop/" target="_blank" rel="noopener">https://hisham.hm/htop/</a></p><p>glances 下载地址：<a href="https://nicolargo.github.io/glances/" target="_blank" rel="noopener">https://nicolargo.github.io/glances/</a></p><h2 id="6-virtualenv"><a class="header-anchor" href="#6-virtualenv">¶</a>6 virtualenv</h2><p>Virtualenv 是用于在 Python 中创建虚拟环境的工具（比起内置的<code>venv</code>模块，我更喜欢 Virtualenv）。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220804528.jpeg" alt=""></p><p>virtualenvwrapper 是 virtualenv 的虚拟环境管理器。它提供了许多命令来执行快速创建、列出或删除虚拟环境等操作。</p><p>virtualenv 下载地址：</p><p><a href="https://pypi.org/project/virtualenv/" target="_blank" rel="noopener">https://pypi.org/project/virtualenv/</a></p><h2 id="7-Homebrew"><a class="header-anchor" href="#7-Homebrew">¶</a>7 Homebrew</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220810324.jpeg" alt=""></p><p>如果你使用的是 Mac，那我就无需再介绍 Homebrew 了。它是 macOS 上被业界普遍认可的软件包管理器。</p><p>下载地址：<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p><p>在Mac下面安装Mysql、Redis、Node之类软件的时候，比较方便的方式是使用Homebrew（号称是The missing package manager for OS X）。不过Homebrew是命令行方式，用起来不是那么的友好，所以就有了Cakebrew。</p><p>网站：<a href="https://www.cakebrew.com/" target="_blank" rel="noopener">https://www.cakebrew.com/</a></p><p>非常友好的图形界面，使用起来简单快捷。</p><p>而LaunchRocket呢，则是一个帮助管理Homebrew安装的服务的软件，比如你使用Homebrew安装的Mysql、Redis、MongoDB，是让它自启动呢，还是手动启动，传统方式需要使用命令行的命令，而使用LaunchRocket则可以在图形界面中进行管理了！</p><p>网站：<a href="https://github.com/jimbojsb/launchrocket" target="_blank" rel="noopener">https://github.com/jimbojsb/launchrocket</a></p><h2 id="8-tree"><a class="header-anchor" href="#8-tree">¶</a>8 tree</h2><p>你可以通过<code>brew install tree</code>安装该工具。如果要查看给定目录的内容，那么 tree 是执行此操作的必备工具。它能以漂亮的树状结构显示所有子目录及文件：</p><pre><code>$ tree ..├── recovery.md├── README.md├── archive├── automator│   ├── Open\\ Iterm2.workflow│   │   └── Contents│   │       ├── Info.plist│   │       ├── QuickLook│   │       │   └── Thumbnail.png│   │       └── document.wflow│   └── Start\\ Screen\\ Saver.workflow├── brew-cask.sh</code></pre><h2 id="9-bat"><a class="header-anchor" href="#9-bat">¶</a>9 bat</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220820634.jpeg" alt=""></p><p>类似于在终端中常用的用于显示文件内容的<code>cat</code>命令，但是<code>bat</code>效果更佳。</p><p>它增加了语法高亮显示，git gutter 标记（如果适用），自动分页（如果文件很大）等功能，并且使得输出的内容阅读起来更加友好。</p><p>bat 下载地址：<a href="https://github.com/sharkdp/bat" target="_blank" rel="noopener">https://github.com/sharkdp/bat</a></p><h2 id="10-httpie"><a class="header-anchor" href="#10-httpie">¶</a>10 httpie</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220827622.gif" alt=""></p><p>如果你需要发送一些 HTTP 请求，但发现使用<code>curl</code>不够直观，那么请尝试一下<code>httpie</code>。这是一款非常好用的<code>curl</code>替代工具。合理的默认配置以及简洁的语法使它更易于使用，命令返回也是彩色输出，甚至支持为不同类型的身份验证安装相应的插件。</p><p>httpie 下载地址：<a href="https://httpie.org/" target="_blank" rel="noopener">https://httpie.org/</a></p><h2 id="11-tldr"><a class="header-anchor" href="#11-tldr">¶</a>11 tldr</h2><p>简化版的命令帮助手册。“man pages” 包含了 Linux 软件的手册，这些手册解释了如何使用给定的命令。你可以尝试运行<code>man cat</code>或<code>man grep</code>来查看相关命令的帮助手册。它们描述的非常详细，有时可能难以掌握。因此，<code>tldr</code>社区的目的，就是将每个命令的帮助手册进行简化，方便用户查阅。</p><p><code>tldr</code>适用于几乎所有的受欢迎的软件。正如我提到的，这是社区的努力和功劳，虽然不太可能包含所有的软件的简化帮助手册。但是当某个帮助手册被纳入管理并起作用时，它提供的信息通常就是你要查找的内容。</p><p>比如，如果你要创建一些文件的 gzip 压缩存档，<code>man tar</code>可以为你提供可能的参数选择。而<code>tldr tar</code>会列出一些我们常见的示例——如图所示，第二个示例正是你要执行的操作：</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220836708.jpeg" alt=""></p><p>“man pages” 展示的信息太全面了，但是很多时候使用<code>tldr</code>可以更快地帮你找到特定信息，这才是用户真正想要的。</p><p>tldr 下载地址：<a href="https://tldr.sh/" target="_blank" rel="noopener">https://tldr.sh/</a></p><h2 id="12-exa"><a class="header-anchor" href="#12-exa">¶</a>12 exa</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220843370.jpeg" alt=""></p><p><code>exa</code>是<code>ls</code>命令的一个可替代方案。</p><p>它色彩艳丽，还可以显示 git 状态等其他信息，自动将文件大小转换为方便人们阅读的单位，并且所有这些都保持与<code>ls</code>几乎相同的执行速度。虽然我很喜欢这个工具并推荐给你们，但由于某种原因，我仍然坚持使用 ls。</p><p>exa 下载地址：<a href="https://the.exa.website/" target="_blank" rel="noopener">https://the.exa.website/</a></p><h2 id="13-litecli-和-mycli"><a class="header-anchor" href="#13-litecli-和-mycli">¶</a>13 litecli 和 mycli</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220850333.gif" alt=""></p><p>这是我首选的 SQLite 和 mysql的解决方案。借助自动提示和语法突出显示，它们比默认的<code>sqlite3</code>和<code>mysql</code>工具要好用很多。</p><p>litecli 下载地址：<a href="https://litecli.com/" target="_blank" rel="noopener">https://litecli.com/</a></p><p>mycli 下载地址：<a href="https://www.mycli.net/" target="_blank" rel="noopener">https://www.mycli.net/</a></p><h2 id="14-ncdu"><a class="header-anchor" href="#14-ncdu">¶</a>14 ncdu</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/640-20201227220855650.jpeg" alt=""></p><p>这是在终端进行磁盘分析时使用的工具，它使用起来简单快捷。当我需要释放一些硬盘空间时，会默认使用这款工具。</p><p>ncdu 下载地址：<a href="https://dev.yorhel.nl/ncdu" target="_blank" rel="noopener">https://dev.yorhel.nl/ncdu</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CLI </tag>
            
            <tag> 终端工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件间通信方式</title>
      <link href="/2020/12/27/vue-zu-jian-jian-tong-xin-liu-chong-fang-shi-wan-zheng-ban/"/>
      <url>/2020/12/27/vue-zu-jian-jian-tong-xin-liu-chong-fang-shi-wan-zheng-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>组件是 vue.js 最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/1460000019208629.png" alt="1460000019208629"></p><p>如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。</p><p>针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。本文总结了 vue 组件间通信的几种方式，如 <code>props</code>/<code>$emit</code>、<code>$emit</code>/<code>$on</code>、<code>vuex</code>、<code>$parent</code> / <code>$children</code>、<code>$attrs</code>/<code>$listeners</code>和 <code>provide</code>/<code>inject</code>，以通俗易懂的实例讲述这其中的差别及使用场景，希望对小伙伴有些许帮助。</p><h2 id="方法一、props-emit"><a class="header-anchor" href="#方法一、props-emit">¶</a>方法一、<code>props</code>/<code>$emit</code></h2><p>父组件 A 通过 <code>props</code> 的方式向子组件 B 传递，B to A 通过在 B 组件中 <code>$emit</code>, A 组件中 <code>v-on</code> 的方式实现。</p><h3 id="1-父组件向子组件传值"><a class="header-anchor" href="#1-父组件向子组件传值">¶</a>1. 父组件向子组件传值</h3><p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件 <em>Users.vue</em> 中如何获取父组件 <em>App.vue</em> 中的数据 <code>users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</code></p><h4 id="1-1-App-vue父组件"><a class="header-anchor" href="#1-1-App-vue父组件">¶</a>1.1 <em>App.vue</em>父组件</h4><pre class=" language-language-js"><code class="language-language-js"><template>  <div id="app">    <!-- 前者自定义名称便于子组件调用，后者要传递数据名 -->    <users v-bind:users="users"></users>  </div></template><script>import Users from "./components/Users"export default {  name: 'App',  data(){    return{      users:["Henry","Bucky","Emily"]    }  },  components:{    "users":Users  }}</code></pre><h4 id="1-2-Users-vue子组件"><a class="header-anchor" href="#1-2-Users-vue子组件">¶</a>1.2 <em>Users.vue</em>子组件</h4><pre class=" language-language-js"><code class="language-language-js"><template>  <div class="hello">    <ul>      <li v-for="user in users">{{user}}</li>//遍历传递过来的值，然后呈现到页面    </ul>  </div></template><script>export default {  name: 'HelloWorld',  props:{    users:{           //这个就是父组件中子标签自定义名字      type:Array,      required:true    }  }}</script></code></pre><blockquote><p><strong>总结：父组件通过 props 向下传递数据给子组件。注：组件中的数据共有三种形式：<code>data</code>、<code>props</code>、<code>computed</code></strong></p></blockquote><h3 id="2-子组件向父组件传值（通过事件形式）"><a class="header-anchor" href="#2-子组件向父组件传值（通过事件形式）">¶</a>2. 子组件向父组件传值（通过事件形式）</h3><p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击 “<em>Vue.js Demo</em>” 后，子组件向父组件传递值，文字由原来的 “传递的是一个值” 变成“子向父组件传值”，实现子组件向父组件值的传递。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/1460000019208630.png" alt="1460000019208630"></p><h4 id="2-1-Header-vue-子组件"><a class="header-anchor" href="#2-1-Header-vue-子组件">¶</a>2.1 <em>Header.vue</em> 子组件</h4><pre class=" language-language-js"><code class="language-language-js"><template>  <header>    <h1 @click="changeTitle">{{title}}</h1>//绑定一个点击事件  </header></template><script>export default {  name: 'app-header',  data() {    return {      title:"Vue.js Demo"    }  },  methods:{    changeTitle() {      this.$emit("titleChanged","子向父组件传值");//自定义事件  传递值“子向父组件传值”    }  }}</script></code></pre><h4 id="2-2-App-vue-父组件"><a class="header-anchor" href="#2-2-App-vue-父组件">¶</a>2.2 <em>App.vue</em> 父组件</h4><pre class=" language-language-js"><code class="language-language-js"><template>  <div id="app">    <app-header v-on:titleChanged="updateTitle" ></app-header>    <!-- 与子组件titleChanged自定义事件保持一致 -->    <!-- updateTitle($event)接受传递过来的文字 -->    <h2>{{title}}</h2>  </div></template><script>import Header from "./components/Header"export default {  name: 'App',  data(){    return{      title:"传递的是一个值"    }  },  methods:{    updateTitle(e){   //声明这个函数      this.title = e;    }  },  components:{   "app-header":Header,  }}</script></code></pre><blockquote><p><strong>总结：子组件通过 <code>events</code> 给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</strong></p></blockquote><h2 id="方法二、-emit-on"><a class="header-anchor" href="#方法二、-emit-on">¶</a>方法二、<code>$emit</code>/<code>$on</code></h2><p><strong>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件, 巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级</strong>。当我们的项目比较大时，可以选择更好的状态管理解决方案 vuex。</p><h4 id="1-具体实现方式："><a class="header-anchor" href="#1-具体实现方式：">¶</a>1. 具体实现方式：</h4><pre class=" language-language-js"><code class="language-language-js">var Event=new Vue();Event.$emit(事件名,数据);Event.$on(事件名,data => {});</code></pre><h4 id="2-举个例子"><a class="header-anchor" href="#2-举个例子">¶</a>2. 举个例子</h4><p>假设兄弟组件有三个，分别是 A、B、C 组件，C 组件如何获取 A 或者 B 组件的数据</p><pre class=" language-language-js"><code class="language-language-js"><div id="itany">    <my-a></my-a>    <my-b></my-b>    <my-c></my-c></div><template id="a">  <div>    <h3>A组件：{{name}}</h3>    <button @click="send">将数据发送给C组件</button>  </div></template><template id="b">  <div>    <h3>B组件：{{age}}</h3>    <button @click="send">将数组发送给C组件</button>  </div></template><template id="c">  <div>    <h3>C组件：{{name}}，{{age}}</h3>  </div></template><script>var Event = new Vue(); //定义一个空的Vue实例var A = {    template: '#a',    data() {      return {        name: 'tom'      }    },    methods: {      send() {        Event.$emit('data-a', this.name);      }    }}var B = {    template: '#b',    data() {      return {        age: 20      }    },    methods: {      send() {        Event.$emit('data-b', this.age);      }    }}var C = {    template: '#c',    data() {      return {        name: '',        age: ""      }    },    mounted() {//在模板编译完成后执行     Event.$on('data-a',name => {         this.name = name;//箭头函数内部不会产生新的this，这边如果不用=>,this指代Event     })     Event.$on('data-b',age => {         this.age = age;     })    }}var vm = new Vue({    el: '#itany',    components: {      'my-a': A,      'my-b': B,      'my-c': C    }});    </script></code></pre><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/1460000019208631.gif" alt="1460000019208631"><br><code>$on</code> 监听了自定义事件 data-a 和 data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。</p><h2 id="方法三、vuex"><a class="header-anchor" href="#方法三、vuex">¶</a>方法三、vuex</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/1460000019208632.png" alt="1460000019208632"></p><h3 id="1-简要介绍-Vuex-原理"><a class="header-anchor" href="#1-简要介绍-Vuex-原理">¶</a>1. 简要介绍 Vuex 原理</h3><p>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 进行，Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作 (常见于调用后端接口异步获取更新数据) 或批量的同步操作需要走 Action，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根据 State 的变化，渲染到视图上。</p><h3 id="2-简要介绍各模块在流程中的功能："><a class="header-anchor" href="#2-简要介绍各模块在流程中的功能：">¶</a>2. 简要介绍各模块在流程中的功能：</h3><ul><li>Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。</li><li>dispatch：操作行为触发方法，是唯一能执行 action 的方法。</li><li>actions：<strong>操作行为处理模块, 由组件中的<code>$store.dispatch('action 名称', data1)</code>来触发。然后由 commit() 来触发 mutation 的调用 , 间接更新 state</strong>。负责处理 Vue Components 接收到的所有交互行为。包含同步 / 异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。</li><li>commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。</li><li>mutations：<strong>状态改变操作方法，由 actions 中的<code>commit('mutation 名称')</code>来触发</strong>。是 Vuex 修改 state 的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。</li><li>state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。</li><li>getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。</li></ul><h3 id="3-Vuex-与-localStorage"><a class="header-anchor" href="#3-Vuex-与-localStorage">¶</a>3.Vuex 与 localStorage</h3><p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，<strong>具体做法应该在 vuex 里数据改变的时候把数据拷贝一份保存到 localStorage 里面，刷新之后，如果 localStorage 里有保存的数据，取出来再替换 store 里的 state。</strong></p><pre class=" language-language-js"><code class="language-language-js">let defaultCity = "上海"try {  // 用户关闭了本地存储功能，此时在外层加个try...catch  if (!defaultCity) {    defaultCity = JSON.parse(window.localStorage.getItem('defaultCity'))  }} catch (e) {}export default new Vuex.Store({  state: {    city: defaultCity  },  mutations: {    changeCity(state, city) {      state.city = city      try {        window.localStorage.setItem('defaultCity', JSON.stringify(state.city));        // 数据改变的时候把数据拷贝一份保存到localStorage里面      } catch (e) {      }    }  }})</code></pre><p>这里需要注意的是：由于 vuex 里，我们保存的状态，都是数组，而 localStorage 只支持字符串，所以需要用 JSON 转换：</p><pre class=" language-language-js"><code class="language-language-js">JSON.stringify(state.subscribeList);   // array -> stringJSON.parse(window.localStorage.getItem("subscribeList"));    // string -> array</code></pre><h2 id="方法四、-attrs-listeners"><a class="header-anchor" href="#方法四、-attrs-listeners">¶</a>方法四、<code>$attrs</code>/<code>$listeners</code></h2><p>多级组件嵌套需要传递数据时，通常使用的方法是通过 vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此 Vue2.4 版本提供了另一种方法 ----<code>$attrs</code>/<code>$listeners</code></p><ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 interitAttrs 选项一起使用。</li><li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件</li></ul><p>接下来我们看个跨级通信的例子：</p><pre class=" language-language-js"><code class="language-language-js">// index.vue<template>  <div>    <h2>浪里行舟</h2>    <child-com1      :foo="foo"      :boo="boo"      :coo="coo"      :doo="doo"      title="前端工匠"    ></child-com1>  </div></template><script>const childCom1 = () => import("./childCom1.vue");export default {  components: { childCom1 },  data() {    return {      foo: "Javascript",      boo: "Html",      coo: "CSS",      doo: "Vue"    };  }};</script></code></pre><pre class=" language-language-js"><code class="language-language-js">// childCom1.vue<template class="border">  <div>    <p>foo: {{ foo }}</p>    <p>childCom1的$attrs: {{ $attrs }}</p>    <child-com2 v-bind="$attrs"></child-com2>  </div></template><script>const childCom2 = () => import("./childCom2.vue");export default {  components: {    childCom2  },  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性  props: {    foo: String // foo作为props属性绑定  },  created() {    console.log(this.$attrs); // { "boo": "Html", "coo": "CSS", "doo": "Vue", "title": "前端工匠" }  }};</script></code></pre><pre class=" language-language-js"><code class="language-language-js">// childCom2.vue<template>  <div class="border">    <p>boo: {{ boo }}</p>    <p>childCom2: {{ $attrs }}</p>    <child-com3 v-bind="$attrs"></child-com3>  </div></template><script>const childCom3 = () => import("./childCom3.vue");export default {  components: {    childCom3  },  inheritAttrs: false,  props: {    boo: String  },  created() {    console.log(this.$attrs); // {"coo": "CSS", "doo": "Vue", "title": "前端工匠" }  }};</script></code></pre><pre class=" language-language-js"><code class="language-language-js">// childCom3.vue<template>  <div class="border">    <p>childCom3: {{ $attrs }}</p>  </div></template><script>export default {  props: {    coo: String,    title: String  }};</script></code></pre><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/1460000019208633.png" alt=""><br>如上图所示<code>$attrs</code>表示没有继承数据的对象，格式为 {属性名：属性值}。Vue2.4 提供了<code>$attrs</code> , <code>$listeners</code> 来传递数据与事件，跨级组件之间的通讯变得更简单。</p><p>简单来说：<code>$attrs</code>与<code>$listeners</code> 是两个对象，<code>$attrs</code> 里存放的是父组件中绑定的非 Props 属性，<code>$listeners</code>里存放的是父组件中绑定的非原生事件。</p><h2 id="方法五、provide-inject"><a class="header-anchor" href="#方法五、provide-inject">¶</a>方法五、provide/inject</h2><h4 id="1-简介"><a class="header-anchor" href="#1-简介">¶</a>1. 简介</h4><p>Vue2.2.0 新增 API, 这对选项需要一起使用，<strong>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效</strong>。一言而蔽之：祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。<br><strong>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</strong>。</p><h4 id="2-举个例子-v2"><a class="header-anchor" href="#2-举个例子-v2">¶</a>2. 举个例子</h4><p>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p><pre class=" language-language-js"><code class="language-language-js">// A.vueexport default {  provide: {    name: '浪里行舟'  }}</code></pre><pre class=" language-language-js"><code class="language-language-js">// B.vueexport default {  inject: \['name'\],  mounted () {    console.log(this.name);  // 浪里行舟  }}</code></pre><p>可以看到，在 A.vue 里，我们设置了一个 <strong>provide: name</strong>，值为 浪里行舟，它的作用就是将 <strong>name</strong> 这个变量提供给它的所有子组件。而在 B.vue 中，通过 <code>inject</code> 注入了从 A 组件中提供的 <strong>name</strong> 变量，那么在组件 B 中，就可以直接通过 <strong><a href="http://this.name" target="_blank" rel="noopener">this.name</a></strong> 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。</p><p>需要注意的是：<strong>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的</strong> ----vue 官方文档<br>所以，上面 A.vue 的 name 如果改变了，B.vue 的 <a href="http://this.name" target="_blank" rel="noopener">this.name</a> 是不会改变的，仍然是 浪里行舟。</p><h4 id="3-provide-与-inject-怎么实现数据响应式"><a class="header-anchor" href="#3-provide-与-inject-怎么实现数据响应式">¶</a>3.provide 与 inject 怎么实现数据响应式</h4><p>一般来说，有两种办法：</p><ul><li>provide 祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如 props，methods</li><li>使用 2.6 最新 API Vue.observable 优化响应式 provide(推荐)</li></ul><p>我们来看个例子：孙组件 D、E 和 F 获取 A 组件传递过来的 color 值，并能实现数据响应式变化，即 A 组件的 color 变化后，组件 D、E、F 会跟着变（核心代码如下：）</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/1460000019208634.png" alt=""></p><pre class=" language-language-js"><code class="language-language-js">// A 组件 <div>      <h1>A 组件</h1>      <button @click="() => changeColor()">改变color</button>      <ChildrenB />      <ChildrenC /></div>......  data() {    return {      color: "blue"    };  },  // provide() {  //   return {  //     theme: {  //       color: this.color //这种方式绑定的数据并不是可响应的  //     } // 即A组件的color变化后，组件D、E、F不会跟着变  //   };  // },  provide() {    return {      theme: this//方法一：提供祖先组件的实例    };  },  methods: {    changeColor(color) {      if (color) {        this.color = color;      } else {        this.color = this.color === "blue" ? "red" : "blue";      }    }  }  // 方法二:使用2.6最新API Vue.observable 优化响应式 provide  // provide() {  //   this.theme = Vue.observable({  //     color: "blue"  //   });  //   return {  //     theme: this.theme  //   };  // },  // methods: {  //   changeColor(color) {  //     if (color) {  //       this.theme.color = color;  //     } else {  //       this.theme.color = this.theme.color === "blue" ? "red" : "blue";  //     }  //   }  // }</code></pre><pre class=" language-language-js"><code class="language-language-js">// F 组件 <template functional>  <div class="border2">    <h3 :style="{ color: injections.theme.color }">F 组件</h3>  </div></template><script>export default {  inject: {    theme: {      //函数式组件取值不一样      default: () => ({})    }  }};</script></code></pre><p>虽说 provide 和 inject 主要为高阶插件 / 组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！</p><h2 id="方法六、-parent-children与-ref"><a class="header-anchor" href="#方法六、-parent-children与-ref">¶</a>方法六、<code>$parent</code> / <code>$children</code>与 <code>ref</code></h2><ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li></ul><p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 <code>ref</code>来访问组件的例子：</p><pre class=" language-language-js"><code class="language-language-js">// component-a 子组件export default {  data () {    return {      title: 'Vue.js'    }  },  methods: {    sayHello () {      window.alert('Hello');    }  }}</code></pre><pre class=" language-language-js"><code class="language-language-js">// 父组件<template>  <component-a ref="comA"></component-a></template><script>  export default {    mounted () {      const comA = this.$refs.comA;      console.log(comA.title);  // Vue.js      comA.sayHello();  // 弹窗    }  }</script></code></pre><p>不过，<strong>这两种方法的弊端是，无法在跨级或兄弟间通信</strong>。</p><pre class=" language-language-js"><code class="language-language-js">// parent.vue<component-a></component-a><component-b></component-b><component-b></component-b></code></pre><p>我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。</p><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>常见使用场景可以分为三类：</p><ul><li>父子通信：</li></ul><p>父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 / 子链也可以通信（<code>$parent</code> / <code>$children</code>）；ref 也可以访问组件实例；provide / inject API；<code>$attrs/$listeners</code></p><ul><li>兄弟通信：</li></ul><p>Bus；Vuex</p><ul><li>跨级通信：</li></ul><p>Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></p><h2 id="参考文章"><a class="header-anchor" href="#参考文章">¶</a>参考文章</h2><ul><li><a href="https://juejin.im/book/5bc844166fb9a05cd676ebca" target="_blank" rel="noopener">Vue.js 组件精讲</a></li><li><a href="https://cn.vuejs.org/v2/api/#inheritAttrs" target="_blank" rel="noopener">Vue.js 官方文档</a></li><li><a href="https://time.geekbang.org/course/detail/163-86419" target="_blank" rel="noopener">Vue 开发实战</a></li><li><a href="https://webcache.googleusercontent.com/search?q=cache:GCLcuCsGrVIJ:https://bingzhe.github.io/2017/08/27/vuex%25E6%2595%25B0%25E6%258D%25AE%25E6%259C%25AC%25E5%259C%25B0%25E5%2582%25A8%25E5%25AD%2598/+&amp;cd=12&amp;hl=zh-CN&amp;ct=clnk&amp;gl=us" target="_blank" rel="noopener">Vuex 数据本地储存</a></li><li><a href="https://tech.meituan.com/vuex_code_analysis.html" target="_blank" rel="noopener">Vuex 框架原理与源码分析</a></li><li><a href="https://juejin.im/post/5c77c4ae518825407505e262" target="_blank" rel="noopener">Vue 组件通信方式全面详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-中间件</title>
      <link href="/2020/12/10/django-zhong-jian-jian/"/>
      <url>/2020/12/10/django-zhong-jian-jian/</url>
      
        <content type="html"><![CDATA[<h1>1 中间件介绍</h1><p>Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。</p><p>中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。</p><p>我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。</p><blockquote><p>因为改变的是全局，所以需要谨慎实用，用不好会影响到性能</p></blockquote><h1>2 中间件作用</h1><p>如果你想修改请求，例如被传送到<em>view</em>中的**<code>HttpRequest</code><strong>对象。 或者你想修改<em>view</em>返回的</strong><code>HttpResponse</code>**对象，这些都可以通过中间件来实现。</p><p>可能你还想在<em>view</em>执行之前做一些操作，这种情况就可以用 <code>middleware</code>来实现。</p><p><strong><em>Django</em>默认的中间件</strong>：（在<em>django</em>项目的<em>settings</em>模块中，有一个 <code>MIDDLEWARE_CLASSES</code> 变量，其中每一个元素就是一个中间件，如下图）</p><pre class=" language-language-python"><code class="language-language-python">MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    # 为request/response提供了几种xss脚本过滤的安全改进，无它不安全    'django.contrib.sessions.middleware.SessionMiddleware',    # 开启session会话支持，无它无session    'django.middleware.common.CommonMiddleware',    # 基于APPEND_SLASH和PREPEND_WWW的设置来重写URL，    # 如果APPEND_SLASH设为True，并且初始URL 没有以斜线结尾以及在URLconf 中没找到对应定义，这时形成一个斜线结尾的新URL；    # 如果PREPEND_WWW设为True，前面缺少 www.的url将会被重定向到相同但是以一个www.开头的ur    'django.middleware.csrf.CsrfViewMiddleware',    # 添加跨站点请求伪造的保护，通过向POST表单添加一个隐藏的表单字段，并检查请求中是否有正确的值，无它无csrf保护    'django.contrib.auth.middleware.AuthenticationMiddleware',    # 在视图函数执行前向每个接收到的user对象添加HttpRequest属性，表示当前登录的用户，无它用不了request.user    'django.contrib.messages.middleware.MessageMiddleware',    # 开启基于Cookie和会话的消息支持，无它无message    'django.middleware.clickjacking.XFrameOptionsMiddleware',    # 对点击劫持的保护]</code></pre><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/12/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="中间件示意图"></p><h1>3 自定义中间件</h1><h2 id="3-1-创建中间件"><a class="header-anchor" href="#3-1-创建中间件">¶</a>3.1 创建中间件</h2><p>创建中间件有两种方式：</p><h3 id="3-1-1-闭包函数构建"><a class="header-anchor" href="#3-1-1-闭包函数构建">¶</a>3.1.1 闭包函数构建</h3><ul><li><p>定义一个中间件闭包函数，然后返回一个可以被调用的中间件。</p></li><li><p>中间件闭包函数需要接收一个可以调用的<code>get_response</code>对象。</p></li><li><p>返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个<code>request</code>对象参数，返回一个<code>response</code>对象。</p></li></ul><pre class=" language-language-python"><code class="language-language-python">def my_middleware(get_response):    print('init 被调用')    def middleware(request):        print('before request 被调用')        response = get_response(request)        print('after response 被调用')        return response    return middleware</code></pre><h3 id="3-1-2-类构建"><a class="header-anchor" href="#3-1-2-类构建">¶</a>3.1.2 类构建</h3><p>需要继承 <code>django.utils.deprecation.MiddlewareMixin</code>这个类</p><p>可以重写的5个方法:</p><pre class=" language-language-python"><code class="language-language-python">1、process_request(self,request)2、process_view(self, request, callback, callback_args, callback_kwargs)3、process_template_response(self,request,response)4、process_exception(self, request, exception)5、process_response(self, request, response)</code></pre><p>以上方法的返回值可以是<code>None</code>或一个<code>HttpResponse</code>对象，如果是<code>None</code>，则继续按照<em>django</em>定义的规则向后继续执行，如果是<code>HttpResponse</code>对象，则直接将该对象返回给用户。</p><pre class=" language-language-python"><code class="language-language-python">class SimMiddleware(MiddlewareMixin):    def __init__(self, get_response):        print('init=====')        self.get_response = get_response    def process_request(self, request):        """        处理请求前: 在每个请求上，request对象产生之后，url匹配之前调用,返回None或HttpResponse对象        """        print('before request=====', request)    def process_view(self, request, view_func, *view_args, **view_kwargs):        """        :param view_func: Django即将使用的视图函数,它是实际的函数对象，而不是函数的名称作为字符串        :param view_args: 将传递给视图的位置参数的列表        :param view_kwargs: 将传递给视图的关键字参数的字典;                            view_args和view_kwargs都不包含第一个视图参数（request）        """        # 处理视图前：在每个请求上，url匹配之后，视图函数调用之前调用，返回None或HttpResponse对象        print('before view=======')    def process_template_response(self, request, response):        # 在视图函数执行完后立即执行的, 执行 该 函数有一个前提条件，那就是视图函数返回的对象要有一个 render() 方法        # （或者表明该对象是一个 TemplateResponse 对象或等价方法）        print("render template=======")        return response    def process_exception(self, request, exception):        # 这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象        print("raise exception=======")        return HttpResponse(exception)    def process_response(self, request, response):        # 处理响应后：视图函数调用之后，所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse对象        print('after response=======', response)        return response</code></pre><h2 id="3-2-注册中间件"><a class="header-anchor" href="#3-2-注册中间件">¶</a>3.2 注册中间件</h2><p>在<em>django</em>项目的<em>settings</em>模块中，在 <code>MIDDLEWARE_CLASSES</code> 变量中添加自定义中间件</p><pre class=" language-language-python"><code class="language-language-python">MIDDLEWARE = [  ...'book.middleware.my_middleware',  # book为应用名,middleware为文件名    'book.middleware.SimMiddleware']</code></pre><h2 id="3-3-中间件效果"><a class="header-anchor" href="#3-3-中间件效果">¶</a>3.3 中间件效果</h2><blockquote><p>首先是 项目启动时，中间件的初始化</p></blockquote><pre><code>init=====init 被调用</code></pre><h3 id="3-3-1-正常视图"><a class="header-anchor" href="#3-3-1-正常视图">¶</a>3.3.1 正常视图</h3><pre class=" language-language-python"><code class="language-language-python">class Index(View):    def get(self, request):        print("Index============")        return HttpResponse("hello Django")</code></pre><blockquote><p>当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求会依次穿过所有中间件的<code>process_request</code>方法,最后到达<code>views</code>的函数中，<code>views</code>函数处理后，在依次穿过所有中间件的<code>process_response</code>方法,最后返回给请求者。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">before request 被调用before request===== <WSGIRequest: GET '/'>before view=======Index============after response======= <HttpResponse status_code=200, "text/html; charset=utf-8">after response 被调用[21/Sep/2020 14:29:59] "GET / HTTP/1.1" 200 12</code></pre><h3 id="3-3-2-错误视图"><a class="header-anchor" href="#3-3-2-错误视图">¶</a>3.3.2 错误视图</h3><pre class=" language-language-python"><code class="language-language-python">class Index(View):    def get(self, request):        print("Index============")        3/0        return HttpResponse("hello Django")</code></pre><blockquote><p>此时，视图发生异常， 会执行中间件的 <code>process_exception</code>方法，而在该方法中，将异常信息作为响应返回，因此，页面显示<code>&quot;division by zero&quot;</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">before request 被调用before request===== <WSGIRequest: GET '/'>before view=======Index============raise exception=======after response======= <HttpResponse status_code=200, "text/html; charset=utf-8">after response 被调用[21/Sep/2020 14:34:15] "GET / HTTP/1.1" 200 16</code></pre><h3 id="3-3-3-模板视图"><a class="header-anchor" href="#3-3-3-模板视图">¶</a>3.3.3 模板视图</h3><pre class=" language-language-python"><code class="language-language-python">class Index(View):    def get(self, request):        print("Index============")        return TemplateResponse(request, 'index.html')</code></pre><blockquote><p>注意: 只有返回的对象是<code>TemplateResponse</code> 对象或等价方法时，才执行中间件的 <code>process_template_response</code>方法，直接调用<code>render</code>方法无效。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">before request 被调用before request===== <WSGIRequest: GET '/'>before view=======Index============render template=======after response======= <TemplateResponse status_code=200, "text/html; charset=utf-8">after response 被调用[21/Sep/2020 14:49:05] "GET / HTTP/1.1" 200 149</code></pre><blockquote><p><code>TemplateResponse</code> <strong>VS</strong> <code>render</code></p><p><code>TemplateResponse</code>将模板的渲染延迟到视图完成之后。这允许任何模板响应中间件在响应上运行，并有可能在呈现模板之前更改模板或上下文数据。模板响应中间件运行后，将渲染模板，并在将响应返回给客户端之前对渲染的内容运行常规响应中间件。</p><p><code>render()</code>立即呈现模板，并返回<code>HttpResponse</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-模板</title>
      <link href="/2020/12/09/django-mo-ban/"/>
      <url>/2020/12/09/django-mo-ban/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-邮件发送</title>
      <link href="/2020/12/03/django-you-jian-fa-song/"/>
      <url>/2020/12/03/django-you-jian-fa-song/</url>
      
        <content type="html"><![CDATA[<p>我们常常会用到一些发送邮件的功能，比如：有人注册网站之后，需要向其邮箱中发送激活链接，只有点击激活链接，激活账户之后，才允许登录。</p><h2 id="配置相关参数"><a class="header-anchor" href="#配置相关参数">¶</a>配置相关参数</h2><p>在 <a href="http://settings.py" target="_blank" rel="noopener">settings.py</a> 的最后面加上类似这些</p><pre class=" language-language-python"><code class="language-language-python">EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'EMAIL_USE_TLS = False   # 是否使用TLS安全传输协议(用于在两个通信应用程序之间提供保密性和数据完整性。)EMAIL_USE_SSL = True    # 是否使用SSL加密，qq企业邮箱要求使用EMAIL_HOST = 'smtp.163.com'   # 发送邮件的邮箱 的 SMTP服务器，这里用了163邮箱EMAIL_PORT = 465     # 发件箱的SMTP服务器端口EMAIL_HOST_USER = 'xxxxx@xmdaren.com'    # 发送邮件的邮箱地址EMAIL_HOST_PASSWORD = '*********'         # 发送邮件的邮箱密码(这里使用的是授权码)DEFAULT_FROM_EMAIL = EMAIL_HOST_USER  # 默认的发送方</code></pre><p>DEFAULT_FROM_EMAIL 还可以写成这样：</p><pre class=" language-language-python"><code class="language-language-python">DEFAULT_FROM_EMAIL = 'mac <mac@163.com>'</code></pre><p>这样别人收到的邮件中就会有你设定的名称。</p><p>下面是一些常用的邮箱：</p><p><a href="http://help.163.com/09/1223/14/5R7P3QI100753VB8.html" target="_blank" rel="noopener">163 邮箱</a>   <a href="http://www.126.com/help/client_04.htm" target="_blank" rel="noopener">126 邮箱</a>  <a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=166&amp;&amp;id=28" target="_blank" rel="noopener">QQ 邮箱</a></p><p>其它邮箱参数可以登陆邮箱寻找帮助信息，也可以尝试在搜索引擎中搜索：“SMTP 邮箱名称”，比如：“163 SMTP” 进行查找。</p><h2 id="发送邮件"><a class="header-anchor" href="#发送邮件">¶</a>发送邮件</h2><p>发送普通邮件可以使用<code>django.core.mail</code>模块下的<code>send_mail</code>函数进行</p><pre class=" language-language-python"><code class="language-language-python">send_mail(subject, message, from_email, recipient_list, fail_silently=False, html_message=None)# 将邮件发送至recipient_list中的每一个收件人'''subject: 发送邮件标题message: 发送邮件正文from_email: 发件人邮箱地址recipient_list: 一个字符串列表，每一个数据为接收者的邮箱地址html_message: 如果指定该值，则发送的内容类型为text/html为一个html邮件内容'''</code></pre><pre class=" language-language-python"><code class="language-language-python">from django.conf import settingsfrom django.core.mail import send_maildef send_regiser_active_email(to_email, username, token):    '''发送激活邮件'''    active_url = "{}/user/active/{}".format(settings.HOST_URL, token)    subject = "xxx欢迎信息"    message = '邮件正文'    sender = settings.DEFAULT_FROM_EMAIL    receiver = [to_email]    html_message = '<h1>{}, 欢迎您成为xxx注册会员</h1>请点击下面链接激活您的账户<br/><a href="{}">{}</a>'.format(username, active_url,                                                                                            active_url)    send_mail(subject, message, sender, receiver, html_message=html_message)    </code></pre><h2 id="itsdangerous"><a class="header-anchor" href="#itsdangerous">¶</a>itsdangerous</h2><p>有时您只想将一些数据发送到不受信任的环境。但是如何安全地做到这一点？诀窍就是签名。只要知道一个密钥，您就可以对数据进行加密签名并将其移交给其他人。当您取回数据时，可以轻松确保没有人篡改数据。使用itsdangerous可以实现此种方案。</p><pre class=" language-language-python"><code class="language-language-python">from itsdangerous import TimedJSONWebSignatureSerializer as TJSSsalt='abcdefg' # 这里就是配置加密的规则serializer=TJSS(salt,expires_in=3600) # 过期时间一小时user_info = {'user_id':1}# 加密阶段res = serializer.dumps(user_info)  # 得到加密后的数据，会返回一个字节类型的数据token = res.decode() # 解码为strprint(token)# 得到的数据如下，就是包含数据和盐值的token了，只有在知道盐值的时候才能被解密出来#eyJhbGciOiJIUzUxMiIsImlhdCI6MTU2MjY0Nzg4NCwiZXhwIjoxNTYyNjUxNDg0fQ.eyJjb25maXJtIjo1fQ.93DtXu9vHQDW0lr7saJhDBt-dcBxNNh_IMTR-JhWnrT-ujQ9SwevSUyW0p2txLS-gtyRHPlH1eD9INksIWilkA# 解密阶段res=serializer.loads(token)print(res)# 返回的数据如下：# {'user_id':1}</code></pre><blockquote><p>当token被修改时，解密时，会抛出 <code>itsdangerous.Badsignature</code></p><p>当token过期时, 解密时，会抛出 <code>itsdangerous.SignatureExpired: Signature expired</code></p></blockquote><h2 id="邮件激活"><a class="header-anchor" href="#邮件激活">¶</a>邮件激活</h2><p>注册成功，发送激活链接</p><pre class=" language-language-python"><code class="language-language-python">from itsdangerous import TimedJSONWebSignatureSerializer as Serializer        # 加密用户信息，生成tokeninfo = {'confirm': user.id}serializer = Serializer(settings.SECRET_KEY, 3600)token = serializer.dumps(info).decode()# 发送邮件send_regiser_active_email(email, username, token)</code></pre><p>用户点击激活链接，进行账户激活</p><pre class=" language-language-python"><code class="language-language-python"># 进行解密， 获取要激活的用户信息serializer = Serializer(settings.SECRET_KEY, 3600)try:    # 获取用户id    info = serializer.loads(token)  # 在路由匹配中，获取tokenexcept (SignatureExpired, BadSignature) as error:    return redirect(reverse("user:activeemail"))  # 激活失败，重写跳转到邮箱激活页面else:    user_id = info.get("confirm")    # 获取用户信息    user = User.objects.get(id=user_id)    user.is_active = 1    user.save()    # 跳转到登录界面    return redirect(reverse('user:login'))  # 激活成功，跳转到登录页面      </code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件 </tag>
            
            <tag> itsdangerous </tag>
            
            <tag> 临时身份令牌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-缓存</title>
      <link href="/2020/12/01/django-huan-cun/"/>
      <url>/2020/12/01/django-huan-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存简介"><a class="header-anchor" href="#缓存简介">¶</a>缓存简介</h2><p>在动态网站中,用户所有的请求,服务器都会去数据库中进行相应的增,删,查,改,渲染模板,执行业务逻辑,最后生成用户看到的页面.</p><p>当一个网站的用户访问量很大的时候,每一次的的后台操作,都会消耗很多的服务端资源,所以必须使用<strong>缓存</strong>来减轻后端服务器的压力.</p><p>缓存是将一些常用的数据保存到<strong>内存</strong>或者<strong>memcache</strong>中,在一定的时间内有人来访问这些数据时,则不再去执行数据库及渲染等操作,而是直接从内存或memcache的缓存中去取得数据,然后返回给用户。</p><h2 id="缓存方式"><a class="header-anchor" href="#缓存方式">¶</a>缓存方式</h2><blockquote><p>Django提供了6种缓存方式</p></blockquote><ul><li>开发调试缓存</li><li>内存缓存</li><li>文件缓存</li><li>数据库缓存</li><li>Memcache缓存(使用<code>python-memcached</code>模块)</li><li>Memcache缓存(使用<code>pylibmc</code>模块)</li></ul><p>经常使用的有<strong>文件缓存</strong>和<strong>Mencache</strong>缓存, 而选用不同的缓存方式，实际就是需要缓存的数据保存的位置不同。只需要修改django项目的配置文件<code>settings.py</code>，即可实现不同缓存方式的切换。</p><h3 id="开发调试"><a class="header-anchor" href="#开发调试">¶</a>开发调试</h3><blockquote><p>此模式为开发调试使用,实际上不执行任何操作</p></blockquote><pre class=" language-language-python"><code class="language-language-python">CACHES = {    'default': {        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',  # 缓存后台使用的引擎        'TIMEOUT': 300,  # 缓存超时时间（默认300秒，None表示永不过期，0表示立即过期）        'OPTIONS': {            'MAX_ENTRIES': 300,  # 最大缓存记录的数量（默认300）            'CULL_FREQUENCY': 3,  # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）        },    }}</code></pre><h3 id="内存缓存"><a class="header-anchor" href="#内存缓存">¶</a>内存缓存</h3><blockquote><p>将缓存内容保存至内存区域中</p></blockquote><pre class=" language-language-python"><code class="language-language-python">CACHES = {    'default': {        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',  # 指定缓存使用的引擎        'LOCATION': 'unique-snowflake',  # 写在内存中的变量的唯一值         'TIMEOUT': 300,  # 缓存超时时间(默认为300秒,None表示永不过期)        'OPTIONS': {            'MAX_ENTRIES': 300,  # 最大缓存记录的数量（默认300）            'CULL_FREQUENCY': 3,  # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）        }    }}</code></pre><h3 id="文件缓存"><a class="header-anchor" href="#文件缓存">¶</a>文件缓存</h3><blockquote><p>把缓存数据存储在文件中</p></blockquote><pre class=" language-language-python"><code class="language-language-python">CACHES = {    'default': {        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',  # 指定缓存使用的引擎        'LOCATION': '/var/tmp/django_cache',  # 指定缓存的路径        'TIMEOUT': 300,  # 缓存超时时间(默认为300秒,None表示永不过期)        'OPTIONS': {            'MAX_ENTRIES': 300,  # 最大缓存记录的数量（默认300）            'CULL_FREQUENCY': 3,  # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）        }    }}</code></pre><h3 id="数据库缓存"><a class="header-anchor" href="#数据库缓存">¶</a>数据库缓存</h3><blockquote><p>把缓存数据存储在数据库中</p></blockquote><pre class=" language-language-python"><code class="language-language-python">CACHES = {    'default': {        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',  # 指定缓存使用的引擎        'LOCATION': 'cache_table',  # 数据库表            'OPTIONS': {            'MAX_ENTRIES': 300,  # 最大缓存记录的数量（默认300）            'CULL_FREQUENCY': 3,  # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）        }    }}</code></pre><p>注意,创建缓存的数据库表使用的语句:</p><pre class=" language-language-python"><code class="language-language-python">python manage.py createcachetable</code></pre><h3 id="Memcached缓存"><a class="header-anchor" href="#Memcached缓存">¶</a>Memcached缓存</h3><p>Memcached是Django原生支持的缓存系统.要使用Memcached,需要下载Memcached的支持库<code>python-memcached</code>或<code>pylibmc</code>.</p><blockquote><p>使用<code>python-memcached</code>模块连接memcache</p></blockquote><pre class=" language-language-python"><code class="language-language-python">CACHES = {    'default': {        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',  # 指定缓存使用的引擎        'LOCATION': '192.168.10.100:11211',  # 指定Memcache缓存服务器的IP地址和端口        'OPTIONS': {            'MAX_ENTRIES': 300,  # 最大缓存记录的数量（默认300）            'CULL_FREQUENCY': 3,  # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）        }    }}</code></pre><blockquote><p>使用<code>pylibmc</code>模块连接memcache</p></blockquote><pre class=" language-language-python"><code class="language-language-python">CACHES = {    'default': {        'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',  # 指定缓存使用的引擎        'LOCATION': '192.168.10.100:11211',  # 指定本机的11211端口为Memcache缓存服务器        'OPTIONS': {            'MAX_ENTRIES': 300,  # 最大缓存记录的数量（默认300）            'CULL_FREQUENCY': 3,  # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）        },    }}</code></pre><p>Memcached是基于内存的缓存,数据存储在内存中.所以如果服务器死机的话,数据就会丢失,所以Memcached一般与其他缓存配合使用</p><h2 id="缓存应用"><a class="header-anchor" href="#缓存应用">¶</a>缓存应用</h2><blockquote><p>在使用缓存之前，必选先选择一种缓存方式，按照上面的配置信息在 <code>settings.py</code>中实现对应配置。</p></blockquote><h3 id="全站使用缓存"><a class="header-anchor" href="#全站使用缓存">¶</a>全站使用缓存</h3><blockquote><p>如果想要对整个项目的<strong>所有</strong><code>GET</code>和<code>HEAD</code>方法的正常返回结果进行缓存，可以通过<strong>中间件</strong>实现</p></blockquote><ul><li>用户的请求通过中间件，经过一系列的认证等操作，如果请求的内容在缓存中存在，则使用<code>FetchFromCacheMiddleware</code>获取内容并返回给用户</li><li>当返回给用户之前，判断缓存中是否已经存在，如果不存在，则<code>UpdateCacheMiddleware</code>会将缓存保存至Django的缓存之中，以实现全站缓存</li><li>请求来了，是从上到下入走中间件；响应的时候是从下到上走中间件。因此，获取页面放在最后，保存页面放最前面</li></ul><pre class=" language-language-python"><code class="language-language-python">MIDDLEWARE = [ 'django.middleware.cache.UpdateCacheMiddleware',  # 响应HttpResponse中设置几个headers 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'django.middleware.cache.FetchFromCacheMiddleware',  # 用来缓存通过GET和HEAD方法获取的状态码为200的响应] CACHE__MIDDLEWARE_SECONDS=15  # 设定超时时间为15秒</code></pre><p>此时在中间件中已经设置过缓存，因此其余代码不变，视图中正常执行逻辑，即可实现全站缓存。</p><pre class=" language-language-python"><code class="language-language-python">from django.http.response import HttpResponseimport timedef index(request):    print('视图函数被调用')    result = 0    for i in range(10):        result += i        time.sleep(0.5)    ctime = time.strftime('%H:%M:%S', time.localtime())    return HttpResponse("时间{}的结果是:{}".format(ctime, result))</code></pre><h3 id="单独视图"><a class="header-anchor" href="#单独视图">¶</a>单独视图</h3><blockquote><p>如果不想对所有的查询结果缓存，而只是为<strong>单个视图</strong>函数添加缓存，就可以使用<strong>装饰器</strong>实现</p></blockquote><pre class=" language-language-python"><code class="language-language-python">from django.views.decorators.cache import cache_pagefrom django.http.response import HttpResponseimport time@cache_page(10)  # 缓存10秒def index(request):    print('视图函数被调用')    result = 0    for i in range(10):        result += i        time.sleep(0.5)    ctime = time.strftime('%H:%M:%S', time.localtime())    return HttpResponse("时间{}的结果是:{}".format(ctime, result))</code></pre><p>因为缓存的原因,不停的刷新浏览器时会发现：第一次请求页面时，会等待5秒，计算完全部数据数据， 才可以返回结果；在下一次请求时，利用缓存结果，可以很快得到响应数据；直到10秒之后，缓存过期，重新进行该过程。</p><h3 id="模板缓存"><a class="header-anchor" href="#模板缓存">¶</a>模板缓存</h3><blockquote><p>如果并不想对页面的其余部分做任何处理，只是相对页面的<strong>一部分</strong> 进行缓存， 就可以使用 <strong>模板缓存</strong> 实现</p></blockquote><p>如果想对缓存进行更多的控制，可以使用 <code>cache</code>模板标签来缓存模板的一个片段。</p><p><code>views</code>视图函数</p><pre class=" language-language-python"><code class="language-language-python">from django.shortcuts import renderimport timedef index(request):    print('视图函数被调用')    ctime = time.strftime('%H:%M:%S', time.localtime())    return render(request, 'page.html', {'ctime': ctime})</code></pre><p>前端网页</p><pre class=" language-language-python"><code class="language-language-python">{% load cache %}  # 放在缓存片段的上面<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>模板缓存</title></head><body><p>这里是未缓存的时间:{{ ctime }}</p># 将按给定的时间缓存包含块中的内容。 # 它最少需要两个参数：缓存时间（以秒为单位）；给缓存片段起的名称,该名称将被视为是字符串，而不是变量# 设定超时时间为10秒, 给缓存模板片段起名为 "time"{% cache 10 time %}      <p>这里是缓存的时间:{{ ctime }}</p>{% endcache %}</body></html></code></pre><p>刷新浏览器可以看到,第一个时间实时变化,后面一个时间每10秒钟变化一次</p><h3 id="手动缓存"><a class="header-anchor" href="#手动缓存">¶</a>手动缓存</h3><blockquote><p>如果不想为一个方法（页面）进行缓存，只想缓存<strong>某个字段</strong>的话，可以 <strong>手动缓存</strong></p></blockquote><pre class=" language-language-python"><code class="language-language-python">from django.core.cache import cachefrom django.http.response import HttpResponseimport timedef index(request):    print('视图函数被调用')    result = cache.get('result')    if not result:        result = 0        for i in range(10):            result += i            time.sleep(0.5)        cache.set('result', result, 10)    ctime = time.strftime('%H:%M:%S', time.localtime())    return HttpResponse("时间{}的结果是:{}".format(ctime, result))</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-数据分页</title>
      <link href="/2020/11/30/django-shu-ju-fen-ye/"/>
      <url>/2020/11/30/django-shu-ju-fen-ye/</url>
      
        <content type="html"><![CDATA[<p>当页面因需要展示的数据条目过多，导致无法在一个页面全部显示。这时，页面经常会采用分页形式进行展示，然后每页显示 20 或者 50 等条数据。分页经常在网站上随处可见，</p><p>分页的实现不仅提高了用户体验，还是减轻数据库读取数据的压力。Django 自带名为 Paginator 的分页工具， 方便我们实现分页功能。本文就讲解如何使用 Paginator 实现分页功能。</p><h1>Paginator</h1><p>Paginator 类的作用是将我们需要分页的数据分割成若干份。当我们实现化一个 Paginator 类的实例时，需要给 Paginator 传入两个参数。第一个参数是数据源，可以是<strong>一个列表、元组、以及查询结果集 QuerySet</strong>。第二个参数<strong>需要传入一个整数，表示每页显示数据条数</strong>。具体用法如下：</p><h3 id="导入分页模块"><a class="header-anchor" href="#导入分页模块">¶</a>导入分页模块</h3><pre class=" language-language-python"><code class="language-language-python">from django.core.paginator import Paginator</code></pre><h3 id="获取queryset对象"><a class="header-anchor" href="#获取queryset对象">¶</a>获取queryset对象</h3><pre class=" language-language-python"><code class="language-language-python">goods_list = Goods.objects.all().order_by('id')</code></pre><h3 id="实例化分页类对象"><a class="header-anchor" href="#实例化分页类对象">¶</a>实例化分页类对象</h3><pre class=" language-language-python"><code class="language-language-python">paginator = Paginator(goods_list, 2)</code></pre><h4 id="Paginator类对象的属性"><a class="header-anchor" href="#Paginator类对象的属性">¶</a>Paginator类对象的属性</h4><table><thead><tr><th>序号</th><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>num_pages</td><td>返回分页之后的总页数</td></tr><tr><td>2</td><td>page_range</td><td>返回分页后的页码列表</td></tr></tbody></table><h4 id="Paginator类对象的方法"><a class="header-anchor" href="#Paginator类对象的方法">¶</a>Paginator类对象的方法</h4><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>get_page(self, number)</td><td>返回第number页的page类实例对象</td></tr></tbody></table><h4 id="Page实例对象的属性"><a class="header-anchor" href="#Page实例对象的属性">¶</a>Page实例对象的属性</h4><table><thead><tr><th>序号</th><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>number</td><td>返回当前页的页码</td></tr><tr><td>2</td><td>object_list</td><td>返回当前页的数据查询集</td></tr><tr><td>3</td><td>paginator</td><td>返回对应的<strong>Paginator</strong>类对象</td></tr></tbody></table><h4 id="page实例对象的方法"><a class="header-anchor" href="#page实例对象的方法">¶</a>page实例对象的方法</h4><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>has_previous</td><td>判断当前页是否有前一页</td></tr><tr><td>2</td><td>has_next</td><td>判断当前页是否有下一页</td></tr><tr><td>3</td><td>previous_page_number</td><td>返回前一页的页码</td></tr><tr><td>4</td><td>next_page_number</td><td>返回下一页的页码</td></tr></tbody></table><h2 id="分页功能实现"><a class="header-anchor" href="#分页功能实现">¶</a>分页功能实现</h2><h3 id="views函数"><a class="header-anchor" href="#views函数">¶</a>views函数</h3><pre class=" language-language-python"><code class="language-language-python">class IndexView(View):    def get(self, request):        page_number = request.GET.get('page', 1)  # 获取客户端发送的页码，默认为1        page_size = request.GET.get('page_size', 2)  # 获取客户端发送的每页数量，默认为1        try:            page_number = int(page_number)  # 处理页码， 过滤无效的数据        except:            page_number = 1        goods_list = Goods.objects.all().order_by('id')        paginator = Paginator(goods_list, page_size)  # 得到分页器对象        page = paginator.get_page(page_number)  # 得到当前页码对象        # 获取页码列表        index = page.number - 1  # 当前页码对应的索引        max_index = paginator.num_pages - 1  # 最大索引        # 为了得到显示7个页码的列表，从当前索引向前数3个，向后数3个，加上本身，即7个页码        start_index = index - 3 if index >= 3 else 0        end_index = index + 3 if index <= max_index - 3 else max_index        # 最后处理过的页码列表        page_range = paginator.page_range[start_index:end_index + 1]        return render(request, 'index.html', context={'goods': page, 'page_range': page_range})</code></pre><h3 id="模板实现"><a class="header-anchor" href="#模板实现">¶</a>模板实现</h3><pre class=" language-language-html"><code class="language-language-html"><!-- 引入bootstrap样式文件 --><link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}"><!--数据遍历展示--><table class="table">    <thead class="thead-light">    <tr>        <th scope="col">#</th>        <th scope="col">名称</th>        <th scope="col">单价</th>        <th scope="col">数量</th>        <th scope="col">图片</th>    </tr>    </thead>    <tbody>    {% for good in goods.object_list %}        <tr>            <th>{{ good.id }}</th>            <td>{{ good.name }}</td>            <td>{{ good.price }}</td>            <td>{{ good.nums }}</td>            <td>                <img src="/media/{{ good.img }}" alt="" style="width: 100px;height: 130px">            </td>        </tr>    {% endfor %}    </tbody></table><!--底部分页按钮--><nav aria-label="Page navigation example" style="margin: 0 auto">    <ul class="pagination">        <li class="page-item">            {% if goods.has_previous %}                <a href="{% url 'goods:index' %}?page={{ goods.previous_page_number }}" class="page-link"                   aria-label="Previous">                    <span aria-hidden="true">&laquo;</span>                </a>            {% else %}                <a href="#" class="page-link" aria-label="Previous">                    <span aria-hidden="true">&laquo;</span>                </a>            {% endif %}        </li>        {% for page in page_range %}            <li class="page-item">                {% ifequal page goods.number %}                    <a href="#" class="page-link">{{ page }}</a>                {% else %}                    <a href="{% url 'goods:index' %}?page={{ page }}" class="page-link">{{ page }}</a>                {% endifequal %}            </li>        {% endfor %}        <li class="page-item">            {% if goods.has_next %}                <a href="{% url 'goods:index' %}?page={{ goods.next_page_number }}" class="page-link" aria-label="Next">                    <span aria-hidden="true">&raquo;</span>                </a>            {% else %}                <a href="#" class="page-link" aria-label="Next">                    <span aria-hidden="true">&raquo;</span>                </a>            {% endif %}        </li>    </ul></nav></code></pre><h4 id="路由配置"><a class="header-anchor" href="#路由配置">¶</a>路由配置</h4><pre class=" language-language-python"><code class="language-language-python">urlpatterns = [    path('', IndexView.as_view(), name='index'),  # /?page=1&page_size=2]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT浅析</title>
      <link href="/2020/10/24/drf-jwt-qian-xi/"/>
      <url>/2020/10/24/drf-jwt-qian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT起源"><a class="header-anchor" href="#JWT起源">¶</a>JWT起源</h2><blockquote><p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（<a href="https://link.jianshu.com?t=https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">(RFC 7519</a>). 该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p></blockquote><p>说起 JWT，我们应该来谈一谈基于 token 的认证和传统的 session 认证的区别。</p><h3 id="传统的-session-认证"><a class="header-anchor" href="#传统的-session-认证">¶</a>传统的 session 认证</h3><p>我们知道，http 协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据 http 协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为 cookie, 以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了, 这就是传统的基于 session 认证。</p><p>但是这种基于 session 的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于 session 认证应用的问题就会暴露出来.</p><h4 id="基于-session-认证所显露的问题"><a class="header-anchor" href="#基于-session-认证所显露的问题">¶</a>基于 session 认证所显露的问题</h4><p><strong>Session</strong>: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言 session 都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p><p><strong>扩展性</strong>: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上, 这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p><p><strong>CSRF</strong>: 因为是基于 cookie 来进行用户识别的, cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p><h3 id="基于-token-的鉴权机制"><a class="header-anchor" href="#基于-token-的鉴权机制">¶</a>基于 token 的鉴权机制</h3><p>基于 token 的鉴权机制类似于 http 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><p>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个 token</li><li>客户端存储 token，并在每次请求时附送上这个 token 值</li><li>服务端验证 token 值，并返回数据</li></ul><p>这个 token 必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)</code>策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p><p>那么我们现在回到 JWT 的主题上。</p><h2 id="JWT-构成"><a class="header-anchor" href="#JWT-构成">¶</a>JWT 构成</h2><p>JWT 是由三段信息构成的，将这三段信息文本用<code>.</code>链接一起就构成了 Jwt 字符串。就像这样:</p><pre class=" language-language-python"><code class="language-language-python">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></pre><p>第一部分我们称它为头部（header), 第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).</p><h3 id="header（头信息）"><a class="header-anchor" href="#header（头信息）">¶</a>header（头信息）</h3><p>jwt 的头部承载两部分信息：</p><ul><li>令牌类型（即：JWT）</li><li>散列算法（HMAC、RSASSA、RSASSA-PSS等）</li></ul><p>完整的头部就像下面这样的 JSON：</p><pre class=" language-language-python"><code class="language-language-python">{  'typ': 'JWT',  'alg': 'HS256'}</code></pre><p>然后将头部进行 base64 加密（该加密是可以对称解密的), 构成了第一部分.</p><pre class=" language-language-python"><code class="language-language-python">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code></pre><h3 id="Payload（有效载荷）"><a class="header-anchor" href="#Payload（有效载荷）">¶</a>Payload（有效载荷）</h3><p>载荷就是存放有效信息的地方，其中包含claims。claims是关于实体（常用的是用户信息）和其他数据的声明，claims有三种类型：</p><ul><li><strong>Registered claims（注册的声明）：</strong> 这些是一组预定义的claims，非强制性的，但是推荐使用， iss（发行人）， exp（到期时间）， sub（主题）， aud（观众）等；</li><li><strong>Public claims（公共的声明）:</strong> 自定义claims，注意不要和JWT注册表中属性冲突，<a href="https://www.iana.org/assignments/jwt/jwt.xhtml" target="_blank" rel="noopener">这里可以查看JWT标准注册表</a></li><li><strong>Private claims（私有的声明）:</strong> 这些是自定义的claims，用于在同意使用这些claims的各方之间共享信息，它们既不是Registered claims，也不是Public claims。</li></ul><h4 id="标准中注册的声明"><a class="header-anchor" href="#标准中注册的声明">¶</a>标准中注册的声明</h4><blockquote><p><strong>建议但不强制使用</strong></p></blockquote><ul><li><strong>iss</strong>: jwt 签发者</li><li><strong>sub</strong>: jwt 所面向的用户</li><li><strong>aud</strong>: 接收 jwt 的一方</li><li><strong>exp</strong>: jwt 的过期时间，这个过期时间必须要大于签发时间，注意，这个值是秒数，而不是毫秒数。</li><li><strong>nbf</strong>: 定义在什么时间之前，该 jwt 都是不可用的.</li><li><strong>iat</strong>: jwt 的签发时间</li><li><strong>jti</strong>: jwt 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。</li><li><strong>name</strong>：用户全名</li></ul><h4 id="公共的声明"><a class="header-anchor" href="#公共的声明">¶</a>公共的声明</h4><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 但不建议添加敏感信息，因为该部分在客户端可解密。</p><h4 id="私有的声明"><a class="header-anchor" href="#私有的声明">¶</a>私有的声明</h4><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。</p><blockquote><p>在官网有详细的属性说明，尽量使用里面提到的 <em>Registered Claim Names</em>，这样可以提高阅读性</p></blockquote><p>自定义一个 payload:</p><pre class=" language-language-python"><code class="language-language-python">{  "sub": "1234567890",  "name": "John Doe",  "admin": true}</code></pre><p>然后将其进行 base64 加密，得到 Jwt 的第二部分。</p><pre class=" language-language-python"><code class="language-language-python">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></pre><h3 id="signature"><a class="header-anchor" href="#signature">¶</a>signature</h3><p>jwt 的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64 后的)</li><li>payload (base64 后的)</li><li>secret</li></ul><p>这个签名的计算跟第一部分中的 alg 属性有关，假如是 HS256，那么服务端需要保存一个私钥，比如 secret 。然后，把第一部分和第二部分生成的两个字符串用 <code>.</code> 连接之后，用 HS256 进行加盐<code>secret</code>加密，然后就构成了 jwt 的第三部分。</p><pre class=" language-language-python"><code class="language-language-python">TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></pre><p>将这三部分用<code>.</code>连接成一个完整的字符串, 构成了最终的 jwt:</p><pre class=" language-language-python"><code class="language-language-python">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></pre><blockquote><p><strong>注意：secret 是保存在服务器端的，jwt 的签发生成也是在服务器端的，secret 就是用来进行 jwt 的签发和 jwt 的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个 secret, 那就意味着客户端是可以自我签发 jwt 了。</strong></p></blockquote><h2 id="如何应用"><a class="header-anchor" href="#如何应用">¶</a>如何应用</h2><p>一般是在请求头里加入<code>Authorization</code>，并加上<code>JWT</code>标注：</p><pre class=" language-language-js"><code class="language-language-js">fetch('api/user/1', {  headers: {    'Authorization': 'JWT ' + token  }})</code></pre><p>服务端会验证 token，如果验证通过就会返回相应的资源。整个流程就是这样的:</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/10/1821058-2e28fe6c997a60c9.png" alt="jwt-diagram"></p><h3 id="示例1-2：以-Django-作为服务端"><a class="header-anchor" href="#示例1-2：以-Django-作为服务端">¶</a>示例1/2：以 Django 作为服务端</h3><h4 id="环境搭建"><a class="header-anchor" href="#环境搭建">¶</a>环境搭建</h4><pre class=" language-language-python"><code class="language-language-python">pip install django  django-cors-headers djangorestframework djangorestframework-jwt</code></pre><h4 id="用户模型类"><a class="header-anchor" href="#用户模型类">¶</a>用户模型类</h4><blockquote><p><code>users/models.py</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass UserModel(AbstractUser):    phone = models.CharField(max_length=11, unique=True, verbose_name='手机')    class Meta:        ordering = ['id']        db_table = 'db_user'        verbose_name = '用户'        verbose_name_plural = '用户'    def __str__(self):        return self.username</code></pre><h4 id="序列化类"><a class="header-anchor" href="#序列化类">¶</a>序列化类</h4><blockquote><p><code>users/ser.py</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">from rest_framework import serializersfrom .models import UserModelfrom django.contrib.auth.hashers import make_passwordimport reclass UserSerializer(serializers.ModelSerializer):    def create(self, validated_data):        return UserModel.objects.create_user(**validated_data)    def update(self, instance, validated_data):        instance.username = validated_data.get('username', instance.username)        instance.phone = validated_data.get('phone', instance.phone)        instance.email = validated_data.get('email', instance.email)        password = validated_data['password']        if not password:            instance.password = make_password(password)        instance.save()        return instance    def validate_password(self, value):        """        验证密码不能全是小写字母，不能全是大写字母，也不能全是数字        """        if not re.match(r'(?!^\d*$)(?![a-z]$)(?![A-Z]$).{6,}$', value):            raise serializers.ValidationError('密码等级不够')        return value    def validate_phone(self, value):        """        校验手机号是否合法        """        if not re.match(r'1[3-7]\d{9}$', value):            raise serializers.ValidationError('手机号不合法')        return value    class Meta:        model = UserModel        fields = ('id', 'username', 'phone', 'password', 'email')        read_only_fields = ('id',)        extra_kwargs = {            'password': {                'write_only': True            }        }</code></pre><h4 id="自定义JWT-payload"><a class="header-anchor" href="#自定义JWT-payload">¶</a>自定义JWT payload</h4><blockquote><p><code>users/utils.py</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">def jwt_response_payload_handler(token, user=None, request=None):    """    自定义jwt认证成功返回数据    """    return {        'token': token,        'id': user.id,        'username': user.username,        'phone': user.phone,        'email': user.email,    }</code></pre><h4 id="自定义Django登录验证"><a class="header-anchor" href="#自定义Django登录验证">¶</a>自定义Django登录验证</h4><blockquote><p><code>users/utils.py</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">from .models import UserModelfrom django.contrib.auth.backends import ModelBackendclass JWTModelBackend(ModelBackend):    """user验证"""    def authenticate(self, request, username=None, password=None, **kwargs):        try:            if re.match(r'^1[3-9]\d{9}$', username):                user = UserModel.objects.get(phone=username)            else:                user = UserModel.objects.get(username=username)        except UserModel.DoesNotExist:            return None        if user.check_password(password) and self.user_can_authenticate(user):            return user</code></pre><h4 id="项目配置信息"><a class="header-anchor" href="#项目配置信息">¶</a>项目配置信息</h4><blockquote><p><code>djangodemo/settings.py</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">INSTALLED_APPS = [   ...,    'corsheaders',    'users']MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'corsheaders.middleware.CorsMiddleware',    'django.middleware.common.CommonMiddleware',    # 'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',]# 跨域参数CORS_ORIGIN_ALLOW_ALL = True# 自定义用户模型类AUTH_USER_MODEL = 'users.UserModel'# 多种方式登录验证AUTHENTICATION_BACKENDS = ['users.utils.JWTModelBackend']REST_FRAMEWORK = {    # 指定drf认证机制    'DEFAULT_AUTHENTICATION_CLASSES': (        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',  # 默认JWT认证        # 'rest_framework.authentication.SessionAuthentication',  # session认证        # 'rest_framework.authentication.BasicAuthentication',  # 基本认证    ),    # 全局权限配置  'DEFAULT_PERMISSION_CLASSES': (         'rest_framework.permissions.IsAuthenticated',     )}import datetimeJWT_AUTH = {    # 指明token的有效期， 默认5分    'JWT_EXPIRATION_DELTA': datetime.timedelta(minutes=5),    'JWT_ALLOW_REFRESH': True,    # 在多久间隔内可以用它来刷新以便获取新的token，默认是7天    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),    # 客户端首先调用obtain_jwt_token进行登录操作，    # 之后必须每隔小于5分钟就刷新一次token，才能保证不掉线。    # 然而即使一直保持在线，上限也只有7天，7天过后必须重新登录，这才是5mins + 7days的确切含义    # 自定义jwt认证成功返回数据    'JWT_RESPONSE_PAYLOAD_HANDLER': 'users.utils.jwt_response_payload_handler',}</code></pre><h4 id="权限验证"><a class="header-anchor" href="#权限验证">¶</a>权限验证</h4><blockquote><p>权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。</p><ul><li>在项目的配置文件中，实现全局的权限配置</li><li>在视图类中指定权限</li></ul></blockquote><p>权限分为四类：</p><ul><li><code>AllowAny</code>: 允许所有用户， 默认权限</li><li><code>IsAuthenticated</code>: 仅通过认证的用户</li><li><code>IsAdminUser</code>: 仅管理员用户</li><li><code>IsAuthenticatedOrReadOnly</code>: 认证的用户可以完全操作，否则只能<code>get</code>读取</li></ul><h4 id="创建视图"><a class="header-anchor" href="#创建视图">¶</a>创建视图</h4><blockquote><p><code>users/views.py</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">from rest_framework.generics import GenericAPIViewfrom rest_framework.mixins import CreateModelMixinfrom users.ser import UserSerializer, UserModel# 创建注册视图类class RegisterView(GenericAPIView, CreateModelMixin):    queryset = UserModel.objects.all()    serializer_class = UserSerializer    def post(self, request, *args, **kwargs):        return self.create(request, *args, **kwargs)# rest_framework_jwt 已经提供登录签发JWT的视图函数：obtain_jwt_token# rest_framework_jwt 提供在有效期内刷新token的视图函数：refresh_jwt_token# 创建允许管理员查询所有用户的视图类class UserView(GenericAPIView, ListModelMixin):  """查询所有注册用户"""    queryset = UserModel.objects.all()    serializer_class = UserSerializer    permission_classes = (IsAdminUser,)  # 指定权限验证,限制管理员才可以查询所有用户    def get(self, request, *args, **kwrags):        return self.list(request, *args, **kwrags)</code></pre><h4 id="路由配置"><a class="header-anchor" href="#路由配置">¶</a>路由配置</h4><blockquote><p><code>djangodemo/urls.py</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">from django.contrib import adminfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    path('users/', include('users.urls'))]</code></pre><blockquote><p><code>users/urls.py</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">from django.urls import pathfrom .views import *from rest_framework_jwt.views import obtain_jwt_token, refresh_jwt_tokenurlpatterns = [    path('register/', RegisterView.as_view()), # 注册路由    path('login/', obtain_jwt_token), # 登录路由    path('refresh/', refresh_jwt_token), # 刷新token    path('', UserView.as_view()) # 权限验证，查询所有用户]</code></pre><h3 id="示例-2-2：以-Vue-作为前端"><a class="header-anchor" href="#示例-2-2：以-Vue-作为前端">¶</a>示例 2/2：以 Vue 作为前端</h3><h4 id="路由前置守卫"><a class="header-anchor" href="#路由前置守卫">¶</a>路由前置守卫</h4><blockquote><p><code>router/index.js</code></p></blockquote><pre class=" language-language-javascript"><code class="language-language-javascript">import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Login from '@/components/Login'import Users from '@/components/Users'Vue.use(Router);let router = new Router({  routes: [    {      path: '/',      name: 'HelloWorld',      component: HelloWorld    },    {      path: '/login',      name: 'Login',      component: Login    },    {      path: '/Users',      name: 'Users',      component: Users    }  ]})router.beforeEach((to, from, next) => {  const isLogin = localStorage.getItem('token') ? true : false;  if (to.path == '/login' || to.path == '/register') {    //'login'和'register'相当于是路由白名单    localStorage.setItem("preRoute", router.currentRoute.fullPath);    next();  } else {    //如果token存在，就正常跳转，如果不存在，则说明未登陆，则跳转到'login'    isLogin ? next() : next("/login");  }})export default router</code></pre><h4 id="axios拦截器"><a class="header-anchor" href="#axios拦截器">¶</a>axios拦截器</h4><blockquote><p><code>utils/axios.js</code></p></blockquote><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'import router from '../router/index.js'const instance = axios.create({  baseURL: 'http://127.0.0.1:8000/',  timeout: 10000,});// 添加请求拦截器instance.interceptors.request.use(function (config) {  // 在发送请求之前, 添加 token 到请求头  if (localStorage.token) {    config.headers['Authorization'] = 'JWT ' + localStorage.getItem('token');    config.headers['Accept'] = 'application/json';  }  return config;}, function (error) {  // 对请求错误做些什么  return Promise.reject(error);});// 自定义的 axios 响应拦截器instance.interceptors.response.use((response) => {  // 判断一下响应中是否有 token，如果有就直接使用此 token 替换掉本地的 token。你可以根据你的业务需求自己编写更新 token 的逻辑  var token = response.data.token;  if (token) {    localStorage.setItem('token', token);  }  return response}, (error) => {  if (error.response) {    switch (error.response.status) {      case 401:        // 这里写清除token的代码        console.log("401")        localStorage.removeItem('token');        /* 普通401拦截直接返回到登录页面 */        router.push('/login');    }  }  return Promise.reject(error)});export default instance</code></pre><h4 id="登录页面"><a class="header-anchor" href="#登录页面">¶</a>登录页面</h4><pre class=" language-language-html"><code class="language-language-html"><template>  <div>    用户名: <input type="text" v-model="userInfo.username"/> <br>    密码: <input type="text" v-model="userInfo.password"/> <br>    <button @click="login">登录</button>  </div></template><script>export default {  name: "login",  data() {    return {      userInfo: {        username: "",        password: "",      },    };  },  methods: {    login() {      this.$axios        .post("users/login/", this.userInfo)        .then((resp) => {          const curr = localStorage.getItem('preRoute');          if (curr == null) {            this.$router.push({path: "/user_center"});          } else {            this.$router.push({path: curr});          }          this.$router.push({path: decodeURIComponent(url)});        })        .catch((err) => {        });    },  },};</script></code></pre><h4 id="用户展示页面"><a class="header-anchor" href="#用户展示页面">¶</a>用户展示页面</h4><pre class=" language-language-html"><code class="language-language-html"><template>  <div>    <table>      <tr v-for="user in userList">        <td> {{ user.id }}</td>        <td> {{ user.username }}</td>        <td> {{ user.phone }}</td>      </tr>    </table>  </div></template><script>export default {  data() {    return {      userList: ""    }  },  methods: {    getData() {      this.$axios.get('/users/')        .then(resp => {          console.log(resp.data)          this.userList = resp.data        })    }  },  mounted() {    this.getData();  }}</script></code></pre><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><h3 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h3><ul><li>因为 json 的通用性，所以 JWT 是可以进行跨语言支持的，像 JAVA,JavaScript,NodeJS,Python 等很多语言都可以使用。</li><li>因为有了 payload 部分，所以 JWT 可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li><li>便于传输，jwt 的构成非常简单，字节占用很小，所以它是非常便于传输的。</li><li>它不需要在服务端保存会话信息, 所以它易于应用的扩展。</li></ul><h3 id="安全相关"><a class="header-anchor" href="#安全相关">¶</a>安全相关</h3><ul><li>不应该在 jwt 的 payload 部分存放敏感信息，因为该部分是客户端可解密的部分。</li><li>保护好 secret 私钥，该私钥非常重要。</li><li>如果可以，请使用 https 协议</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRF </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue引入本地资源</title>
      <link href="/2020/10/23/vue-yin-ru-ben-di-zi-yuan/"/>
      <url>/2020/10/23/vue-yin-ru-ben-di-zi-yuan/</url>
      
        <content type="html"><![CDATA[<p>简单介绍一下在Vue项目中引入本地资源的实现方式: <a id="more"></a></p><h2 id="引入本地图片"><a class="header-anchor" href="#引入本地图片">¶</a>引入本地图片</h2><h3 id="使用-引入："><a class="header-anchor" href="#使用-引入：">¶</a>使用 <code>@</code>引入：</h3><p>这是在组件内直接引用和普通的 html 方法一样，代码如下</p><pre class=" language-language-html"><code class="language-language-html"><img src="@/assets/test.png" alt="test.png"></code></pre><h3 id="使用-vue-的方法引入："><a class="header-anchor" href="#使用-vue-的方法引入：">¶</a>使用 vue 的方法引入：</h3><p>这是典型的 vue 思想，使用数据来操纵 dom； 首先在组件内使用 import … from 引入</p><pre class=" language-language-js"><code class="language-language-js">import imgUrl from '../assets/test.png';</code></pre><p>然后在 data 里面声明</p><pre class=" language-language-js"><code class="language-language-js">data: function () {      return {                  imgSrc: imgUrl            }       }</code></pre><p>最后绑定数据</p><pre class=" language-language-js"><code class="language-language-js"><img :src="imgSrc" alt="imgSrc"></code></pre><h2 id="引入样式文件"><a class="header-anchor" href="#引入样式文件">¶</a>引入样式文件</h2><p>在项目的 <code>src</code> 文件下，新建一个 <code>style</code> 文件夹，存放 <code>css</code> 文件。</p><h3 id="全局引入"><a class="header-anchor" href="#全局引入">¶</a>全局引入</h3><p>将外部的 css 文件放到 style 文件下，引入外部文件只需在 <code>main.js</code>文件中</p><pre class=" language-language-js"><code class="language-language-js">import './style/reset.css'</code></pre><h3 id="局部引入"><a class="header-anchor" href="#局部引入">¶</a>局部引入</h3><pre class=" language-language-js"><code class="language-language-js"><style scoped>  @import '../assets/iconfont/iconfont.css'; // 这个分号一定要写，要不会报错</style></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片 </tag>
            
            <tag> 样式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deepin OS 安装 NVIDIA驱动</title>
      <link href="/2020/09/03/xi-tong-deepin-os-an-zhuang-nvidia-qu-dong/"/>
      <url>/2020/09/03/xi-tong-deepin-os-an-zhuang-nvidia-qu-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="工具-原料"><a class="header-anchor" href="#工具-原料">¶</a>工具 / 原料</h2><ul><li>一台电脑</li><li>Deepin15.10.2 系统</li><li>N 卡官网驱动</li></ul><a id="more"></a><h2 id="方法-步骤"><a class="header-anchor" href="#方法-步骤">¶</a>方法 / 步骤</h2><h3 id="一、驱动下载"><a class="header-anchor" href="#一、驱动下载">¶</a>一、驱动下载</h3><p>本教程以 <code>GTX1050</code> 为例，前往 <a href="https://www.nvidia.cn/geforce/drivers/" target="_blank" rel="noopener">N 卡官网</a>下载对应的驱动 :</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/20200826215347.png" alt="20200826215347"></p><p>然后选择一个下载即可，我下载的是<code>NVIDIA-Linux-x86_64-430.26.run</code>，最好不要下载最新的驱动，有可能有 Bug。(为可方便起见，建议更改文件名为 <code>001.run</code>，千万别忘了<code>. run</code>，该文件名只是为了好敲入命令。)</p><h3 id="二、禁用-nouveau-驱动"><a class="header-anchor" href="#二、禁用-nouveau-驱动">¶</a>二、禁用 nouveau 驱动</h3><ol><li><p>如果之前在 Deepin 中安装过 NVIDIA 驱动，请将其全部删除：</p><p>在终端执行命令: <code>sudo apt autoremove  nvidia</code>(没有可以跳过)</p></li><li><p>在终端执行命令:</p><pre class=" language-language-shell"><code class="language-language-shell">sudo dedit /etc/modprobe.d/blacklist.conf</code></pre><p>然后在将以下内容复制到文件中</p><pre class=" language-language-shell"><code class="language-language-shell">blacklist nouveaublacklist lbm-nouveauoptions nouveau modeset=0alias nouveau offalias lbm-nouveau off</code></pre><p>保存退出</p></li><li><p>接下来在终端执行命令:</p><pre><code>sudo update-initramfs -u</code></pre></li><li><p>重启系统，再次进入系统，可能会发现分  辨率异常。(分辨率异常就说明成功禁用 nouveau 驱动重启系统，重启后查看是否生效，</p><pre class=" language-language-shell"><code class="language-language-shell">lsmod |grep -i nouveau</code></pre></li></ol><h3 id="三、NVIDIA-安装过程"><a class="header-anchor" href="#三、NVIDIA-安装过程">¶</a>三、NVIDIA 安装过程</h3><ol><li><p>使用快捷键 <code>CTRL+ALT+F2</code> 进入终端，登录自己的账号 (就是用户名和密码)。</p></li><li><p>暂时关闭图形界面：</p><pre class=" language-language-bash"><code class="language-language-bash">sudo service lightdm stop</code></pre></li><li><p>给下载好的 nvidia 驱动文件设置执行权限 (文件默认在 <code>/home/用户名/Downloads/</code> 目录下，用户名为你自己的用户名，如果你改文件名了，就填你改后的文件名，千万别填 <code>NVIDIA-Linux-x86_64-430.26.run</code>)。</p><pre class=" language-language-bash"><code class="language-language-bash">sudo chmod a+x  /home/用户名/Downloads/NVIDIA-Linux-x86_64-430.26.run</code></pre></li><li><p>驱动安装：</p><pre class=" language-language-bash"><code class="language-language-bash">sudo  sh  /home / 用户名 / Downloads/NVIDIA-Linux-x86_64-430.26.run</code></pre><p>(一系列 yes，还有一个界面选择 <code>install and cover</code>，意为安装和覆盖。)</p></li><li><p>重启系统：</p><pre class=" language-language-bash"><code class="language-language-bash">sudo reboot</code></pre><p>安装完成后重启，执行 <code>nvidia-smi</code></p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/20190922111147368.png" alt="20190922111147368"></p><p>发现这时候其实 NVIDIA 的显卡并没有工作，<strong>显存一点都没占用</strong>。主要是由于我的电脑是双显卡，这时候其实依然是 intel 集成显卡在工作，所以还要做下面的工作。</p></li></ol><h3 id="四、设置默认-nvidia-显卡工作"><a class="header-anchor" href="#四、设置默认-nvidia-显卡工作">¶</a>四、设置默认 nvidia 显卡工作</h3><pre class=" language-language-shell"><code class="language-language-shell">lspci | egrep 'VGA|3D'</code></pre><p>执行上述命令获取 <code>nvidia</code> 显卡设备 <code>BusID</code>，例如: <code>01:00.0</code> 填写 <code>PCI:1:0:0</code>，</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/20190922111306609.png" alt="20190922111306609"></p><p>然后编辑 <code>/etc/X11/xorg.conf</code>，注意其中 PCI 部分填写 <code>PCI:1:0:0</code>，</p><pre class=" language-language-shell"><code class="language-language-shell">Section "Module"    Load "modesetting"EndSectionSection "Device"    Identifier "nvidia"    Driver "nvidia"    BusID "PCI:X:X:X"           Option "AllowEmptyInitialConfiguration"EndSection</code></pre><p>编辑<code>~/.xinitrc</code>，</p><pre class=" language-language-shell"><code class="language-language-shell">xrandr --setprovideroutputsource modesetting NVIDIA-0xrandr --autoxrandr --dpi 96</code></pre><p>编辑<code>/etc/lightdm/display_setup.sh</code>，</p><pre><code>#!/bin/shxrandr --setprovideroutputsource modesetting NVIDIA-0xrandr --autoxrandr --dpi 96</code></pre><p>然后执行</p><pre class=" language-language-shell"><code class="language-language-shell">sudo chmod +x  /etc/lightdm/display_setup.sh</code></pre><p>编辑 <code>/etc/lightdm/lightdm.conf</code> 在 <code>[Seat:*]</code> 行下添加，</p><pre class=" language-language-shell"><code class="language-language-shell">display-setup-script=/etc/lightdm/display_setup.sh</code></pre><p>重启动后，查看是否生效，<code>nvidia-smi</code></p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/20190922111512515.png" alt="20190922111512515"></p><p>发现已经生效。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deepin </tag>
            
            <tag> nvidia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信-多种方式实现并发 Web Server</title>
      <link href="/2020/08/16/wang-luo-tong-xin-duo-chong-fang-shi-shi-xian-bing-fa-web-server/"/>
      <url>/2020/08/16/wang-luo-tong-xin-duo-chong-fang-shi-shi-xian-bing-fa-web-server/</url>
      
        <content type="html"><![CDATA[<p>下面我们使用 <code>Python</code> 来实现并发的 <code>Web Server</code>，其中采用了多进程、多线程、协程、单进程单线程非阻塞、<code>select</code>、<code>epoll</code>的方式。</p><a id="more"></a><h2 id="一、使用子进程来实现并发-Web-Server"><a class="header-anchor" href="#一、使用子进程来实现并发-Web-Server">¶</a>一、使用子进程来实现并发 Web Server</h2><pre class=" language-language-python"><code class="language-language-python">import socketimport reimport multiprocessing#  注意： 不同的实现方式，但是对请求的处理方式相同，只是主函数中对客户端请求的接收方式不同 def handle_request(new_socket):    while True:        # 接收请求        recv_msg = new_socket.recv(1024).decode("utf-8")        if recv_msg == "":            print("recv null")            new_socket.close()            return        # 从请求中解析出URI        recv_lines = recv_msg.splitlines()        print(recv_lines)        # 使用正则表达式提取出URI        ret = re.match(r"[^/]+(/[^ ]*)", recv_lines[0])        if ret:            # 获取URI字符串            file_name = ret.group(1)            # 如果URI是/，则默认返回index.html的内容            if file_name == "/":                file_name = "/index.html"        try:            # 根据请求的URI，读取相应的文件            fp = open("." + file_name, "rb")        except:            # 找不到文件，响应404            response_msg = "HTTP/1.1 404 NOT FOUND\r\n"            response_msg += "\r\n"            response_msg += "<h1>----file not found----</h1>"            new_socket.send(response_msg.encode("utf-8"))        else:            html_content = fp.read()            fp.close()            response_body = html_content            # 响应正确 200 OK            response_header = "HTTP/1.1 200 OK\r\n"            response_header += "Content-Length:%d\r\n" % len(response_body)            response_header += "\r\n"            response = response_header.encode("utf-8") + response_body            # 返回响应数据            new_socket.send(response)def main():    # 创建TCP SOCKET实例    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # # 设置重用地址    # tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    # 绑定地址（默认本机IP）和端口    tcp_server_socket.bind(("", 7890))    # 监听    tcp_server_socket.listen(128)    # 循环接收客户端连接    while True:        new_socket, client_addr = tcp_server_socket.accept()        # 启动一个子进程来处理客户端的请求        sub_p = multiprocessing.Process(target=handle_request, args=(new_socket,))        sub_p.start()        # 这里要关闭父进程中的new_socket，因为创建子进程会复制一份new_socket给子进程        new_socket.close()    # 关闭整个SOCKET    tcp_server_socket.close()if __name__ == "__main__":    main()</code></pre><p>我们使用进程来实现并发的 Web Server，也就是将 <code>accept</code> 到 <code>new_socket</code> 传递给子进程去处理，处理函数还是 <code>handle_request</code>。</p><p>但是这里注意，子进程会从父进程中将所有的变量<strong>进行拷贝</strong>，也就是说父进程和子进程中<strong>各有一份 new_socket</strong>，而在 <code>Linux</code> 下，<code>socket</code> 对应的也是一个文件描述符，而这两个 <code>new_socket</code> 实际上是指向同一个 <code>fd</code> 的。所以我们将 <code>new_socket</code> 交给子进程后，父进程就可以马上关闭自己的 <code>new_socket</code> 了，当子进程服务完毕后，关闭子进程中的 <code>new_socket</code>，这样<strong>对应的 <code>FD</code> 才会正真关闭，此时才会触发四次挥手。所以父进程代码中的 <code>new_socket.close()</code> 非常重要。</strong></p><h2 id="二、使用线程来实现并发-Web-Server"><a class="header-anchor" href="#二、使用线程来实现并发-Web-Server">¶</a>二、使用线程来实现并发 Web Server</h2><p>在第一节中，我们使用进程来实现并发，但是进程对资源消耗很大，一般不推荐使用。所以这里我们使用线程来实现并发，很简单，我们将 <code>multiprocessing.Process</code> 替换为 <code>threaing.Thread</code> 就可以了：</p><pre class=" language-language-python"><code class="language-language-python">import socketimport reimport threadingfrom web_server import handle_requestdef main():    # 创建TCP SOCKET实例    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置重用地址    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    # 绑定地址（默认本机IP）和端口    tcp_server_socket.bind(("", 7890))    # 监听    tcp_server_socket.listen(128)    # 循环接收客户端连接    while True:        new_socket, client_addr = tcp_server_socket.accept()        # 启动一个线程来处理客户端的请求        t = threading.Thread(target=handle_request, args=(new_socket,))        t.start()    # 关闭整个SOCKET    tcp_server_socket.close()if __name__ == "__main__":    main()</code></pre><p>我们发现，除了将子进程的创建过程替换成了线程的创建过程，后面的 <code>new_socket.close(</code>) 也被删除了，这是因为线程是公用进程资源的，<code>new_socket</code> 不会被复制，所以 <code>socket</code> 对应的 FD，只有一个 new_socket 指向他。</p><p>如果此时我们仍然在这里关闭 <code>new_socket</code>，那么在线程再使用 <code>new_socket</code> 就会报错。如下信息：</p><pre class=" language-language-python"><code class="language-language-python">Exception in thread Thread-1:Traceback (most recent call last):  File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py", line 926, in _bootstrap_inner    self.run()  File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py", line 870, in run    self._target(*self._args, **self._kwargs)  File "/Users/mac/PycharmProjects/Month2/web_server.py", line 9, in handle_request    recv_msg = new_socket.recv(1024).decode("utf-8")OSError: [Errno 9] Bad file descriptor</code></pre><h2 id="三、使用协程来实现并发-Web-Server"><a class="header-anchor" href="#三、使用协程来实现并发-Web-Server">¶</a>三、使用协程来实现并发 Web Server</h2><p>使用进程和线程来实现的并发 Web Server，当并发访问量很大时，资源消耗都很高。所以这里使用协程来实现并发服务器。</p><pre class=" language-language-python"><code class="language-language-python">import socketimport reimport geventfrom gevent import monkeymonkey.patch_all()from web_server import handle_requestdef main():    # 创建TCP SOCKET实例    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # # 设置重用地址    # tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    # 绑定地址（默认本机IP）和端口    tcp_server_socket.bind(("", 7890))    # 监听    tcp_server_socket.listen(128)    # 循环接收客户端连接    while True:        new_socket, client_addr = tcp_server_socket.accept()        # 启动一个协程来处理客户端的请求        gevent.spawn(handle_request, new_socket)    # 关闭整个SOCKET    tcp_server_socket.close()if __name__ == "__main__":    main()</code></pre><p>使用 gevent 来实现协程，并发处理请求。</p><h2 id="四、使用单进程单线程非阻塞模拟实现高并发HTTP服务器"><a class="header-anchor" href="#四、使用单进程单线程非阻塞模拟实现高并发HTTP服务器">¶</a>四、使用单进程单线程非阻塞模拟实现高并发HTTP服务器</h2><p>前面我们使用的多进程和多线程来处理并发，是因为 <code>socket.recv()</code> 是阻塞的，每次 <code>accept</code> 一个连接，就需要交给一个新的进程或线程去处理，从而不影响下一个 <code>socket</code> 连接。</p><p>但是我们可以通过单进程单线程和非阻塞的方式来完成并发 <code>socket</code> 的处理：</p><pre class=" language-language-python"><code class="language-language-python">import socketimport timeimport redef handle_request(new_socket, recv_msg):    # 从请求中解析出URI    recv_lines = recv_msg.splitlines()    # 使用正则表达式提取出URI    ret = re.match(r"[^/]+(/[^ ]*)", recv_lines[0])    if ret:        # 获取URI字符串        file_name = ret.group(1)        # 如果URI是/，则默认返回index.html的内容        if file_name == "/":            file_name = "/index.html"    try:        # 根据请求的URI，读取相应的文件        fp = open("." + file_name, "rb")    except:        # 找不到文件，响应404        response_msg = "HTTP/1.1 404 NOT FOUND\r\n"        response_msg += "\r\n"        response_msg += "<h1>----file not found----</h1>"        new_socket.send(response_msg.encode("utf-8"))    else:        html_content = fp.read()        fp.close()        response_body = html_content        # 响应正确 200 OK        response_header = "HTTP/1.1 200 OK\r\n"        response_header += "Content-Length:%d\r\n" % len(response_body)        response_header += "\r\n"        response = response_header.encode("utf-8") + response_body        # 返回响应数据        new_socket.send(response)def main():    # 创建TCP SOCKET实例    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置重用地址    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    # 绑定地址（默认本机IP）和端口    tcp_server_socket.bind(("", 7890))    # 监听    tcp_server_socket.listen(128)    # 将accept设置为非阻塞,这里设置一次，后面不管调多少次accept都是非阻塞的    tcp_server_socket.setblocking(False)    # 定义一个列表，将每次连接的socket加入该列表    client_socket_list = list()    fd_to_addr = {}    # 循环接收客户端连接    while True:        time.sleep(0.5)        try:            new_socket, client_addr = tcp_server_socket.accept()        except Exception as ret:            # 当没有客户端链接的时候，抛出异常            pass        else:            print("客户端{} OnLine。。。。".format(client_addr))            # 当有客户端链接的时候            # 将new_socket.recv()设置为非阻塞的            new_socket.setblocking(False)            # 将new_socket加入列表            client_socket_list.append(new_socket)            # 将 conn 和 addr 信息分别保存起来            fd_to_addr[new_socket.fileno()] = client_addr        # 遍历socket列表，检查每一个socket是否有数据到达，或者客户端是否断开        for client_socket in client_socket_list:            try:                recv_content = client_socket.recv(1024).decode("utf-8")            except Exception as ret:                # 异常，表示该客户端没有发数据过来                pass            else:                # 正常，表示客户端发了数据，或者客户端断开连接（断开连接会导致recv正常返回）                if recv_content:                    # 有数据，调用请求处理代码                    handle_request(client_socket, recv_content)                else:                    print("客户端{}OffLine。。。。".format(fd_to_addr[client_socket.fileno()]))                    # recv正常返回，且数据为空，表示客户端断开了链接                    # 将该socket踢出列表                    client_socket_list.remove(client_socket)                    # 服务器也关闭连接                    client_socket.close()    # 关闭整个SOCKET    tcp_server_socket.close()if __name__ == "__main__":    main()</code></pre><p>上面代码主要是说明在单进程单线程情况下，如何将 <code>accept</code> 和 <code>recv</code> 分开，并且都用非阻塞的方式来处理，这样每次查看是否有客户端链接进来的时候，都会去检查所有已链接的 <code>socket</code> 是否有数据发送过来。</p><p>在这种方式中，我们使用单进程单线程模拟了并发处理 <code>socket</code> 连接的功能，但这些 <code>socket</code> 连接的处理不是并行的。当一个 <code>socket</code> 处理数据时间比较长时，也会<strong>造成整个程序的等待。</strong></p><p>特别注意的是，在请求处理函数 <code>handle_request</code> 中，我们将请求内容作为参数一并传递进去。然后在返回 <code>200 OK</code> 的时候，在响应头中添加了 <code>Content-Length</code> 字段，这个字段用于告诉客户端，此次发送的响应体有多大。当客户端收完指定大小的数据，就认为这次服务器发送的数据已经发送完毕。他就可以继续发送下一个新的请求。</p><p>在 <code>handle_request</code> 中可以看到，<code>new_socket.close()</code> 已经被删除，也就是说服务器不会自动关闭连接，而直到客户端断开连接之前，服务器都保持<code>长连接</code>。断开连接由客户端来发起。</p><h2 id="五、使用select实现高并发HTTP服务器"><a class="header-anchor" href="#五、使用select实现高并发HTTP服务器">¶</a>五、使用select实现高并发HTTP服务器</h2><p>在编写了单进程非阻塞式服务器之后，还有另外种写服务器的方法，便是利用<code>select</code>。<br><code>select</code>是对底层操作系统的一个访问操作，因而效率较高，比单进程非阻塞中的<code>for</code>循环遍历效率要高，可以利用<code>select</code>进行选择，选择出来可以读取信息的套接字、可以发送信息的套接字、以及产生的异常（分别是三个返回值）。</p><pre class=" language-language-python"><code class="language-language-python">readable, writable, exceptionable = select([], [], [])</code></pre><p>以上即为<code>select</code>的使用方法，程序执行到该语句后进行阻塞等待，接收到新的套接字之后便解阻塞。<br>程序思路便是利用<code>select</code>检测、选择出能读取的套接字（包括服务器套接字、客户端套接字），将接收到消息的客户端套接字存入列表（列表中本来只有服务器套接字），之后进行<code>for</code>循环遍历，读取套接字中的信息或者进行与客户端的连接。</p><pre class=" language-language-python"><code class="language-language-python">from socket import *from select import selectfrom web_server import handle_requestdef main():    # 创建套接字    server_socket = socket(AF_INET, SOCK_STREAM)    # 设置可以重复使用绑定的信息    server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)    # 绑定本机信息    server_socket.bind(("", 8080))    # 主动监听    server_socket.listen(128)        # 将accept设置为非阻塞    server_socket.setblocking(False)    inputs = [server_socket]    fd_to_addr = {}    while True:        readable, writable, exceptionable = select(inputs, [], [])        for sock in readable:            if sock == server_socket:                clientSocket, clientAddr = server_socket.accept()                # 当有客户端链接的时候                # 将new_socket.recv()设置为非阻塞的                clientSocket.setblocking(False)                inputs.append(clientSocket)                # 将 addr 信息保存起来                fd_to_addr[clientSocket.fileno()] = clientAddr                print("客户端{} OnLine。。。。".format(clientAddr))            else:                message = sock.recv(1024)                if message:                    # print('message from [%s] is %s' % (str(sock), message.decode('utf-8')))                    handle_request(sock, message.decode("utf8"))                else:                    print('[%s] OffLine。。。。' % (fd_to_addr[sock.fileno()]))                    inputs.remove(sock)                    sock.close()if __name__ == '__main__':    main()</code></pre><p><code>select</code>版服务器有一定的缺点，便是只能处理1024个并发客户端，因而其效率还是有一定的局限性。</p><h2 id="六、使用epoll实现高并发HTTP服务器"><a class="header-anchor" href="#六、使用epoll实现高并发HTTP服务器">¶</a>六、使用epoll实现高并发HTTP服务器</h2><p>我们在最后使用单进程+单线程+非阻塞+长连接实现了一个可并发处理客户端连接的服务器。他的原理可以用以下的图来描述：</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/P4p4aJ.png" alt="P4p4aJ"></p><p><strong>解释：</strong></p><ol><li><p>HTTP服务器是我们使用 单进程+单线程+非阻塞+长连接实现 的<code>web</code>服务器。</p></li><li><p>在实现的时候，我们创建了一个存放已接受<code>Socket</code>连接的列表，该列表是在应用程序的内存空间中的。如图中深蓝色部分</p></li><li><p>当有3个客户端接入的时候，列表中一共存在3个对应的<code>socket</code>句柄，分别对应三个小黄框。</p></li><li><p>灰色小框代表服务器接收请求的<code>socket</code>。</p></li><li><p>我们在进行无限循环的时候，首先是检查是否有新的客户端接入，相当于检查灰色小框是否有数据到达。然后轮询3个小黄框对应<code>socket</code>是否有数据到达。轮询的效率是很低的。</p></li><li><p>服务器在使用<code>accept</code>和<code>recv</code>时，实际上是委托操作系统帮他检查是否有数据到达，由于这个列表的<code>socket</code>都处于用户内存空间，所以需要将其复制到内核空间。操作系统检查完毕后，如果有数据就返回数据给应用程序，如果没有数据就以异常的方式通知应用程序。而且不光这样，操作系统可能还同时在运行其他的应用程序，这样效率会非常低。</p></li></ol><p><strong>我们再来看epoll的图：</strong></p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/5TcU6B.png" alt="5TcU6B"></p><p><strong>解释：</strong></p><p>1.我们可以看到，在结构上，最大的区别在于，存放<code>socket</code>的列表不处于应用程序内部。在<code>epoll</code>中，这个存放<code>socket</code>的列表处于一个<strong>特殊的内存空间，这个内存空间是应用程序与内核共享的空间</strong>。也就是说，当应用程序委托操作系统检查是否有数据到达时，无需将复制数据给内核空间，操作系统可以直接进行检查。</p><p>2.操作系统检查到某个<code>socket</code>有数据到达，使用<strong>事件通知</strong>的形式，直接告诉应用程序，而不是以轮询的方式。打个比方，一个厨师挨个问50个人饿了没，如果饿了就给他东西吃，这是轮询。而50个人中，谁饿了谁举手，厨师就给吃的，这叫事件通知。很明显，事件通知的效率会特别高。</p><pre class=" language-language-python"><code class="language-language-python">from socket import *import selectfrom web_server import handle_requestdef main():    # 创建套接字    server_socket = socket(AF_INET, SOCK_STREAM)    # 设置可以重复使用绑定的信息    server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)    # 绑定本机信息    server_socket.bind(("", 8080))    # 主动监听    server_socket.listen(128)    # 将accept设置为非阻塞    server_socket.setblocking(False)    # 创建epoll对象    epoll = select.epoll()    # 注册事件到epoll中    # epoll.register(fd[, eventmask])    # 注意，如果fd已经注册过，则会发生异常    # 将创建的套接字添加到epoll的事件监听中    # 注册tcp套接字    epoll.register(server_socket.fileno(), select.EPOLLIN)    '''因为epoll返回的触发事件对应的是套接字文件描述符，所以需要在字典中加入对应关系'''    # 定义一个字典，用于存放fd和套接字的对应关系，因为操作系统在事件通知的时候，使用的是fd，而不是套接字，我们需要使用fd来找到对应    # 的套接字，从而可以调用accept和recv    fd_to_socket = {}    fd_to_addr = {}    # 循环接收客户端连接    while True:        # 使用一个列表来接受操作系统的事件通知，poll()是阻塞的，当有数据到达时，poll才会解开阻塞        epoll_list = epoll.poll()        for fd, event in epoll_list:            # 首先判断事件通知中的fd是否对应监听套接字（监听套接字调用accept）            if fd == server_socket.fileno():                conn, addr = server_socket.accept()                # 监听到一个新的客户端连接，将conn也注册到epoll中                epoll.register(conn.fileno(), select.EPOLLIN)                print('有新的客户端到来%s' % str(addr))                # 将 conn 和 addr 信息分别保存起来                fd_to_socket[conn.fileno()] = conn                fd_to_addr[conn.fileno()] = addr            else:  # 如果不是监听套接字，那么都是客户端对应的套接字                # 接收数据                recvData = fd_to_socket[fd].recv(1024).decode('utf8')                if recvData:                    handle_request(fd_to_socket[fd], recvData)                # 如果没有数据，则表示客户端断开连接                else:                    # 从 epoll 中移除该 连接 fd                    epoll.unregister(fd)                    #  关闭fd对应的socket                    fd_to_socket[fd].close()                    print("%s---offline---" % str(fd_to_addr[fd]))if __name__ == '__main__':    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络通信 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> WEB Server </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信-简单WEB服务器</title>
      <link href="/2020/08/16/wang-luo-tong-xin-simple-web-server/"/>
      <url>/2020/08/16/wang-luo-tong-xin-simple-web-server/</url>
      
        <content type="html"><![CDATA[<p>本篇文章介绍如何实现一个简单 的Web Server 以及对应的问题解决方案。</p><a id="more"></a><h2 id="一、如何使用Python实现一个返回固定页面的Web-Server"><a class="header-anchor" href="#一、如何使用Python实现一个返回固定页面的Web-Server">¶</a>一、如何使用Python实现一个返回固定页面的Web Server</h2><ol><li><p>使用socket创建一个TCP Server</p></li><li><p>接受来自浏览器的TCP链接，并接收HTTP请求</p></li><li><p>返回固定响应数据给浏览器</p></li></ol><!--more--><pre class=" language-language-python"><code class="language-language-python">import socket, timedef handle_request(new_socket):    # 接收请求    recv_msg = new_socket.recv(1024)    print(recv_msg)    # 响应数据    response_msg = "HTTP/1.1 200 OK\r\n"    response_msg += "\r\n"    response_msg += "<h1>Hello</h1>"    # 返回响应数据（二进制数据）    time.sleep(1)    new_socket.send(response_msg.encode("utf-8"))    # 关闭该次socket连接    new_socket.close()def main():    # 创建TCP SOCKET实例    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 绑定地址（默认本机IP）和端口    tcp_server_socket.bind(("", 8890))    # 监听    tcp_server_socket.listen(128)    # 循环接收客户端连接    while True:        new_socket, client_addr = tcp_server_socket.accept()        # 处理每个客户端的请求        handle_request(new_socket)    # 关闭整个SOCKET    tcp_server_socket.close()if __name__ == '__main__':    main()</code></pre><h3 id="缺陷："><a class="header-anchor" href="#缺陷：">¶</a>缺陷：</h3><ol><li>这种简单的web server是阻塞的，同时只能处理一个请求。</li></ol><h2 id="二、解决服务器端口占用问题"><a class="header-anchor" href="#二、解决服务器端口占用问题">¶</a>二、解决服务器端口占用问题</h2><p>问题描述：当浏览器访问服务器时，服务器收到请求，马上返回响应数据，并且调用了<code>new_socket.close()</code>。此时，马上重启服务器的话，可能会提示端口被占用。</p><p>这是因为TCP的四次挥手过程中，谁先发送<code>FIN</code>包，则谁会在发送最后一个<code>ACK</code>包后进入<code>TIME_WAIT</code>状态，此状态会等待<code>2MSL</code>的时间（大概2-4分钟）。在这个阶段，服务器绑定的端口资源是被占用的。等这个阶段过了，端口会进入<code>CLOSED</code>状态，则可以被再次利用。</p><p>如何解决服务器重启端口被占用的问题：</p><pre class=" language-language-python"><code class="language-language-python">def main():    # 创建TCP SOCKET实例    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置重用地址    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    # 绑定地址（默认本机IP）和端口    tcp_server_socket.bind(("", 7890))    # 监听    tcp_server_socket.listen(128)    # 循环接收客户端连接    while True:        new_socket, client_addr = tcp_server_socket.accept()        # 处理每个客户端的请求        handle_request(new_socket)    # 关闭整个SOCKET    tcp_server_socket.close()</code></pre><blockquote><p>在创建<code>socket</code>实例之后，设置可以重用地址，就可以解决报错问题。</p></blockquote><h2 id="三、TCP协议3次握手、4次挥手"><a class="header-anchor" href="#三、TCP协议3次握手、4次挥手">¶</a>三、TCP协议3次握手、4次挥手</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/fHQGzW.jpg" alt="fHQGzW"></p><h3 id="三次握手："><a class="header-anchor" href="#三次握手：">¶</a>三次握手：</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><p><strong>三次握手流程和目的都相对简单：</strong></p><ol><li><p>客户端向服务器发送<code>SYN flag</code>的包，并携带<code>seq</code>为<code>x</code>。</p></li><li><p>服务器收到<code>SYN</code>包后，开始准备对应的资源，准备好后，发送<code>SYN+ACK</code>包，这实际上是服务器回应客户端的<code>ACK</code>包，合并了服务器让客户端准备资源的<code>SYN</code>包。所以携带了对应<code>SYN</code>的<code>seq y</code>，以及<code>ACK=x+1</code>。</p></li><li><p>客户端收到服务器发来的<code>SYN</code>包，则回复<code>ACK</code>包，<code>ack=y+1</code>。</p></li></ol><p>这样3次握手就建立好了，客户端和服务器都进入<code>ESTABLISHED</code>状态，表示资源都准备完毕。所以TCP的三次握手实际上是客户端与服务器之间互相要求准备资源以及回复资源已准备好的过程。</p><p>理论上应该是4次握手，但为了增加性能减小时间开销，中间的两次数据传输（服务器发送的<code>SYN</code>和<code>ACK</code>）合并在一起了。所以变成了3次握手。</p><h3 id="四次挥手："><a class="header-anchor" href="#四次挥手：">¶</a>四次挥手：</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><p><strong>四次挥手相对比较复杂：</strong></p><ol><li><p>假设客户端在完成数据传输后，首先开始发送<code>FIN</code>包（也就是我们的客户端程序调用<code>socket.close()</code>的时候，系统底层会自动发送<code>FIN</code>包），则表示客户端已经没有需要发送给服务器的数据。由于<code>SOCKET</code>是全双工的，所以客户端发送<code>FIN</code>只是表示客户端以后都不在发送数据，但此时还可以接收数据。</p></li><li><p>客户端发送出<code>FIN</code>包后，就会进入<code>FIN WAIT-1</code>状态，该状态一般很难观测到，因为该状态只维持到服务器响应<code>ACK</code>包，一般情况下都是瞬间就返回了（注意这里和3次握手不同，这里的<code>ACK</code>包不能与服务器发送的FIN包合并，因为服务器可能还有数据要继续发送给客户端，所以服务器可能要等到数据传输完毕才会向客户端发送<code>FIN</code>包，这就是为什么是四次挥手）</p></li><li><p>服务器收到客户端发来的<code>FIN</code>包，则马上发送回应的ACK包，此包没有意外的话，会瞬间到达客户端。</p></li><li><p>客户端收到<code>ACK</code>包后，结束<code>FIN WAIT-1</code>状态，进入<code>FIN WAIT-2</code>状态，该状态的目的是等待服务器发送<code>FIN</code>包。</p></li><li><p>服务器完成了最后的数据发送，则向客户端发送<code>FIN</code>包（也就是服务器程序调用<code>socket.close()</code>的时候，系统底层会自动发送<code>FIN</code>包），表示服务器以后也没有数据要发送了，开始断开服务器的发送通道。</p></li><li><p>服务器在发送出<code>FIN</code>后，会进入<code>LAST-ACK</code>状态（例如等待4s）。这个状态是为了等待客户端恢复确认的<code>ACK</code>包，因为服务器发送出去的<code>FIN</code>包，他无法确认客户端是否收到，如果超出<code>waittime</code>还未收到<code>ACK</code>包，则重新发送FIN包。</p></li><li><p>客户端如果正确收到了服务器发送的<code>FIN</code>包，理论上应该释放资源，并发送<code>ACK</code>包。但是如果客户端发出的<code>ACK</code>包由于某些原因，服务器并未收到，那么服务器在几秒后会重新发送<code>FIN</code>包，但客户端已经把资源释放掉了，则就会出现问题。怎么解决这个问题呢？解决方案是，客户端收到服务器发送的<code>FIN</code>包，并不马上释放资源（例如绑定的端口等），而是先回复<code>ACK</code>包，并进入<code>TIME-WAIT</code>状态，这个状态要持续<code>2MSL</code>（2-3分钟）。如果在<code>2MSL</code>时间段中，服务器都没有重新发送FIN包，则表示服务器已经收到了自己发出的<code>ACK</code>包，这是客户端才放心的释放资源。</p></li><li><p>最终客户端在等待<code>2MSL</code>后，进入<code>CLOSED</code>状态。服务器在确认收到最后一个<code>ACK</code>包后直接进入<code>CLOSED</code>状态。</p></li></ol><p><strong>资源占用的解释：</strong></p><p>我们知道，客户端是使用随机端口来发起<code>TCP</code>连接的，所以客户端首先发送<code>FIN</code>包的话，最后的<code>2MSL</code>是由客户端来等待，即使2-3分钟资源未被释放，也不会影响客户端另外发起新的请求（因为可用的随机端口很多，不会出现冲突）。</p><p>但是如果由服务器来首先发起<code>FIN</code>，则最后的<code>2MSL</code>要由服务器来等待，则在2-3分钟内，服务器绑定的端口并未被释放，所以如果此时重启服务器，则会出现资源未释放、端口被占用的情况。</p><p><strong>结论：尽量让客户端来发起断开连接的请求。如果要使服务器断开请求还不会出现占用端口的情况，则可以参考前面第二节的方法，为服务器SOCKET设置资源重用的属性。</strong></p><h2 id="四、改善简单WEB-Server"><a class="header-anchor" href="#四、改善简单WEB-Server">¶</a>四、改善简单WEB Server</h2><p>前面我们实现的简单Web Server不管客户端请求的<code>URI</code>是什么，我们都只能返回固定的<code>&quot;Hello</code>&quot;字符串。我们对其进行改善，让其根据接收到的请求，来返回不同的页面数据。</p><pre class=" language-language-python"><code class="language-language-python">import socketimport redef handle_request(new_socket):    # 接收请求    recv_msg = ""    recv_msg = new_socket.recv(1024).decode("utf-8")    if recv_msg == "":        print("recv null")        new_socket.close()        return    # 从请求中解析出URI    recv_lines = recv_msg.splitlines()    print(recv_lines)    # 使用正则表达式提取出URI    ret = re.match(r"[^/]+(/[^ ]*)", recv_lines[0])    if ret:        # 获取URI字符串        file_name = ret.group(1)        # 如果URI是/，则默认返回index.html的内容        if file_name == "/":            file_name = "/index.html"    try:        # 根据请求的URI，读取相应的文件        fp = open("." + file_name, "rb")    except:        # 找不到文件，响应404        response_msg = "HTTP/1.1 404 NOT FOUND\r\n"        response_msg += "\r\n"        response_msg += "<h1>----file not found----</h1>"        new_socket.send(response_msg.encode("utf-8"))    else:        html_content = fp.read()        fp.close()        # 响应正确 200 OK        response_msg = "HTTP/1.1 200 OK\r\n"        response_msg += "\r\n"        # 返回响应头        new_socket.send(response_msg.encode("utf-8"))        # 返回响应体        new_socket.send(html_content)    # 关闭该次socket连接    new_socket.close()def main():    # 创建TCP SOCKET实例    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # # 设置重用地址    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    # 绑定地址（默认本机IP）和端口    tcp_server_socket.bind(("", 7890))    # 监听    tcp_server_socket.listen(128)    # 循环接收客户端连接    while True:        new_socket, client_addr = tcp_server_socket.accept()        # 处理每个客户端的请求        handle_request(new_socket)    # 关闭整个SOCKET    tcp_server_socket.close()if __name__ == "__main__":    main()</code></pre><p>以上代码重点在于解析出<code>GET /index.html HTTP/1.1</code>中的<code>/index.html</code>部分，知道服务器要请求什么内容，然后按需找到对应的文件，已二进制方式读取文件内容并返回给客户端即可。</p><p>如果客户端没有指定访问的内容，则默认返回<code>index.html</code>页面。</p><p>注意异常的处理。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络通信 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> WEB Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信-长连接与短连接</title>
      <link href="/2020/08/16/wang-luo-tong-xin-chang-lian-jie-yu-duan-lian-jie/"/>
      <url>/2020/08/16/wang-luo-tong-xin-chang-lian-jie-yu-duan-lian-jie/</url>
      
        <content type="html"><![CDATA[<p>简单介绍长连接与短连接的优缺点。</p><a id="more"></a><h2 id="1-短连接："><a class="header-anchor" href="#1-短连接：">¶</a>1. 短连接：</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/%E7%9F%AD%E8%BF%9E%E6%8E%A5.png" alt="短连接"></p><ol><li>client 向 server 发起连接请求</li><li>server 接到请求，双方建立连接</li><li>client 向 server 发送消息</li><li>server 回应 client</li><li>一次读写完成，此时双方任何一个都可以发起 close 操作</li></ol><h2 id="2-长连接："><a class="header-anchor" href="#2-长连接：">¶</a>2. 长连接：</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="长连接"></p><ol><li>client 向 server 发起连接</li><li>server 接到请求，双方建立连接</li><li>client 向 server 发送消息</li><li>server 回应 client</li><li>一次读写完成，连接不关闭</li><li>后续读写操作…</li><li>长时间操作之后 client 发起关闭请求</li></ol><h2 id="3-优缺点分析"><a class="header-anchor" href="#3-优缺点分析">¶</a>3. 优缺点分析</h2><ol><li><p>长连接可以省去较多的 TCP 建立和关闭的操作，节约时间。但是如果用户量太大容易造成服务器负载过高最终导致服务不可用</p></li><li><p>短连接对于服务器来说实现起来较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但是如果用户访问量很大, 往往可能在很短时间内需要创建大量的连接，造成服务器响应速度过慢</p></li></ol><h2 id="4-总结"><a class="header-anchor" href="#4-总结">¶</a>4. 总结</h2><ol><li><p>小的 WEB 网站的 http 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源来让套接字保持存活。</p></li><li><p>对于中大型 WEB 网站一般都采用长连接，好处是响应用户请求的时间更短，用户体验更好，虽然更耗硬件资源一些，但这都不是事儿。另外，数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络通信 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 短连接 </tag>
            
            <tag> 长连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful规范的API接口设计</title>
      <link href="/2020/08/14/restful-gui-fan-de-api-jie-kou-she-ji/"/>
      <url>/2020/08/14/restful-gui-fan-de-api-jie-kou-she-ji/</url>
      
        <content type="html"><![CDATA[<p>在项目中，需要为 APP 撰写 API。刚开始接触的时候，并没有考虑太多，就想提供 URL，APP 端通过该 URL 进行查询、创建、更新等操作即可。但再对相关规范进行了解后，才发现，API 的设计并没有那么简单，远远不是 URL 的问题，而是一个通信协议的整体架构。</p><h2 id="使用-SSL（https）来提供-URL"><a class="header-anchor" href="#使用-SSL（https）来提供-URL">¶</a>使用 SSL（https）来提供 URL</h2><blockquote><p>首先，使用 https 可以在数据包被抓取时多一层加密。</p></blockquote><p>我们现在的 APP 使用环境大部分都是在路由器 WIFI 环境下，一旦路由器被入侵，那么黑客可以非常容易的抓取到用户通过路由器传输的数据，如果使用 http 未经加密，那么黑客可以很轻松的获取用户的信息，甚至是账户信息。</p><blockquote><p>其次，即使使用 https，也要在 API 数据传输设计时，正确的采用加密。</p></blockquote><p>例如直接将 token 信息放在 URL 中的做法，即使你使用了 https，黑客仅能抓到域名字符部分，不能抓到请求的数据，但是 URL 可以在浏览器或特殊客户端工具中直接看到。因此，使用 https 进行请求时，要采用 POST、PUT 或者 HEAD 的方式传输必要的数据。</p><h2 id="使用-GET、POST、PUT、DELETE-这几种请求模式"><a class="header-anchor" href="#使用-GET、POST、PUT、DELETE-这几种请求模式">¶</a>使用 GET、POST、PUT、DELETE 这几种请求模式</h2><p>请求模式也可以说是动作、数据传输方式，通常我们在 web 中的 form 有 GET、POST 两种。</p><p>而在 HTTP 中，存在以下这几种。</p><table><thead><tr><th style="text-align:left">请求方式</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">GET（选择）</td><td style="text-align:left">从服务器上获取一个具体的资源或者一个资源列表。</td></tr><tr><td style="text-align:left">POST（创建）</td><td style="text-align:left">在服务器上创建一个新的资源。</td></tr><tr><td style="text-align:left">PUT（更新）</td><td style="text-align:left">以整体的方式更新服务器上的一个资源。</td></tr><tr><td style="text-align:left">PATCH （更新）</td><td style="text-align:left">只更新服务器上一个资源的一个属性。</td></tr><tr><td style="text-align:left">DELETE（删除）</td><td style="text-align:left">删除服务器上的一个资源。</td></tr><tr><td style="text-align:left">HEAD</td><td style="text-align:left">获取一个资源的元数据，如数据的哈希值或最后的更新时间。</td></tr><tr><td style="text-align:left">OPTIONS</td><td style="text-align:left">获取客户端能对资源做什么操作的信息。</td></tr></tbody></table><h2 id="在-URI-中体现资源，而非动作"><a class="header-anchor" href="#在-URI-中体现资源，而非动作">¶</a>在 URI 中体现资源，而非动作</h2><p>阅读 RESTful 架构的参考文献之后，你会了解什么是资源的概念，以及 REST 的确切含义。再构建 API 的 URL 的时候，URI 中应该仅包含资源（对象），而不要加入动作。</p><p>比如 <code>/user/1/update</code> ，其中 <code>update</code> 就是一个动作，虽然我们希望通过这个 URI 来实现用户 ID 为 1 的用户进行信息更新，但是按照 RESTful 的规范，<code>update</code>作为动作，应该用上面的 <code>PUT</code> 来表示，所以请求更新用户信息，应该使用 <code>PUT /user/1</code> 来表示更新用户 ID 为 1 的用户信息。</p><p>如果去对应上面的请求模式：</p><ul><li>GET 表示显示、列出、展示</li><li>POST 表示提交、创建</li><li>PUT 表示更新</li><li>DELETE 表示删除</li></ul><h2 id="版本"><a class="header-anchor" href="#版本">¶</a>版本</h2><p>API 的开发直接关系了 APP 是否可以正常使用，如果原本运行正常的 API，突然改动，那么之前使用这个 API 的 APP 可能无法正常运行。APP 是不可能强迫用户主动升级的，因此，通过 API 版本来解决这个问题。也就是说，API 的多个版本是同时运行的，而且都要保证可以正常使用。</p><p>按照 RESTful 的规范，不同的版本也应该用相同的 API URL，通过 header 信息来判断版本，再调用不同版本的程序进行处理。但是这明显会给开发带来巨大的成本。</p><p>解决办法有两种：</p><ol><li>新版本兼容旧版本，所有旧版本的动作、字段、操作，都在新版本中可以被实现，但明显这样的维护成本很大；</li><li>不同的版本，用不同的 URL 来提供服务，比如在 URL 中通过 v1、v2 来区分版本号，或者采用子域名的方式，比如 <a href="http://v2.api.xxx.com/user" target="_blank" rel="noopener">v2.api.xxx.com/user</a> 的方式。</li></ol><h2 id="HTTP-响应码"><a class="header-anchor" href="#HTTP-响应码">¶</a>HTTP 响应码</h2><p>在用户发出请求，服务端对请求进行响应时，给予正确的 HTTP 响应状态码，有利于让客户端正确区分遇到的情况。</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">请求方式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>200 </code></td><td style="text-align:center"><code> [GET]</code></td><td style="text-align:left">（<code>OK</code>成功）服务器成功返回用户请求的数据,该操作是幂等的（Idempotent）</td></tr><tr><td style="text-align:center"><code>201 </code></td><td style="text-align:center"><code> [POST/PUT/PATCH]</code></td><td style="text-align:left">（<code>CREATED</code>已建立）用户新建或修改数据成功</td></tr><tr><td style="text-align:center"><code>202</code></td><td style="text-align:center"><code>[*]</code></td><td style="text-align:left">(<code>Accepted</code>接受请求)表示一个请求已经进入后台排队（异步任务）</td></tr><tr><td style="text-align:center"><code>204</code></td><td style="text-align:center"><code>[DELETE]</code></td><td style="text-align:left">(<code>NO CONTENT</code>无内容) 用户删除数据成功</td></tr><tr><td style="text-align:center"><code>300 </code></td><td style="text-align:center"></td><td style="text-align:left">（<code>Multiple Choices</code>多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td style="text-align:center"><code>301 </code></td><td style="text-align:center"></td><td style="text-align:left">（<code>Permanently Moved</code>永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td></tr><tr><td style="text-align:center"><code>302 </code></td><td style="text-align:center"></td><td style="text-align:left">（<code>Temporarily Moved</code>临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td style="text-align:center"><code>303 </code></td><td style="text-align:center"></td><td style="text-align:left">（<code>See Other</code>查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</td></tr><tr><td style="text-align:center"><code>304 </code></td><td style="text-align:center"></td><td style="text-align:left">（<code>Not Modified</code>未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td></tr><tr><td style="text-align:center"><code>305 </code></td><td style="text-align:center"></td><td style="text-align:left">（<code>Use Proxy</code>使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td></tr><tr><td style="text-align:center"><code>307</code></td><td style="text-align:center"></td><td style="text-align:left"><code>Temporary Redirect</code>（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td style="text-align:center"><code>400</code></td><td style="text-align:center"><code>[POST/PUT/PATCH]</code></td><td style="text-align:left"><code> INVALID REQUEST</code>(坏请求) 用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</td></tr><tr><td style="text-align:center"><code>401</code></td><td style="text-align:center"><code>[*]</code></td><td style="text-align:left"><code>Unauthorized</code> (未授权) 表示用户没有权限（令牌、用户名、密码错误）</td></tr><tr><td style="text-align:center"><code>403</code></td><td style="text-align:center"><code>[*]</code></td><td style="text-align:left"><code>Forbidden</code> （禁止）表示用户得到授权（与401错误相对），但是访问是被禁止的</td></tr><tr><td style="text-align:center"><code>404</code></td><td style="text-align:center"><code>[*]</code></td><td style="text-align:left"><code>NOT FOUND</code> （未找到）用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</td></tr><tr><td style="text-align:center"><code>405</code></td><td style="text-align:center"></td><td style="text-align:left"><code> Method not allowed</code>（方法不被允许）不支持该Request的方法</td></tr><tr><td style="text-align:center"><code>406</code></td><td style="text-align:center"></td><td style="text-align:left"><code>Not Acceptable</code>（无法接受）无法使用请求的内容特性来响应请求的网页，也就是后台的返回结果前台无法解析（比如用户请求 JSON 格式，但是只有 XML 格式）</td></tr><tr><td style="text-align:center"><code>407</code></td><td style="text-align:center"></td><td style="text-align:left"><code>Proxy Authentication Required</code>（要求进行代理认证）与状态码401类似， 用于需要进行认证的代理服务器.</td></tr><tr><td style="text-align:center"><code>408</code></td><td style="text-align:center"></td><td style="text-align:left"><code> Request Timeout</code>(请求超时) 如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接</td></tr><tr><td style="text-align:center"><code>410</code></td><td style="text-align:center"><code>[GET]</code></td><td style="text-align:left"><code>Gone</code> （过去的）用户请求的资源被永久删除，且不会再得到的</td></tr><tr><td style="text-align:center"><code>422</code></td><td style="text-align:center"><code> [POST/PUT/PATCH]</code></td><td style="text-align:left"><code>Unprocesable entity</code> （不可处理）当创建一个对象时，发生一个验证错误</td></tr><tr><td style="text-align:center"><code>500</code></td><td style="text-align:center"><code> [*]</code></td><td style="text-align:left"><code>INTERNAL SERVER ERROR</code>(服务器内部错误）服务器发生错误，用户将无法判断发出的请求是否成功</td></tr></tbody></table><h2 id="返回值结构"><a class="header-anchor" href="#返回值结构">¶</a>返回值结构</h2><p>在完成了上面的 URL 部署之后，接下来我们来看看返回结果应该怎么样来确定。</p><p>我看到大部分文献中指出，最好使用 JSON 进行返回，而非 xml。</p><p>我认为原因可能有两点：</p><ol><li>JSON 可以很好的被很多程序支持，javascript 的 ajax 可以直接将 JSON 转换为对象。</li><li>JSON 的格式在容量上比 xml 小很多，可以减低宽带占用，提高传输效率。</li></ol><p>那么，返回值应该怎么去部署呢？</p><p>首先，字段的合理返回，数据的包裹。因为返回值中，我们常常要对数据进行区分分组，或者按照从属关系打包，所以，我们再返回时，最好有包裹的思想，把数据存放在不同的包裹中进行返回。</p><pre class=" language-language-python"><code class="language-language-python">{    'error_code': 0,    'data': {        'user_id': 1,        'username': 'xiaomin'    },    'server_time': 14939939}</code></pre><p>上面返回的 JSON 中，使用 data 来作为数据包，将所有数据统一以这个字段进行包裹。除了 data，也可以用 list 等其他形式的包裹，命名都是自己来根据自己的需要确定的。</p><pre class=" language-language-python"><code class="language-language-python">{    'error_code': 0,    'list': [        {'user_id': 1, 'username': 'xiaoming'},        {'user_id': 2, 'username': 'goudan'}    ]    'server_time': 14939939}</code></pre><p>总之，不要不分包，直接把所有数据和一些你想返回的全局数据混在一起进行返回。</p><p>其次，错误码。错误码的作用是方便查找错误原因，通常情况下，可以用 error_code 来表示，当 error_code=0 时，表示没有发生错误，当 error_code&gt;0 时，发生了错误，并且提供较为详细的文档，告诉客户端对应的 error_code 值所产生的错误的原因和位置。</p><p>最后，空白压缩和字符转换。也就是返回的 JSON 结果不要换行和空格，用一行返回结果，使整个结果文本容量最小。同时，中文等字符或结果中有引号，都进行字符转换，防止结果无法被正确识别。</p><h2 id="鉴权"><a class="header-anchor" href="#鉴权">¶</a>鉴权</h2><p>其实也就是客户端的权限控制。一般而言，会给客户端分发一个 token 来确定该客户端的唯一身份。客户端在请求时，通过这个 token，判断发出请求的客户端所对应的用户，及其相关信息和权限。</p><p>前文已经提到了，token 信息不是用来进行处理的数据，虽然可以通过 POST、PUT 等进行数据提交或传输，但是从 RESTful 规范来讲，它不属于操作数据，在服务端进行处理时，仅是利用 token 进行鉴权处理，所以，我的建议是通过 header 来发送 token。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级-内存管理</title>
      <link href="/2020/07/30/python-gao-ji-nei-cun-guan-li/"/>
      <url>/2020/07/30/python-gao-ji-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理机制"><a class="header-anchor" href="#内存管理机制">¶</a>内存管理机制</h2><blockquote><p>Python中不但变量名无需事先声明，而且也无需类型声明。在Python语言中，对象的类型和内存占用都是运行时确定的。在赋值时解释器会根据语法和右侧的操作数来决定新对象的类型。在对象创建后，一个该对象的引用会被赋值给左侧的变量。</p></blockquote><a id="more"></a><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/python%E9%92%88%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%20.png" alt="python针对变量的内存管理机制"></p><h3 id="id-函数"><a class="header-anchor" href="#id-函数">¶</a>id()函数</h3><blockquote><p>python的内置函数 id()可以用来查看对象的内存地址</p></blockquote><pre class=" language-language-python"><code class="language-language-python">>>> a = 1>>> id(a)24834392>>> a = 'banana'>>> id(a)139990659655312>>> a = 3>>> b = 3>>> id(a)10289448>>> id(b)10289448</code></pre><h3 id="引用计数"><a class="header-anchor" href="#引用计数">¶</a>引用计数</h3><ul><li><p>要保持追踪内存中的对象，Python使用了引用计数这一简单技术。</p></li><li><p>也就是说Python内部记录着所有使用中的对象各有多少引用。</p><ul><li>一个内部跟踪变量，称为引用计数器。</li><li>每个对象各有多少个引用，简称引用计数。</li><li>当对象被创建时，就创建了一个引用计数，当这个对象不再需要时，也就是说，这个对象的引用计数变为0时，它通常会被垃圾回收。</li></ul></li></ul><h4 id="增加引用计数"><a class="header-anchor" href="#增加引用计数">¶</a>增加引用计数</h4><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%20.png" alt="增加引用计数"></p><h4 id="减少引用计数"><a class="header-anchor" href="#减少引用计数">¶</a>减少引用计数</h4><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/%E5%87%8F%E5%B0%91%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%20.png" alt="减少引用计数"></p><h3 id="is和"><a class="header-anchor" href="#is和">¶</a>is和==</h3><p>在讲is和==这两种运算符区别之前，首先要知道Python中对象包含的三个基本要素，分别是：<code>id</code>(身份标识)、<code>type</code>(数据类型)和<code>value</code>(值)。</p><p><code>is</code>和<code>==</code>都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。</p><p><code>is</code>也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是<code>id</code>是否相同。</p><p><code>==</code>是python标准操作符中的比较操作符，用来比较判断两个对象的<code>value</code>(值)是否相等</p><h3 id="可变类型与不可变类型"><a class="header-anchor" href="#可变类型与不可变类型">¶</a>可变类型与不可变类型</h3><ol><li><code>list</code>、<code>dict</code>、<code>set</code>属于可变类型</li><li><code>number</code>、<code>str</code>、<code>tuple</code>、<code>bool</code>属于不可变类型</li></ol><p>不可变数据类型在第一次声明赋值声明的时候, 会在内存中开辟一块空间, 用来存放这个变量被赋的值, 而这个变量实际上存储的, 并不是被赋予的这个值, 而是存放这个值所在空间的内存地址, 通过这个地址, 变量就可以在内存中取出数据了. 所谓不可变就是说, 我们不能改变这个数据在内存中的值, 所以当我们改变这个变量的赋值时, 只是在内存中重新开辟了一块空间, 将这一条新的数据存放在这一个新的内存地址里, 而原来的那个变量就不在引用原数据的内存地址而转为引用新数据的内存地址了。</p><p>结合不可变数据类型，可变数据类型就很好理解来，可变数据类型是指变量所指向的内存地址处的值是可以被改变的。</p><p><strong>从另外一个角度来看：</strong></p><p>可变类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。</p><p>可变数据类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。</p><h3 id="内存管理优化"><a class="header-anchor" href="#内存管理优化">¶</a>内存管理优化</h3><p>Python采用基于值的内存管理模式，相同的值在内存中只有一份。这是很多Python教程上都会提到的一句话，但实际情况要复杂的多。什么才是值？什么样的值才会在内存中只保存一份？这是个非常复杂的问题。</p><h4 id="在python交互环境中"><a class="header-anchor" href="#在python交互环境中">¶</a>在python交互环境中</h4><p>首先明确一点，整数、实数、字符串是真正意义上的值，而上面那句话中的“值”主要指<strong>不可变类型</strong>中的整数和字符串。对于列表、元组、字典、集合以及range对象、map对象等容器类对象，它们不是普通的“值”，即使看起来是一样的，在内存中也不会只保存一份。</p><h5 id="整数"><a class="header-anchor" href="#整数">¶</a>整数</h5><pre class=" language-language-python"><code class="language-language-python">In [51]: a = 12In [52]: b = 12In [53]: a is bOut[53]: True</code></pre><p>python中对于小的整数存在一个缓存池。为了避免因创建相同的值而重复申请内存空间所带来的效率问题， Python解释器会在启动时创建出小整数池，范围是<code>[-5,256]</code>，该范围内的小整数对象是全局解释器范围内被重复使用，永远不会被垃圾回收机制回收。</p><h5 id="实数"><a class="header-anchor" href="#实数">¶</a>实数</h5><pre class=" language-language-python"><code class="language-language-python">In [8]: a = 12.5In [9]: b = 12.5In [10]: a is bOut[10]: False</code></pre><p>对于实数，由于计算机存储实数会有精度问题，很难精确存储，所以不进行缓存，也就是说，即使看起来是一样的实数，在内存中也不是一份。</p><h5 id="字符串"><a class="header-anchor" href="#字符串">¶</a>字符串</h5><pre class=" language-language-python"><code class="language-language-python">In [63]: a = "abc123_"In [64]: b = "abc123_"In [65]: a is bOut[65]: TrueIn [66]: a = "12 3"In [67]: b = "12 3"In [68]: a is bOut[68]: False</code></pre><p>由于变量的存储机制，python增加了字符串的<code>intern</code>机制。也就是说，值同样的字符串对象（<strong>整数也使用</strong>）仅仅会保存一份，是共用的，这也决定了字符串必须是不可变对象。</p><pre class=" language-language-python"><code class="language-language-python">In [70]: c = "a" + "b"  # 在 compile-time（编译时）已经求完值，被替换成了'ab', In [71]: id(c)Out[71]: 4489029232In [72]: d = "ab"  # 此时，内存中已经有 'ab', 因此直接引用即可In [73]: id(d)Out[73]: 4489029232  In [74]: id(a + "b")  # 在run-time（运行时）拼接的，导致没有被主动internOut[74]: 4519083312 In [75]: a = 'hello world'In [76]: b = 'hello world'In [77]: a is b  # intern机制仅仅对那些看起来像是Python标识符的字符串对象才会触发Out[77]: False</code></pre><p><strong>intern机制</strong></p><p><strong>优点</strong>：在创建新的字符对象时，如果内存中已经存在，则直接引用，避免频繁的创建和销毁内存，提升效率。</p><p><strong>缺点</strong>：在拼接字符串时，或者在改动字符串时会极大的影响性能。原因是字符串在Python当中是不可变对象，所以对字符串的改动不是inplace（原地）操作，需要新开辟内存地址，新建对象。这也是为什么拼接字符串的时候不建议用<code>+</code>而是用<code>join()</code>。<code>join()</code>是先计算出全部字符串的长度，然后再一一拷贝，仅仅创建一次对象。</p><p><strong>总结</strong></p><ol><li>单词，即Python标识符，不可修改，默认开启intern机制，共用对象，引用计数为0时自动被回收。</li><li>字符串（包含了除Python标识符以外的字符），不可修改，默认没有开启intern机制，引用计数为0时自动被回收。</li><li>特殊情况下（动态拼接），不会被主动intern。</li></ol><h5 id="元组"><a class="header-anchor" href="#元组">¶</a>元组</h5><pre class=" language-language-python"><code class="language-language-python">In [4]: a = (1, 2)In [5]: b = (1, 2)In [6]: a is bOut[6]: False</code></pre><p>对于元组等容器类对象，它们不是普通的“值”，即使看起来是一样的，在内存中也不会只保存一份。</p><h4 id="在Python代码中"><a class="header-anchor" href="#在Python代码中">¶</a>在Python代码中</h4><p>在同一模块文件中，不可变类型的数字、字符串、元组， 在值相同时，只会保存一份;而不同模块中的不同值，才会重新生成。</p><p><strong>模块 <code>bbb.py</code></strong></p><pre class=" language-language-python"><code class="language-language-python">c1 = 1000c2 = "hello world % "c3 = (1, 2)c4 = 12.3</code></pre><p><strong>模块 <code>aaa.py</code></strong></p><pre class=" language-language-python"><code class="language-language-python">from bbb import *a = 1000b = 1000print(a is b)  # Trueprint(a is c1)  # Falsea = "hello world % "b = "hello world % "print(a is b)  # Trueprint(a is c2)  # Falsea = (1, 2)b = (1, 2)print(a is b)  # Trueprint(a is c3)  # Falsea = 12.3b = 12.3print(a is b)  # Trueprint(a is c4)  # False</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用计数 </tag>
            
            <tag> 可变类型与不可变类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRF-序列化与反序列化</title>
      <link href="/2020/07/08/drf-xu-lie-hua-yu-fan-xu-lie-hua/"/>
      <url>/2020/07/08/drf-xu-lie-hua-yu-fan-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<p>DRF内置的序列化类，可以对整个模型类进行序列化与反序列化，简化了繁杂的工作。</p><a id="more"></a><h2 id="内置字段序列化"><a class="header-anchor" href="#内置字段序列化">¶</a>内置字段序列化</h2><h3 id="模型类"><a class="header-anchor" href="#模型类">¶</a>模型类</h3><pre class=" language-language-python"><code class="language-language-python">from django.db import models# Create your models here.class Authors(models.Model):    name = models.CharField(max_length=10, verbose_name='姓名')    def __str__(self):        return self.name    class Meta:        db_table = 'db_authors'        verbose_name = '作者'        verbose_name_plural = '作者'class Books(models.Model):    title = models.CharField(max_length=10, verbose_name='标题')    price = models.DecimalField(max_digits=7, decimal_places=2, verbose_name='单价')    publish = models.CharField(max_length=20, verbose_name='出版社')    author = models.ForeignKey(Authors, on_delete=models.CASCADE)    def __str__(self):        return self.title    class Meta:        db_table = 'db_books'        verbose_name = '图书'        verbose_name_plural = '图书'</code></pre><h3 id="序列化类"><a class="header-anchor" href="#序列化类">¶</a>序列化类</h3><h4 id="1-全部字段序列化"><a class="header-anchor" href="#1-全部字段序列化">¶</a>1. 全部字段序列化</h4><pre class=" language-language-python"><code class="language-language-python">from rest_framework.serializers import ModelSerializerfrom .models import Books, Authorsfrom rest_framework import serializersclass AuthorsSerializer(ModelSerializer):    class Meta:        model = Authors        fields = '__all__'        class BooksSerializer(ModelSerializer):       class Meta:        model = Books        fields = '__all__'        </code></pre><h4 id="2-指定字段序列化"><a class="header-anchor" href="#2-指定字段序列化">¶</a>2. 指定字段序列化</h4><h5 id="1-外键字段内置方式序列化"><a class="header-anchor" href="#1-外键字段内置方式序列化">¶</a>&lt;1&gt; 外键字段内置方式序列化</h5><p><strong>图书类序列化</strong></p><pre class=" language-language-python"><code class="language-language-python">from rest_framework.serializers import ModelSerializerfrom .models import Books, Authorsfrom rest_framework import serializersclass BooksSerializer(ModelSerializer):    # author = serializers.PrimaryKeyRelatedField(read_only=True)  # 内置关联字段，默认序列化方式，关联对象的主键        # author = serializers.StringRelatedField(read_only=True)  # 内置关联字段，此字段将被序列化为关联对象的字符串表示方式（即__str__方法的返回值）        # author = serializers.HyperlinkedRelatedField(view_name='authors-detail', read_only=True)  # 内置关联字段，此字段被序列化为关联对象的路由地址    # author = serializers.SlugRelatedField(read_only=True, slug_field='id')  # 内置关联字段，指定关联对象的字段        # author = serializers.CharField(source='author.name', read_only=True)  # 指定关联对象的字段        # author = AuthorsSerializer()  # 将关联对象所有字段全部序列化    class Meta:        model = Books        fields = '__all__'</code></pre><p><strong>作者类序列化</strong></p><pre class=" language-language-python"><code class="language-language-python">from rest_framework.serializers import ModelSerializerfrom .models import Books, Authorsfrom rest_framework import serializersclass AuthorsSerializer(ModelSerializer):    # books_set = serializers.PrimaryKeyRelatedField(read_only=True, many=True)    # books_set = serializers.StringRelatedField(many=True)    # books_set = serializers.HyperlinkedRelatedField(view_name='books-detail', read_only=True, many=True)    # books_set = BookSerializer(many=True)    # books_set = BookRelateField(read_only=True, many=True)  # 自定义关联字段    class Meta:        model = Authors        fields = '__all__'</code></pre><h5 id="2-外键字段自定义方式序列化"><a class="header-anchor" href="#2-外键字段自定义方式序列化">¶</a>&lt;2&gt; 外键字段自定义方式序列化</h5><pre class=" language-language-python"><code class="language-language-python">from rest_framework.serializers import ModelSerializerfrom .models import Books, Authorsfrom rest_framework import serializersclass BookRelateField(serializers.RelatedField):    def to_representation(self, value):        return 'Author: {}'.format(value)class AuthorsSerializer(ModelSerializer):    books_set = BookRelateField(read_only=True, many=True)  # 自定义关联字段    class Meta:        model = Authors        fields = '__all__'class AuthorRelateField(serializers.RelatedField):    def to_representation(self, value):        return 'Author: {} {}'.format(value.id, value.name)class BooksSerializer(ModelSerializer):    author = AuthorRelateField(read_only=True) # 自定义关联字段        class Meta:        model = Books        fields = '__all__'       </code></pre><p>以上序列化方式，任选其一均可，但是注意，此时只能保证<strong>序列化成功</strong>，不能保证反序列化</p><h2 id="自定义字段序列化"><a class="header-anchor" href="#自定义字段序列化">¶</a>自定义字段序列化</h2><blockquote><p>最大好处, 在于将序列化字段与反序列化字段分离，互不影响</p></blockquote><h3 id="1-修改模型类"><a class="header-anchor" href="#1-修改模型类">¶</a>&lt;1&gt; 修改模型类</h3><p>需要在模型类中用<code>@property</code>来实现，可插拔</p><h4 id="模型类-v2"><a class="header-anchor" href="#模型类-v2">¶</a>模型类</h4><pre class=" language-language-python"><code class="language-language-python">class Books(models.Model):    title = models.CharField(max_length=10, verbose_name='标题')    price = models.DecimalField(max_digits=7, decimal_places=2, verbose_name='单价')    publish = models.CharField(max_length=20, verbose_name='出版社')    author = models.ForeignKey(Authors, on_delete=models.CASCADE)    @property  # 插拔字段 - 默认为read_only(不需要考虑反序列化)，且不能修改    def author_name(self):        return self.author.name    @property    def author_info(self):        from .serializers import AuthorsSerializer        return AuthorsSerializer(self.author).data    def __str__(self):        return self.title</code></pre><h4 id="序列化类-v2"><a class="header-anchor" href="#序列化类-v2">¶</a>序列化类</h4><pre class=" language-language-python"><code class="language-language-python">class BooksSerializer(ModelSerializer):    class Meta:        model = Books        fields = ('id', 'title', 'price', 'author', 'author_name', 'author_info')        extra_kwargs = {            'author': {                'write_only': True            }        }</code></pre><h3 id="2-修改序列化类"><a class="header-anchor" href="#2-修改序列化类">¶</a>&lt;2&gt;修改序列化类</h3><blockquote><p>模型类不变，只在序列化器中添加序列化字段</p></blockquote><h4 id="序列化类-v3"><a class="header-anchor" href="#序列化类-v3">¶</a>序列化类</h4><pre class=" language-language-python"><code class="language-language-python">class BooksSerializer(ModelSerializer):    author_url = serializers.HyperlinkedIdentityField(view_name='authors-detail', read_only=True)  # 内置序列化方式，关联对象的路由地址        author_name = serializers.SerializerMethodField()    # author_name 字段在数据库中不能存在，下面写方法的时候前面加 get_  就可以，这样就得到我们需要的数据了。    @staticmethod    def get_author_name(obj):        """        固定写法,obj代表Books实例对象,模型类配置了反向引用author代表作者对象        """        return obj.author.id    class Meta:        model = Books        fields = ('id', 'title', 'price', 'author', 'author_name', 'author_url')        extra_kwargs = {            'author': {                'write_only': True            }        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRF </tag>
            
            <tag> 序列化 </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归函数</title>
      <link href="/2020/06/06/python-han-shu-di-gui-han-shu/"/>
      <url>/2020/06/06/python-han-shu-di-gui-han-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-定义"><a class="header-anchor" href="#1-定义">¶</a>1. 定义</h3><p>函数调用函数自身，这种方式称为递归，这种函数称为递归函数</p><a id="more"></a><blockquote><p>递归函数使用过程中，需要找到<code>不变的规律</code>和停止递归的<code>边界条件</code>，</p><p>因为函数自身调用自身，函数本身的结构不变，只是<code>每次传的参数改变</code>啦</p><p>递归实现过程(<strong>扩展</strong>)：利用栈的思想，先找边界条件，同时将后面的任务存起来，一直到最前面的边界条件，然后回去，每次从栈中取任务，进行计算，一直到最后一个任务取完，结果也计算完毕</p></blockquote><h3 id="2-递归过程"><a class="header-anchor" href="#2-递归过程">¶</a>2. 递归过程:</h3><ul><li>递归前进段</li><li>递归边界条件</li><li>递归返回段</li></ul><h3 id="3-案例讲解"><a class="header-anchor" href="#3-案例讲解">¶</a>3. 案例讲解</h3><h4 id="递归求100以内偶数和"><a class="header-anchor" href="#递归求100以内偶数和">¶</a>递归求100以内偶数和</h4><pre class=" language-language-python"><code class="language-language-python"># f(100) = 0 + 2 + 4 + ... + 98  + 100# f(98)  = 0 + 2 + ... + 98# f(96) = 0 + 2 + ...  + 96# ...# f(2) = f(0) + 2# f(0) = 0# n!=0: f(n) = f(n - 2) + n# n = 0  f(0) = 0def mysum(n):    """n以内所有偶数和"""    if n == 0:        return 0    else:        return mysum(n-2) + nr = mysum(100)print(r)</code></pre><blockquote><p>100以内奇数和, 100以内所有数字和类似</p></blockquote><h4 id="10以内所有数字之积-10的阶乘"><a class="header-anchor" href="#10以内所有数字之积-10的阶乘">¶</a>10以内所有数字之积(<code>10的阶乘</code>)</h4><pre class=" language-language-python"><code class="language-language-python"># 1! = 1# 2！= 1*2# 3！= 1*2*3# 。。。# 10! = 1 * 2 * 3 * 4 * ... * 10# f(10) = f(9) * 10# n!=1 :  f(n)  = f(n-1) * n# n==1: f(1) = 1def f(n):    if n != 1:        return f(n - 1) * n    else:        return 1r = f(10)print(r)</code></pre><h4 id="递归实现斐波那契数列"><a class="header-anchor" href="#递归实现斐波那契数列">¶</a>递归实现斐波那契数列</h4><pre class=" language-language-python"><code class="language-language-python"># 1  1  2  3  5  8  13  21# f(n) = f(n-1) + f(n-2)# n=1 : 1# n=2 : 1def fibonacci(n):    if n == 1 or n == 2:        return 1    else:        return fibonacci(n - 1) + fibonacci(n - 2)r = fibonacci(5)print(r)</code></pre><h4 id="递归实现吸烟问题"><a class="header-anchor" href="#递归实现吸烟问题">¶</a>递归实现吸烟问题</h4><p>吸烟有危害，不仅仅危害人体健康，还会对社会产生不良的影响。吸烟还很容易引起喉头炎、气管炎，肺气肿等问题； 那么现在假设人一生抽烟10000根达到极限峰值，再抽一根烟就像压倒骆驼的最后一根稻草，会使人体爆发疾病问题； 每天一个人抽烟的个数都比前天多一根（第一天抽一根），且一周只有工作日（周一~周五）会吸烟； 请使用递归的方式求出一个人按照以上方式抽烟达到10000根，爆发疾病需要历经多少天</p><pre class=" language-language-python"><code class="language-language-python">def smoker(day, count, amount):    """    递归解决吸烟问题    :param day: 当前的天数    :param count: 当天的吸烟数量    :param amount: 总计的吸烟数量    :return: 吸到10000根烟的天数    """    if amount >= 10000:        # 如果吸烟总数大于10000， 返回天数        return day    else:        day += 1 # 每吸一次烟，天数加1        if day % 7 != 6 and day % 7 != 0:            # 只有周六，周日不吸烟，判断不是周六，也不是周日            count += 1 # 当天吸烟的数量            amount += count # 目前为止，吸烟的总数量        return smoker(day, count, amount)print(smoker(1, 1, 1)) # 第1天，吸了1根烟，总共吸了1根烟</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名函数</title>
      <link href="/2020/06/06/python-han-shu-ni-ming-han-shu/"/>
      <url>/2020/06/06/python-han-shu-ni-ming-han-shu/</url>
      
        <content type="html"><![CDATA[<ul><li>匿名函数的另一个别称是<code>lambda表达式</code></li></ul><a id="more"></a><ul><li><p>lambda表达式的语法：</p><pre class=" language-language-python"><code class="language-language-python">lambda argument_list: expression</code></pre><ul><li><code>argument_list</code>是参数列表。它的结构与Python中函数(<code>function</code>)的参数列表是一样的。</li><li><code>expression</code>是一个关于参数的表达式。表达式中出现的参数需要在<code>argument_list</code>中有定义，并且表达式只能是单行的。</li></ul><pre class=" language-language-python"><code class="language-language-python"># lambda x: x*x# 这个lambda表达式实际等同于：# def f(x):#   return x*xIn [15]: f = lambda x: x * xIn [16]: fOut[16]: <function __main__.<lambda>(x)>In [17]: f(5)Out[17]: 25    In [24]: x2 = lambda *args: [x**2 for x in list(args)]In [25]: x2(1, 2, 3, 4, 5, 6, 7)Out[25]: [1, 4, 9, 16, 25, 36, 49]</code></pre></li><li><p>匿名函数作为参数</p><pre class=" language-language-python"><code class="language-language-python">In [7]: s = [x for x in range(10)]In [8]: sOut[8]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [9]: s.sort(key=lambda x : abs(x-5))In [10]: sOut[10]: [5, 4, 6, 3, 7, 2, 8, 1, 9, 0]</code></pre><pre class=" language-language-python"><code class="language-language-python">In [32]: stus = [...:     {"name": "zhangsan", "age": 18},...:     {"name": "lisi", "age": 19},...:     {"name": "wangwu", "age": 17}...: ]In [33]: stus.sort(key=lambda x : x["name"])In [34]: stusOut[34]:[{'name': 'lisi', 'age': 19}, {'name': 'wangwu', 'age': 17}, {'name': 'zhangsan', 'age': 18}]In [35]: stus.sort(key=lambda x : x["age"])In [36]: stusOut[36]:[{'name': 'wangwu', 'age': 17}, {'name': 'zhangsan', 'age': 18}, {'name': 'lisi', 'age': 19}]</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
            <tag> 匿名函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高阶函数</title>
      <link href="/2020/06/06/python-han-shu-gao-jie-han-shu/"/>
      <url>/2020/06/06/python-han-shu-gao-jie-han-shu/</url>
      
        <content type="html"><![CDATA[<ol><li><p>定义</p><p>当一个函数 接收 另一个函数作为参数， 它就是 <code>高阶函数</code></p></li></ol><a id="more"></a><ol start="2"><li><p>示例</p><pre class=" language-language-python"><code class="language-language-python">def func(a, x, y):    a(x, y)  # a就是传递的 函数参数f，  执行 a 相当于 执行  fdef f(x, y):    print(x + y)func(f, 1, 2)  # 3， 在函数f执行过程中，输出 3</code></pre></li></ol><h2 id="四大高阶函数"><a class="header-anchor" href="#四大高阶函数">¶</a>四大高阶函数</h2><h3 id="map-func-iterable"><a class="header-anchor" href="#map-func-iterable">¶</a><code>map(func, iterable)</code></h3><blockquote><p>将 <strong>可迭代对象</strong> 中的每个值 按照 第一个参数( <strong>函数</strong>)的 规则 依次 处理， 得到一个 新的 <strong>迭代器</strong> 对象</p></blockquote><pre class=" language-language-python"><code class="language-language-python">def func(alist):    """    :param alist: 接收列表作为参数    :return: 将列表中每个数字，求平方之后，返回一个新列表    """    def sqr(x):        return x * x    r = map(sqr, alist) # r是迭代器对象    return list(r)  # 将迭代器对象转换为列表r = func([11, 22, 33, 44, 55])print(r)</code></pre><pre class=" language-language-python"><code class="language-language-python"># 定义函数， 接收 列表 作为参数 ， 返回一个 包含 绝对值  的新列表# abs()：python内置函数，求一个数的绝对值def func(alist):    # map 高阶函数需要的参数，不用管是内置的，还是自定义的    r = map(abs, alist)    return list(r)r = func([-12, 34, 56, -98])print(r)  # [12, 34, 56, 98]</code></pre><pre class=" language-language-python"><code class="language-language-python"># 定义函数，接收 一个 包含 单词的字符串， 返回 一个 每个单词 首字母大写 的字符串def func(astr):    # 将字符串切分为单词列表    wlist = astr.split()    def toUpper(x):        return x.title()    r = map(toUpper, wlist)    # 将单词拼接为字符串    s = " ".join(r)    return sr = func("a good  fruit apple")print(r)  # " A Good  Fruit Apple"# 提示： 可以考虑 将 字符串按照 单词 切分， map处理之后， 再 重新拼接为字符串</code></pre><h3 id="reduce-func-iterable"><a class="header-anchor" href="#reduce-func-iterable">¶</a><code>reduce(func, iterable)</code></h3><blockquote><p>将可迭代对象中所有的元素，按照第一个 函数的规则， 连续操作，得到一个  <strong>具体的数据</strong></p></blockquote><pre class=" language-language-python"><code class="language-language-python">from functools import reduce# 自定义一个Mysum()函数，接收一个列表作为参数， 返回列表中所有元素之和def mysum(alist):    def add(x, y):        return x + y    r = reduce(add, alist) # reduce 的结果是一个具体的值    return rr = mysum([1, 2, 3, 4, 5])print(r)  # 15</code></pre><h3 id="filter-func-iterable"><a class="header-anchor" href="#filter-func-iterable">¶</a><code>filter(func, iterable)</code></h3><blockquote><p>按照第一个 函数的 <strong>返回值</strong> 对 可迭代对象 中 所有的数据 进行 过滤， 得到一个 包含过滤后结果的 <strong>迭代器对象</strong></p></blockquote><pre class=" language-language-python"><code class="language-language-python"># 自定义一个filterNumber()函数，接收一个列表作为参数， 返回一个 包含偶数 的列表def filterNumber(alist):    def is_even(x):        """如果函数的返回结果为True, 对应的元素可以得到"""        if x % 2 == 0:            return True    r = filter(is_even, alist)  # r也是迭代器对象    return list(r)  # 通过类型转换，将迭代器中数据取出r = filterNumber([1, 2, 3, 4, 5, 6])print(r)  # [2, 4, 6]]</code></pre><pre class=" language-language-python"><code class="language-language-python"># 自定义一个函数 sevenNumber()函数，接收一个列表作为参数， 返回一个 包含 "逢7必过" 数字的新列表def sevenNumber(alist):    def f(x):        # 判断为7的倍数，返回True        if x % 7 == 0 or '7' in str(x):            return True    r = filter(f, alist)  # r是迭代器对象    return list(r)r = sevenNumber(range(1, 101))print(r)</code></pre><h3 id="sorted-iterable-key-func-reverse-False"><a class="header-anchor" href="#sorted-iterable-key-func-reverse-False">¶</a><code>sorted(iterable, key=func, reverse=False)</code></h3><blockquote><p>默认将列表 按照 升序 排序</p></blockquote><pre class=" language-language-python"><code class="language-language-python">alist = [21, 14, -67, -34, 19]# 按照 数字大小 升序 排序r = sorted(alist)print(r)  # [-67, -34, 14, 19, 21]# 按照 数字大小 降序 排序r = sorted(alist, reverse=True)print(r)  # [21, 19, 14, -34, -67]# 按照每 个数字的绝对值 升序 排序r = sorted(alist, key=abs)print(r)  # [14, 19, 21, -34, -67]# 按照 每个数字的绝对值 降序 排序r = sorted(alist, key=abs, reverse=True)print(r)  # [-67, -34, 21, 19, 14]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高阶函数 </tag>
            
            <tag> sorted </tag>
            
            <tag> map </tag>
            
            <tag> reduce </tag>
            
            <tag> filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量进阶</title>
      <link href="/2020/06/06/python-han-shu-bian-liang-jie-xi/"/>
      <url>/2020/06/06/python-han-shu-bian-liang-jie-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="变量的作用域"><a class="header-anchor" href="#变量的作用域">¶</a>变量的作用域</h3><ul><li>在Python程序中创建、改变、查找变量名时，都是在一个保存变量名的空间中进行，我们称之为命名空间，也被称之为作用域。</li></ul><a id="more"></a><ul><li>Python的作用域是静态的，在源代码中变量名被赋值的位置决定了该变量能被访问的范围。即Python变量的作用域由变量所在源代码中的位置决定。</li></ul><h3 id="作用域的产生"><a class="header-anchor" href="#作用域的产生">¶</a>作用域的产生</h3><ul><li><p>只有当变量在<code>Module(模块)</code>、<code>Class(类)</code>、<code>def(函数)</code>中定义的时候，才会有作用域的概念。</p></li><li><p>在作用域中定义的变量，一般只在该作用域中有效。</p></li><li><p>在<code>if-elif-else</code>、<code>for-else</code>、<code>while</code>、<code>try-except/try-finally</code>等关键字的语句块中并不会产生作用域</p></li></ul><h4 id="代码分析1"><a class="header-anchor" href="#代码分析1">¶</a>代码分析1</h4><pre class=" language-language-python"><code class="language-language-python">def func():    variable = 100    print(variable)print(variable)</code></pre><blockquote><p>代码执行到第二个<code>print(variable)</code>时会报错 <code>NameError: name 'variable' is not defined</code></p><p>变量<code>variable</code>只在函数<code>func()</code>的定义域内有效！</p></blockquote><h4 id="代码分析2"><a class="header-anchor" href="#代码分析2">¶</a>代码分析2</h4><pre class=" language-language-python"><code class="language-language-python">if True:    variable = 100    print(variable)print("******")print(variable)</code></pre><p>输出结果为：</p><pre class=" language-language-shell"><code class="language-language-shell">100     ******100</code></pre><p>程序没有报错，因为if语句不产生作用域</p><h3 id="变量作用域的类型"><a class="header-anchor" href="#变量作用域的类型">¶</a>变量作用域的类型</h3><ul><li>L(local)局部作用域<ul><li>√ 函数内的命名空间</li></ul></li><li>E(enclosing)嵌套作用域<ul><li>√ 外部嵌套函数的命名空间</li></ul></li><li>G(global)全局作用域<ul><li>√ 所在模块（文件）的命名空间</li></ul></li><li>B(built-in)内置作用域<ul><li>√ Python内置模块的命名空间</li></ul></li></ul><h4 id="实例解析"><a class="header-anchor" href="#实例解析">¶</a>实例解析</h4><pre class=" language-language-python"><code class="language-language-python">globalVar = 100  # 全局作用域     def test_scope():    enclosingVar = 200  # 嵌套作用域    def func():        localVar = enclosingVar + 1  # 局部作用域        print(localVar)print(__name__)  # 内置作用域</code></pre><h3 id="变量名解析LEGB法则"><a class="header-anchor" href="#变量名解析LEGB法则">¶</a>变量名解析LEGB法则</h3><p>当在函数中使用未确定的变量名时，<code>Python</code>会按照优先级依次搜索4个作用域，以此来确定该变量名的意义。</p><ul><li><p>首先搜索局部作用域(L)，</p></li><li><p>之后是上一层嵌套结构中<code>def</code>或<code>lambda</code>函数的嵌套作用域(E)，</p></li><li><p>之后是全局作用域(G)，</p></li><li><p>最后是内置作用域(B)。</p></li><li><p>按这个查找原则，在第一处找到的地方停止。如果没有找到，则会出发<code>NameError</code>错误。</p></li></ul><h3 id="搜索变量名的优先级："><a class="header-anchor" href="#搜索变量名的优先级：">¶</a>搜索变量名的优先级：</h3><ul><li>局部作用域 &gt; 嵌套作用域 &gt; 全局作用域 &gt; 内置作用域</li></ul><h4 id="实例1"><a class="header-anchor" href="#实例1">¶</a>实例1</h4><pre class=" language-language-python"><code class="language-language-python">def func():    variable = 300    print(variable)  #打印局部作用域的variablevariable = 100func()print(variable) #打印全局作用域的variable</code></pre><p>运行结果：</p><pre class=" language-language-shell"><code class="language-language-shell">300100</code></pre><h4 id="实例2"><a class="header-anchor" href="#实例2">¶</a>实例2</h4><pre class=" language-language-python"><code class="language-language-python">def test_scopt():    variable = 200    print(variable)    def func():        print(variable) #此处打印的是上层嵌套函数    func()              #test_scopt()中的variablevariable = 100test_scopt()print(variable)</code></pre><p>运行结果：</p><pre class=" language-language-shell"><code class="language-language-shell">200200100</code></pre><h4 id="实例3"><a class="header-anchor" href="#实例3">¶</a>实例3</h4><pre class=" language-language-python"><code class="language-language-python">variable = 300def test_scopt():    print(variable) #此处的变量variable绑定的是下一行      variable = 200  #语句中所声明的局部变量，但未被赋值所以报错test_scopt()print(variable)</code></pre><p>运行结果：</p><pre class=" language-language-shell"><code class="language-language-shell">UnboundLocalError: local variable 'variable' referenced before assignment</code></pre><h4 id="实例4"><a class="header-anchor" href="#实例4">¶</a>实例4</h4><pre class=" language-language-python"><code class="language-language-python">variable = 300def test_scopt():    print(variable)  #此处打印的是全局变量variable    #variable = 200  #如果这行未被注释，那么上一句print打印的应是                     #此处定义的局部变量     test_scopt()print(variable)</code></pre><p>运行结果：</p><pre class=" language-language-shell"><code class="language-language-shell">300300</code></pre><p>仔细体会实例4和实例3的区别！</p><h3 id="global与nonlocal关键字"><a class="header-anchor" href="#global与nonlocal关键字">¶</a>global与nonlocal关键字</h3><ul><li><p>global适用于函数内部修改全局变量的值</p></li><li><p>nonlocal适用于嵌套函数中内部函数修改外部变量的值</p></li></ul><h4 id="实例1（global关键字）"><a class="header-anchor" href="#实例1（global关键字）">¶</a>实例1（global关键字）</h4><pre class=" language-language-python"><code class="language-language-python">spam = 99   # <--def tester():    def nested():        global spam   #绑定到了第一行定义的spam        print('current=',spam)        spam = 200    return nestedtester()()print(spam)</code></pre><p>运行结果：</p><pre class=" language-language-shell"><code class="language-language-shell">current= 99200</code></pre><h4 id="实例2（nonlocal关键字）"><a class="header-anchor" href="#实例2（nonlocal关键字）">¶</a>实例2（nonlocal关键字）</h4><pre class=" language-language-python"><code class="language-language-python">def outer():    count = 10 # <--    def inner():        nonlocal count #绑定到了第二行定义的count        count = 20        print(count)    inner()    print(count)outer()</code></pre><p>运行结果：</p><pre class=" language-language-shell"><code class="language-language-shell">2020</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LEGB </tag>
            
            <tag> 引用计数 </tag>
            
            <tag> global </tag>
            
            <tag> nonlocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/2020/05/24/http-xie-yi-zhi-http-zhuang-tai-ma-xiang-jie/"/>
      <url>/2020/05/24/http-xie-yi-zhi-http-zhuang-tai-ma-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-协议之-http-状态码详解"><a class="header-anchor" href="#HTTP-协议之-http-状态码详解">¶</a>HTTP 协议之 http 状态码详解</h2><p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。</p><p>它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。</p><p>HTTP 状态码被分为五大类， 目前我们使用的 HTTP 协议版本是 1.1， 支持以下的状态码。随着协议的发展，HTTP 规范中会定义更多的状态码。</p><h2 id="1xx（临时响应）"><a class="header-anchor" href="#1xx（临时响应）">¶</a>1xx（临时响应）</h2><blockquote><p>表示临时响应并需要请求者继续执行操作的状态代码。</p></blockquote><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">100</td><td style="text-align:center">（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</td></tr></tbody></table><h2 id="2xx-（成功）"><a class="header-anchor" href="#2xx-（成功）">¶</a>2xx （成功）</h2><blockquote><p>表示成功处理了请求的状态代码。</p></blockquote><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">200</td><td style="text-align:left">（成功） 服务器已成功处理了请求，该操作是幂等的（Idempotent）。 通常，这表示服务器提供了请求的网页。</td></tr><tr><td style="text-align:center">201</td><td style="text-align:left">（已创建） 请求成功并且服务器创建了新的资源。</td></tr><tr><td style="text-align:center">202</td><td style="text-align:left">（已接受） 服务器已接受请求，但尚未处理。即请求已经进入后台排队（异步任务）</td></tr><tr><td style="text-align:center">203</td><td style="text-align:left">（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td style="text-align:center">204</td><td style="text-align:left">（无内容） 服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td style="text-align:center">205</td><td style="text-align:left">（重置内容） 服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td style="text-align:center">206</td><td style="text-align:left">（部分内容） 服务器成功处理了部分 GET 请求。</td></tr></tbody></table><h2 id="3xx-（重定向）"><a class="header-anchor" href="#3xx-（重定向）">¶</a>3xx （重定向）</h2><blockquote><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p></blockquote><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">300</td><td style="text-align:left">（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td style="text-align:center">301</td><td style="text-align:left">（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td></tr><tr><td style="text-align:center">302</td><td style="text-align:left">（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td style="text-align:center">303</td><td style="text-align:left">（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td></tr><tr><td style="text-align:center">304</td><td style="text-align:left">（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</td></tr><tr><td style="text-align:center">305</td><td style="text-align:left">（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</td></tr><tr><td style="text-align:center">307</td><td style="text-align:left">（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr></tbody></table><h2 id="4xx（请求错误）"><a class="header-anchor" href="#4xx（请求错误）">¶</a>4xx（请求错误）</h2><blockquote><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p></blockquote><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">400</td><td style="text-align:center">（错误请求） 服务器不理解请求的语法。</td></tr><tr><td style="text-align:center">401</td><td style="text-align:center">（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</td></tr><tr><td style="text-align:center">403</td><td style="text-align:center">（禁止） 服务器拒绝请求。</td></tr><tr><td style="text-align:center">404</td><td style="text-align:center">（未找到） 服务器找不到请求的网页。</td></tr><tr><td style="text-align:center">405</td><td style="text-align:center">（方法禁用） 禁用请求中指定的方法。</td></tr><tr><td style="text-align:center">406</td><td style="text-align:center">（不接受） 无法使用请求的内容特性响应请求的网页。</td></tr><tr><td style="text-align:center">407</td><td style="text-align:center">（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td></tr><tr><td style="text-align:center">408</td><td style="text-align:center">（请求超时） 服务器等候请求时发生超时。</td></tr><tr><td style="text-align:center">409</td><td style="text-align:center">（冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</td></tr><tr><td style="text-align:center">410</td><td style="text-align:center">（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</td></tr><tr><td style="text-align:center">411</td><td style="text-align:center">（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</td></tr><tr><td style="text-align:center">412</td><td style="text-align:center">（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</td></tr><tr><td style="text-align:center">413</td><td style="text-align:center">（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td></tr><tr><td style="text-align:center">414</td><td style="text-align:center">（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</td></tr><tr><td style="text-align:center">415</td><td style="text-align:center">（不支持的媒体类型） 请求的格式不受请求页面的支持。</td></tr><tr><td style="text-align:center">416</td><td style="text-align:center">（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</td></tr><tr><td style="text-align:center">417</td><td style="text-align:center">（未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</td></tr></tbody></table><h2 id="5xx（服务器错误）"><a class="header-anchor" href="#5xx（服务器错误）">¶</a>5xx（服务器错误）</h2><blockquote><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p></blockquote><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">500</td><td style="text-align:center">（服务器内部错误） 服务器遇到错误，无法完成请求。</td></tr><tr><td style="text-align:center">501</td><td style="text-align:center">（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</td></tr><tr><td style="text-align:center">502</td><td style="text-align:center">（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</td></tr><tr><td style="text-align:center">503</td><td style="text-align:center">（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</td></tr><tr><td style="text-align:center">504</td><td style="text-align:center">（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td></tr><tr><td style="text-align:center">505</td><td style="text-align:center">（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态码 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-ORM</title>
      <link href="/2020/05/24/django-orm/"/>
      <url>/2020/05/24/django-orm/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ORM介绍"><a class="header-anchor" href="#一、ORM介绍">¶</a>一、ORM介绍</h2><h3 id="1-什么是-ORM"><a class="header-anchor" href="#1-什么是-ORM">¶</a>1. 什么是 ORM</h3><ul><li><p><strong><code>ORM</code></strong> 全拼<code>Object-Relation Mapping</code></p></li><li><p>中文意为 <strong><code>对象-关系映射</code></strong></p></li><li><p>在<code>MVC</code>/<code>MVT</code>设计模式中的<code>Model</code>模块中都包括<code>ORM</code></p></li></ul><a id="more"></a><h3 id="2-ORM-优势"><a class="header-anchor" href="#2-ORM-优势">¶</a>2.ORM 优势</h3><p>（1）只需要面向对象编程, 不需要面向数据库编写代码.</p><ul><li>对数据库的操作都转化成对类属性和方法的操作.</li><li>不用编写各种数据库的 sql 语句.</li></ul><p>（2）实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异.</p><ul><li>不在关注用的是<code>mysql</code>、<code>oracle</code>… 等.</li><li>通过简单的配置就可以轻松更换数据库, 而不需要修改代码.</li></ul><h3 id="3-ORM-劣势"><a class="header-anchor" href="#3-ORM-劣势">¶</a>3.ORM 劣势</h3><ul><li>相比较直接使用 SQL 语句操作数据库, 有性能损失.</li><li>根据对象的操作转换成 SQL 语句, 根据查询的结果转化成对象, 在映射过程中有性能损失.</li></ul><h3 id="4-ORM-和数据库关系："><a class="header-anchor" href="#4-ORM-和数据库关系：">¶</a>4.ORM 和数据库关系：</h3><p>在 Django 中 model 是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表.</p><p>基本情况：</p><p>每个模型都是一个 Python 类，它是 django.db.models.Model 的子类。</p><p>模型的每个属性都代表一个数据库字段。</p><p>综上所述，Django 为您提供了一个自动生成的数据库访问 API。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/ORM%E7%A4%BA%E6%84%8F%E5%9B%BE%20.png" alt="ORM示意图"></p><h2 id="二、Django配置使用mysql数据库"><a class="header-anchor" href="#二、Django配置使用mysql数据库">¶</a>二、Django配置使用mysql数据库</h2><h3 id="settings-py配置DATABASES"><a class="header-anchor" href="#settings-py配置DATABASES">¶</a><code>settings.py</code>配置<code>DATABASES</code></h3><p>默认:<code>{}</code>(空字典)</p><p>一个字典，包含Django使用的所有数据库的设置。它是一个嵌套的字典，其内容将数据库别名映射到包含单个数据库选项的字典。</p><p>数据库设置必须配置一个默认数据库;还可以指定任意数量的其他数据库。</p><p>最简单的设置文件是针对使用SQLite的单数据库设置的。这可以配置使用以下:</p><pre class=" language-language-python"><code class="language-language-python">DATABASES = {    'default': {        'ENGINE': 'django.db.backends.sqlite3',        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),    }}</code></pre><p>当连接到其他数据库后端(如<code>MySQL</code>、<code>Oracle</code>或<code>PostgreSQL</code>)时，需要额外的连接参数。有关如何指定其他数据库类型，请参阅下面的引擎设置。这个例子是为<code>MySQL</code>:</p><pre class=" language-language-python"><code class="language-language-python">DATABASES = {    'default': {        'ENGINE': 'django.db.backends.mysql',        'NAME': 'django_test',        'USER': 'root',        'PASSWORD': 'mysqlroot',        'HOST': '127.0.0.1',        'PORT': 3306    }}</code></pre><h3 id="MySQL连接工具"><a class="header-anchor" href="#MySQL连接工具">¶</a><code>MySQL</code>连接工具</h3><ol><li><p>需要安装<code>pymysql</code>模块</p><pre class=" language-language-bash"><code class="language-language-bash">pip install pymysql</code></pre></li><li><p>在项目的<code>__init__.py</code>初始化文件,添加如下信息:</p><pre class=" language-language-python"><code class="language-language-python">import pymysqlpymysql.install_as_MySQLdb()</code></pre></li><li><p>在django最新版本中，提示&quot;Django需要mysqlclient 1.3.13或更高版本&quot;。要么在报错时，将抛出版本异常的代码注释掉,仍然使用<code>pymysql</code>；要么直接使用<code>mysqlclient</code>,不建议直接<code>pip</code>命令安装，可以使用<code>conda</code>创建虚拟环境，使用<code>conda</code>安装<code>mysqlclient</code>。</p></li></ol><h2 id="三、字段属性和选项"><a class="header-anchor" href="#三、字段属性和选项">¶</a>三、字段属性和选项</h2><h3 id="1-模型类属性命名限制"><a class="header-anchor" href="#1-模型类属性命名限制">¶</a>1.模型类属性命名限制</h3><ul><li><p>不能是python的保留关键字。</p></li><li><p><strong>不允许使用连续的下划线，这是由django的查询方式决定的。</strong></p></li><li><p>定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：</p><pre class=" language-language-python"><code class="language-language-python">  属性名=models.字段类型(选项)</code></pre></li></ul><h3 id="2-字段类型"><a class="header-anchor" href="#2-字段类型">¶</a>2.字段类型</h3><h4 id="整数"><a class="header-anchor" href="#整数">¶</a>整数</h4><h5 id="AutoField"><a class="header-anchor" href="#AutoField">¶</a><code>AutoField</code></h5><p>根据可用id自动递增的一个32位(<code>4 byte</code>)的整数(<code>Integer</code>)字段,它的适用范围为:<code>1</code>到<code>2147483647</code>之间。</p><p>你通常不需要直接使用它;如果不进行其他指定，主键字段将自动添加到模型中。</p><p>默认情况下， Django 会给每一个模型添加下面的字段：</p><pre class=" language-language-python"><code class="language-language-python">id = models.AutoField(primary_key=True)</code></pre><p>这是一个自增的主键。</p><p>如果你想自己指定主键， 在你想要设置为主键的字段上设置参数 <code>primary_key=True</code>。如果 Django 看到你显式地设置了 <code>Field.primary_key</code>，将不会自动在表（模型）中添加 <code>id</code> 列。</p><p>每个模型都需要拥有一个设置了 <code>primary_key=True</code> 的字段（无论是显式的设置还是 Django 自动设置）</p><h5 id="BigAutoField"><a class="header-anchor" href="#BigAutoField">¶</a><code>BigAutoField</code></h5><p>一个64位(<code>8 byte</code>)的整数，类似于<code>AutoField</code>，除了它的适用范围为:<code>1</code>到<code>9223372036854775807</code>之间。</p><h5 id="IntegerField"><a class="header-anchor" href="#IntegerField">¶</a><code>IntegerField</code></h5><p>一个32位(<code>4 byte</code>)的整数。在Django支持的所有数据库中，<code>-2147483648</code>到<code>2147483647</code>之间的值都是安全的。</p><h5 id="BigIntegerField"><a class="header-anchor" href="#BigIntegerField">¶</a><code>BigIntegerField</code></h5><p>一个64位(<code>8 byte</code>)的整数，类似于<code>IntegerField</code>，除了它保证适合从<code>-9223372036854775808</code>到<code>9223372036854775807</code>的数字。</p><h5 id="SmallIntegerField"><a class="header-anchor" href="#SmallIntegerField">¶</a><code>SmallIntegerField</code></h5><p>一个8位(<code>2 byte</code>)的整数，类似于<code>IntegerField</code>,在Django支持的所有数据库中，<code>-32768</code>到<code>32767</code>之间的值都是安全的。</p><h5 id="PositiveIntegerField"><a class="header-anchor" href="#PositiveIntegerField">¶</a><code>PositiveIntegerField</code></h5><p>一个32位(<code>4 byte</code>)的整数，类似于<code>IntegerField</code>，但必须是正数或零(0)。在Django支持的所有数据库中，<code>0</code>到<code>2147483647</code>之间的值都是安全的。由于向后兼容的原因，接受值<code>0</code>。</p><h5 id="PositiveSmallIntegerField"><a class="header-anchor" href="#PositiveSmallIntegerField">¶</a><code>PositiveSmallIntegerField</code></h5><p>一个8位(<code>2 byte</code>)的整数，类似于<code>PositiveIntegerField</code>，在Django支持的所有数据库中，<code>0</code>到<code>32767</code>之间的值都是安全的</p><h4 id="小数"><a class="header-anchor" href="#小数">¶</a>小数</h4><h5 id="FloatField"><a class="header-anchor" href="#FloatField">¶</a><code>FloatField</code></h5><p>在Python中由 <code>float</code> 实例表示的浮点数。</p><h5 id="DecimalField"><a class="header-anchor" href="#DecimalField">¶</a><code>DecimalField</code></h5><p>一种固定精度的十进制数，在Python中用<code> Decimal</code>实例表示。它使用<code>DecimalValidator</code>验证输入。</p><p>有两个必要的参数:</p><h6 id="DecimalField-max-digits"><a class="header-anchor" href="#DecimalField-max-digits">¶</a><code>DecimalField.max_digits</code></h6><p>数字中允许的最大位数。注意，这个数字必须大于或等于<code>decimal_places</code>。</p><h6 id="DecimalField-decimal-places"><a class="header-anchor" href="#DecimalField-decimal-places">¶</a><code>DecimalField.decimal_places</code></h6><p>要与该数字一起存储的小数位数。</p><p>例如，要存储分辨率为两位小数的999以内的数字，需要使用</p><pre class=" language-language-python"><code class="language-language-python">models.DecimalField(..., max_digits=5, decimal_places=2)</code></pre><blockquote><p><code>FloatField</code> <strong>vs.</strong> <code>DecimalField</code></p><p><code>FloatField</code>类有时会与<code>DecimalField</code>类混在一起。虽然它们都表示实数，但它们表示的是不同的数。<code>FloatField</code>在内部使用Python的<code>float</code>类型，而<code>DecimalField</code>使用Python的<code>Decimal</code>类型。有关两者之间差异的信息，请参阅Python的 <a href="https://docs.python.org/3/library/decimal.html#module-decimal" target="_blank" rel="noopener"><code>decimal</code></a> 模块文档。</p></blockquote><h4 id="布尔"><a class="header-anchor" href="#布尔">¶</a>布尔</h4><h5 id="BooleanField"><a class="header-anchor" href="#BooleanField">¶</a><code>BooleanField</code></h5><p>一个<code>true</code>/<code>false</code>字段。</p><p>当<code>Field.default</code>未定义时，<code>BooleanField</code>的默认值为<code>None</code></p><blockquote><p>Django 2.1:<br>在旧版本中，这个字段不允许<code>null=True</code>，因此必须使用<code>NullBooleanField</code>。现在不建议使用后者，因为在Django的未来版本中可能会弃用它。</p><p>在较早的版本中，该字段隐式地具有<code>blank=True</code>。您可以通过设置blank=True来恢复前面的行为。</p></blockquote><h5 id="NullBooleanField"><a class="header-anchor" href="#NullBooleanField">¶</a><code>NullBooleanField</code></h5><p>类似<code>BooleanField</code>的<code>null=True</code>。使用<code>BooleanField</code>这个字段而不是<code>NullBooleanField</code>这个字段，因为在Django的未来版本中<code>NullBooleanField</code>可能会被弃用</p><h4 id="字符"><a class="header-anchor" href="#字符">¶</a>字符</h4><h5 id="CharField"><a class="header-anchor" href="#CharField">¶</a><code>CharField</code></h5><p>字符串字段，用于小型到大型字符串。<code>CharField</code>有一个额外的必要参数:</p><h6 id="CharField-max-length"><a class="header-anchor" href="#CharField-max-length">¶</a><code>CharField.max_length</code></h6><p>字段的最大长度(以字符为单位)。<code>max_length</code>在数据库标准和Django的验证中使用<code>MaxLengthValidator</code>执行。</p><p>对于大量文本，使用<code>TextField</code>。</p><h5 id="TextField"><a class="header-anchor" href="#TextField">¶</a><code>TextField</code></h5><p>一个大的文本字段。这个字段的默认表单小部件是一个<code>Textarea</code>。</p><p>如果指定max_length属性，它将反映在自动生成表单字段的<code>Textarea</code>小部件中。然而，它并没有在模型或数据库级别强制执行。</p><h5 id="URLField"><a class="header-anchor" href="#URLField">¶</a><code>URLField</code></h5><p>一个有关<code>URL</code>的<code>CharField</code>，由<code>URLValidator</code>验证该值是否为有效的<code>URL</code>地址。</p><p>与所有<code>CharField</code>子类一样，<code>URLField</code>接受可选的<code>max_length</code>参数。如果不指定<code>max_length</code>，则使用默认值200。</p><h5 id="EmailField"><a class="header-anchor" href="#EmailField">¶</a><code>EmailField</code></h5><p>一个有关<code>Email</code>的<code>CharField</code>,由<code>EmailValidator</code>验证该值是否为有效的电子邮件地址。</p><p>与所有<code>CharField</code>子类一样，<code>EmailField</code>接受可选的<code>max_length</code>参数。如果不指定<code>max_length</code>，则使用默认值254。</p><h5 id="UUIDField"><a class="header-anchor" href="#UUIDField">¶</a><code>UUIDField</code></h5><p>用于存储通用唯一标识符的字段。使用Python的<code>UUID</code>类。当在<code>PostgreSQL</code>上使用时，它以<code>uuid</code>数据类型存储，否则以<code>char(32)</code>存储。</p><p>全局惟一标识符是<code>primary_key</code>的<code>AutoField</code>的一个很好的替代方案。数据库不会为你生成<strong>UUID</strong>，建议使用默认:</p><pre class=" language-language-python"><code class="language-language-python">import uuidfrom django.db import modelsclass MyUUIDModel(models.Model):    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)    # other fields</code></pre><blockquote><p>注意，一个回调函数(省略括号)被传递到<code>default</code>，而不是<strong>UUID</strong>的一个实例。</p></blockquote><h4 id="文件"><a class="header-anchor" href="#文件">¶</a>文件</h4><h5 id="FileField"><a class="header-anchor" href="#FileField">¶</a><code>FileField</code></h5><p>一个文件上传字段。有两个可选参数:</p><h6 id="FileField-upload-to"><a class="header-anchor" href="#FileField-upload-to">¶</a><code>FileField.upload_to</code></h6><p>这个属性提供了一种设置上传目录和文件名的方法，可以通过两种方式进行设置。在这两种情况下，值都被传递到<code>Storage.save()</code>方法。</p><p>如果您指定一个字符串值，它可能包含<code>strftime()</code>格式，它将被文件上传的日期/时间所取代(这样上传的文件就不会填满给定的目录)。例如:</p><pre class=" language-language-python"><code class="language-language-python">class MyModel(models.Model):    # 文件将被上传至 MEDIA_ROOT/uploads    upload = models.FileField(upload_to='uploads/')    # or...    # 文件将被上传至 MEDIA_ROOT/uploads/2015/01/30    upload = models.FileField(upload_to='uploads/%Y/%m/%d/')</code></pre><p>如果使用默认的<code>FileSystemStorage</code>，字符串值将追加到<code>MEDIA_ROOT</code>路径，以形成本地文件系统上的位置，上传的文件将存储在此位置。如果使用不同的存储，请检查该存储的文档，以了解它如何处理<code>upload_to</code>。</p><p><code>upload_to</code>也可以是一个可调用的函数。这个函数将被调用以获得上传路径，包括文件名。这个可调用函数必须接受两个参数，并返回一个<code>unix</code>风格的路径(带有斜杠)，以便传递给存储系统。这两个参数是:</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>instance</code></td><td>定义FileField的模型的一个实例。更具体地说，这是附加当前文件的特定实例。<br/>在大多数情况下，这个对象还没有保存到数据库中，所以如果它使用默认的<code>AutoField</code>，那么它的主键字段可能还没有值。</td></tr><tr><td><code>filename</code></td><td>原给定给该文件的文件名。在确定最终目的地路径时，可能会考虑这一点，也可能不考虑这一点。</td></tr></tbody></table><p>例子:</p><pre class=" language-language-python"><code class="language-language-python">def user_directory_path(instance, filename):    # file will be uploaded to MEDIA_ROOT/user_<id>/<filename>    return 'user_{0}/{1}'.format(instance.user.id, filename)class MyModel(models.Model):    upload = models.FileField(upload_to=user_directory_path)</code></pre><h6 id="FileField-storage"><a class="header-anchor" href="#FileField-storage">¶</a><code>FileField.storage</code></h6><p>一个存储对象，它处理文件的存储和检索。有关如何提供此对象的详细信息，请参见 <a href="https://docs.djangoproject.com/en/2.2/topics/files/" target="_blank" rel="noopener">管理文件</a> 。</p><p>在模型中使用<code>FileField</code>或<code>ImageField</code>需要几个步骤:</p><ol><li>在设置文件中，需要将<code>MEDIA_ROOT</code>定义为一个目录的完整路径，您希望<code>Django</code>在这个目录中存储上传的文件。(为了提高性能，这些文件不存储在数据库中。)将<code>MEDIA_URL</code>定义为该目录的基本公共<code>URL</code>。确保此目录可由<code>Web</code>服务器的用户帐户写入。</li><li>将<code>FileField</code>或<code>ImageField</code>添加到模型中，定义<code>upload_to</code>选项，以指定<code>MEDIA_ROOT</code>的子目录，用于上传文件。</li><li>所有将存储在数据库中的内容都是文件的路径(相对于<code>MEDIA_ROOT</code>)。您很可能希望使用Django提供的便利url属性。例如，如果 <code>ImageField</code>被称为 <code>mug_shot</code> ，可以获取模板中图像的绝对路径 <code></code></li></ol><p>例如，假设<code>MEDIA_ROOT</code>设置为<code>'/home/media'</code>， <code>upload_to</code>设置为<code>'photos/%Y/%m/%d'</code>。<code>upload_to</code>的<code>'%Y/%m/%d'</code>部分是<code>strftime()</code>格式;<code>'%Y'</code>是四位数的年份，<code>'%m'是</code>两位数的月份，<code>'%d'</code>是两位数的日期。如果你在2007年1月15日上传了一个文件，它将被保存在<code>/home/media/photos/2007/01/15</code>目录下。</p><p>如果要检索上传文件的磁盘上文件名或文件大小，可以分别使用<a href="https://docs.djangoproject.com/en/2.2/ref/files/file/#django.core.files.File.name" target="_blank" rel="noopener"><code>名称</code></a> 和<a href="https://docs.djangoproject.com/en/2.2/ref/files/file/#django.core.files.File.size" target="_blank" rel="noopener"><code>大小</code></a> 属性;有关可用属性和方法的更多信息，请参见 <a href="https://docs.djangoproject.com/en/2.2/ref/files/file/#django.core.files.File" target="_blank" rel="noopener"><code>文件</code></a>类引用和 <a href="https://docs.djangoproject.com/en/2.2/topics/files/" target="_blank" rel="noopener">管理文件</a>主题指南。</p><blockquote><p>文件作为模型保存在数据库中的一部分保存，因此在保存模型之前，不能依赖于磁盘上使用的实际文件名。</p></blockquote><p>请注意，无论何时处理上传的文件，都应该密切注意上传文件的位置和文件类型，以避免安全漏洞。验证所有上传的文件，以确保这些文件是您所认为的。例如，如果您盲目地让某人在未经验证的情况下将文件上传到Web服务器的文档根目录中，那么某人就可以上传一个<strong>CGI</strong>或<strong>PHP</strong>脚本，并通过访问该脚本在您的站点上的<strong>URL</strong>来执行该脚本。不要允许这样的操作。</p><p>还要注意，即使是上传的<strong>HTML</strong>文件，由于它可以由浏览器执行(但不能由服务器执行)，也会造成相当于<strong>XSS</strong>或请注意，无论何时处理上传的文件，都应该密切注意上传文件的位置和文件类型，以避免安全漏洞。验证所有上传的文件，以确保这些文件是您所认为的。例如，如果您盲目地让某人在未经验证的情况下将文件上传到Web服务器的文档根目录中，那么某人就可以上传到<strong>CGI</strong>或<strong>PHP</strong>脚本，并通过访问该脚本在您的站点上的URL来执行该脚本。不要允许这样的操作。</p><p>还要注意，即使是上传的HTML文件，由于它可以由浏览器执行(但不能由服务器执行)，也会造成相当于<strong>XSS</strong>或<strong>CSRF</strong>攻击的安全威胁。攻击的安全威胁。</p><blockquote><p><code>FileField</code>实例在数据库中创建为<code>varchar</code>列，默认最大长度为100个字符。与其他字段一样，可以使用<code>max_length</code>参数更改最大长度。</p></blockquote><h5 id="ImageField"><a class="header-anchor" href="#ImageField">¶</a><code>ImageField</code></h5><p>从<code>FileField</code>继承所有属性和方法，但也验证上传的对象是有效的图像。</p><p>除了可用于<code>FileField</code>的特殊属性之外，<code>ImageField</code>还具有高度和宽度属性。</p><p>为了方便查询这些属性，<code>ImageField</code>有两个额外的可选参数:</p><h6 id="ImageField-height-field"><a class="header-anchor" href="#ImageField-height-field">¶</a><code>ImageField.height_field</code></h6><p>一个模型字段的名称，该字段将在每次保存模型实例时自动填充映像的高度。</p><h6 id="ImageField-width-field"><a class="header-anchor" href="#ImageField-width-field">¶</a><code>ImageField.width_field</code></h6><p>一个模型字段的名称，该字段将在每次保存模型实例时自动填充图像的宽度。</p><p>需要 <a href="https://pillow.readthedocs.io/en/latest/" target="_blank" rel="noopener">Pillow</a> 库。</p><blockquote><p><code>ImageField</code>实例在数据库中创建为<code>varchar</code>列，默认最大长度为100个字符。与其他字段一样，可以使用<code>max_length</code>参数更改最大长度。</p></blockquote><h5 id="FilePathField"><a class="header-anchor" href="#FilePathField">¶</a><code>FilePathField</code></h5><p>一个<code>CharField</code>，它的选择仅限于文件系统上某个目录中的文件名。有三个特殊的参数，其中第一个是必需的:</p><h6 id="FilePathField-path"><a class="header-anchor" href="#FilePathField-path">¶</a><code>FilePathField.path</code></h6><p>必需的。这个<code>FilePathField</code>应该从中获得其选择的目录的绝对文件系统路径。例如:<code>&quot;/ home /images&quot;</code>。</p><h6 id="FilePathField-match"><a class="header-anchor" href="#FilePathField-match">¶</a><code>FilePathField.match</code></h6><p>可选的。一个正则表达式，作为一个字符串，<code>FilePathField</code>将使用它来过滤文件名。注意，正则表达式将应用于基本文件名，而不是完整路径。示例:<strong><code>foo.*\.txt$</code></strong>。它将匹配一个名为<code>foo23.txt</code>的文件，但不匹配<code>bar.txt</code>或<code>foo23.png</code>。</p><h6 id="FilePathField-recursive"><a class="header-anchor" href="#FilePathField-recursive">¶</a><code>FilePathField.recursive</code></h6><p>可选的。非真即假。默认是假的。指定是否应该包括<code>path</code>的所有子目录</p><h6 id="FilePathField-allow-files"><a class="header-anchor" href="#FilePathField-allow-files">¶</a><code>FilePathField.allow_files</code></h6><p>可选的。非真即假。默认是正确的。指定是否应包括位于指定位置的文件。这个或<code>allow_folders</code>必须为真。</p><h6 id="FilePathField-allow-folders"><a class="header-anchor" href="#FilePathField-allow-folders">¶</a><code>FilePathField.allow_folders</code></h6><p>可选的。非真即假。默认是假的。指定是否应包括指定位置的文件夹。这个或allow_files必须为真。</p><p>当然，这些参数可以一起使用。</p><p>一个潜在的问题是，match应用于基本文件名，而不是完整路径。所以,这个例子:</p><pre class=" language-language-python"><code class="language-language-python">FilePathField(path="/home/images", match="foo.*", recursive=True)</code></pre><p>将匹配<code>/home/images/foo.png</code>，但不匹配<code>/home/images/foo/bar.png</code>，因为匹配应用于基本文件名(<code>foo.png</code>和<code>bar.png</code>)。</p><blockquote><p><code>FilePathField</code>实例在数据库中创建为<code>varchar</code>列，默认最大长度为100个字符。与其他字段一样，可以使用<code>max_length</code>参数更改最大长度。</p></blockquote><h5 id="BinaryField"><a class="header-anchor" href="#BinaryField">¶</a><code>BinaryField</code></h5><p>存储原始二进制数据的字段。可以为它分配字节、字节数组或内存视图。</p><p>默认情况下，<code>BinaryField</code>将<code>editable</code>设置为<code>False</code>，在这种情况下，它不能包含在ModelForm中。</p><p><code>BinaryField</code>有一个额外的可选参数:</p><h6 id="BinaryField-max-length"><a class="header-anchor" href="#BinaryField-max-length">¶</a><code>BinaryField.max_length</code></h6><p>字段的最大长度(以字符为单位)。最大长度在Django的验证中使用MaxLengthValidator实现。</p><blockquote><p>Django 2.1:<br>旧版本不允许将editable设置为True。</p></blockquote><h4 id="时间"><a class="header-anchor" href="#时间">¶</a>时间</h4><h5 id="DateField"><a class="header-anchor" href="#DateField">¶</a><code>DateField</code></h5><p>日期，在Python中用<code>datetime.date</code>实例表示。有一些额外的，可选的参数:</p><h6 id="DateField-auto-now"><a class="header-anchor" href="#DateField-auto-now">¶</a><code>DateField.auto_now</code></h6><p>每次保存对象时自动将字段值设置为当前时间，用于“最后修改”时间戳。</p><p>该字段只在调用<code>Model.save()</code>时自动更新。当以其他方式(如<code>QuerySet.update()</code>)更新其他字段时，该字段不会更新，不过可以在这样的更新中为该字段指定自定义值。</p><h6 id="DateField-auto-now-add"><a class="header-anchor" href="#DateField-auto-now-add">¶</a><code>DateField.auto_now_add</code></h6><p>在第一次创建对象时自动将字段设置为当前时间。用于创建时间戳。</p><p>即使在创建对象时为这个字段设置了值，它也会被忽略。如果您希望能够修改该字段，请将<code>auto_now_add=True</code>设置为以下内容:</p><ul><li>For <code>DateField</code>: <code>default=date.today</code> - from <code>datetime.date.today()</code></li><li>For <code>DateTimeField</code>: <code>default=timezone.now</code> - from <code>django.utils.timezone.now()</code></li></ul><p><code>auto_now_add</code>、<code>auto_now</code>和<code>default</code>选项是互斥的。这些选项的任何组合都将导致错误。</p><h5 id="DateTimeField"><a class="header-anchor" href="#DateTimeField">¶</a><code>DateTimeField</code></h5><p>日期和时间，在Python中用<code>datetime.datetime</code>实例表示。接受与<code>DateField</code>相同的额外参数。</p><h5 id="TimeField"><a class="header-anchor" href="#TimeField">¶</a><code>TimeField</code></h5><p>时间，在Python中用<code>datetime.time</code>实例表示。接受与<code>DateField</code>相同的额外参数。</p><h3 id="3-字段选项"><a class="header-anchor" href="#3-字段选项">¶</a>3.字段选项</h3><blockquote><p>以下参数对所有字段类型均有效，且是可选的。</p></blockquote><h4 id="null"><a class="header-anchor" href="#null">¶</a><code>null</code></h4><p>如果设置为 <code>True</code>， 当该字段为空时，Django 会将数据库中该字段设置为 <code>NULL</code>，默认为 <code>False</code>。</p><p>避免在基于字符串的字段（例如 <code>CharField</code>和 <code>TextField</code>）上使用 <code>null</code>。如果字符串字段的 <code>null=True</code>，那意味着对于“无数据”有两个可能的值：<code>NULL</code> 和空字符串。在大多数情况下，对于“无数据”声明两个值是赘余的，Django 的惯例是使用空字符串而不是 <code>NULL</code>。 一个例外是当 <code>CharField</code>同时具有 <code>unique=True</code> 和 <code>blank=True</code> 时。 在这种情况下，需要设置 <code>null=True</code>，以便在使用空白值保存多个对象时避免唯一的约束违规。</p><p>对于基于字符串和非基于字符串的字段，如果希望在表单中允许空值，还需要设置<code>blank=True</code>，因为<code>null</code>参数只影响数据库存储(参见<code>blank</code>)。</p><h4 id="blank"><a class="header-anchor" href="#blank">¶</a><code>blank</code></h4><p>如果设置为 <code>True</code> ，该字段允许为空。默认为 <code>False</code> 。</p><p>注意，这与<code>null</code>不同。<code>null</code>纯粹是与数据库相关的，而<code>blank</code>则是与验证相关的。如果字段为<code>blank=True</code>，表单验证将允许输入空值。</p><blockquote><p>blank和null的用法区别</p></blockquote><ul><li><p>null纯粹是与数据库相关的，而blank则是与表单验证相关的。</p></li><li><p>避免在基于字符串的字段（例如 <code>CharField</code>和 <code>TextField</code>）上使用 <code>null</code>。如果字符串字段的 <code>null=True</code>，那意味着对于“无数据”有两个可能的值：<code>NULL</code> 和<code>空字符串</code>。在大多数情况下，对于“无数据”声明两个值是赘余的，Django 的惯例是使用空字符串而不是 <code>NULL</code>。 一个例外是当 <code>CharField</code>同时具有 <code>unique=True</code> 和 <code>blank=True</code> 时。 在这种情况下，需要设置 <code>null=True</code>，以便在使用空白值保存多个对象时避免唯一的约束违规。</p></li><li><p>当存在两个参数时，总共会有四种设定组合</p><ul><li><code>blank=True</code>、<code>null=True</code>。统一的表明了该字段（列）是可以为空的。</li><li><code>blank=False</code>、<code>null=False</code>。统一的表面了该字段（列）不可以为空。</li><li><code>blank=True</code>、<code>null=False</code>。这个设定的意义在于，某些字段并不希望用户在表单中创建，而是通过在<code>save</code>方法中根据其他字段生成。</li><li><code>blank=False</code>、<code>null=True</code>。这个设定不允许表单中该字段为空，但是允许在更新时或者通过shell等非表单方式插入数据该字段为空。</li></ul></li></ul><blockquote><p>只设定了<code>blank=True</code>而没有设定<code>null=True</code>的时候，通过<code>Admin</code>站点表单创建模型实例并且表单在该字段上没有值时数据库不报错呢？？？</p></blockquote><ul><li>当没有设定<code>null=True</code>时，该列在数据库中就存在<code>NOT NULL</code>的约束，如果插入数据时这一列没有值，按理说数据库应该会报错才对</li><li>出现这种情况的原因在于，<code>django</code>在处理某些在数据库中实际的存储值为字符串的<code>Field</code>时（如<code>CharField</code>, <code>TextField</code>, <code>ImageField</code>（图片文件的路径）），永远不会向数据库中填入空值。如果表单中某个<code>CharField</code>或者<code>TextField</code>字段为空，那么<code>django</code>会在数据库中填入<code>&quot;&quot;</code>，而不是<code>null</code>.</li></ul><h4 id="choices"><a class="header-anchor" href="#choices">¶</a><code>choices</code></h4><p>一个序列，它由两个元素(例如[(A, B)， (A, B)…])的迭代组成，作为这个字段的选择。如果提供了选择，则通过模型验证强制执行，默认的表单小部件将是一个包含这些选择的选择框，而不是标准的文本字段。</p><p>每个元组中的第一个元素是要在模型上设置的实际值，第二个元素是人类可读的名称。例如:</p><pre class=" language-language-python"><code class="language-language-python">YEAR_IN_SCHOOL_CHOICES = [    ('FR', 'Freshman'),    ('SO', 'Sophomore'),    ('JR', 'Junior'),    ('SR', 'Senior'),]</code></pre><p>通常，最好在模型类中定义选项，并为每个值定义一个适当命名的常量:</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsclass Student(models.Model):    FRESHMAN = 'FR'    SOPHOMORE = 'SO'    JUNIOR = 'JR'    SENIOR = 'SR'    YEAR_IN_SCHOOL_CHOICES = [        (FRESHMAN, 'Freshman'),        (SOPHOMORE, 'Sophomore'),        (JUNIOR, 'Junior'),        (SENIOR, 'Senior'),    ]    year_in_school = models.CharField(        max_length=2,        choices=YEAR_IN_SCHOOL_CHOICES,        default=FRESHMAN,    )    def is_upperclass(self):        return self.year_in_school in (self.JUNIOR, self.SENIOR)</code></pre><p>虽然您可以在模型类的外部定义一个选择列表，然后引用它，但是在模型类内部定义每个选择的选择和名称，可以将所有信息与使用它的类一起保存，并使选择易于引用(例如：<strong>Student.SOPHOMORE</strong> 可以在导入<strong>Student</strong>模型类的任何地方使用)。</p><p>您还可以将可用的选项收集到指定的组中，这些组可用于组织目的:</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsclass Media(models.Model):    MEDIA_CHOICES = [        ('Audio', (            ('vinyl', 'Vinyl'),            ('cd', 'CD'),        )         ),        ('Video', (            ('vhs', 'VHS Tape'),            ('dvd', 'DVD'),        )         ),        ('unknown', 'Unknown'),    ]    media = models.CharField(        max_length=10,        choices=MEDIA_CHOICES,        default='cd'    )</code></pre><p>每个元组中的第一个元素是应用于组的名称。第二个元素是二元组的迭代，每个二元组包含一个值和一个可读的选项名。分组选项可以与单个列表中的未分组选项组合在一起(例如本例中的未知选项)。</p><p>注意，选择可以是任何序列对象–不一定是列表或元组。这允许您动态地构造选择。但是，如果您发现自己的选择是动态的，那么最好使用一个带有 <code>ForeignKey</code>的数据库表。但是静态数据不会有太大的变化。</p><p>对于每个设置了选项的字段，对象都有一个<code>get_FOO_display()</code>方法，其中<code>FOO</code>是字段的名称。该方法返回字段的&quot;人易读&quot;值。</p><p>例子:</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsclass Person(models.Model):    SHIRT_SIZES = (        ('S', 'Small'),        ('M', 'Medium'),        ('L', 'Large'),    )    name = models.CharField(max_length=60)    shirt_size = models.CharField(max_length=2, choices=SHIRT_SIZES)</code></pre><pre class=" language-language-bash"><code class="language-language-bash">>>> p = Person(name="Fred Flintstone", shirt_size="L")>>> p.save()>>> p.shirt_size'L'>>> p.get_shirt_size_display()'Large'</code></pre><h4 id="db-column"><a class="header-anchor" href="#db-column">¶</a><code>db_column</code></h4><p>要用于此字段的数据库列的名称。如果没有给出，Django将使用字段的名称。</p><h4 id="db-index"><a class="header-anchor" href="#db-index">¶</a><code>db_index</code></h4><p>如果为真，将为此字段创建一个数据库索引。</p><h4 id="default"><a class="header-anchor" href="#default">¶</a><code>default</code></h4><p>该字段的默认值。可以是一个值或者是个可调用的对象，如果是个可调用对象，每次实例化模型时都会调用该对象。</p><p>默认值不能是一个可变的对象(模型实例、列表、集合等)，因为对该对象的同一个实例的引用将被用作所有模型实例的默认值。反而，可以在回调函数中打包处理所需的默认值。例如，如果要为<code>JSONField</code>指定默认<code>dict</code>，可以使用一个函数:</p><pre class=" language-language-python"><code class="language-language-python">def contact_default():    return {"email": "to1@example.com"}contact_info = JSONField("ContactInfo", default=contact_default)</code></pre><p><strong>lambda</strong>表达式不能用于像<strong>default</strong>这样的字段选项，因为它们不能被迁移序列化。</p><p>对于像映射模型实例的<code>ForeignKey</code>这样的字段，默认值应该是它们引用的字段的值(<code>pk</code>，除非设置<code>to_field</code>)，而不是模型实例。</p><p>当创建新的模型实例并且没有为字段提供值时，将使用默认值。当字段是主键时，当字段设置为<code>None</code>时也会使用默认值。</p><h4 id="help-text"><a class="header-anchor" href="#help-text">¶</a><code>help_text</code></h4><p>额外的“帮助”文本，随表单控件一同显示。即便你的字段未用于表单，它对于生成文档也是很有用的。</p><p>注意，这个值不会在自动生成的表单中进行<code>html</code>转义的。如果您愿意，可以在<code>help_text</code>中包含<strong>HTML</strong>。例如:</p><pre class=" language-language-python"><code class="language-language-python">help_text="Please use the following format: <em>YYYY-MM-DD</em>."</code></pre><p>或者，您可以使用纯文本和<code>django.utils.html.escape()</code>来转义任何<strong>HTML</strong>特殊字符。确保转义任何来自不可信用户的帮助文本，以避免跨站点脚本攻击。</p><h4 id="primary-key"><a class="header-anchor" href="#primary-key">¶</a><code>primary_key</code></h4><p>如果设置为 <code>True</code> ，将该字段设置为该模型的主键。</p><p>如果您没有为模型中的任何字段指定<code>primary_key=True</code>, <strong>Django</strong>将自动添加一个<code>AutoField</code>来保存主键，所以您不需要在任何字段上设置<code>primary_key=True</code>，除非您想覆盖默认的主键行为。</p><p><code>primary_key=True</code>意味着<code>null=False</code>和<code>unique=True</code>。对象上只允许有一个主键。</p><p>主键字段是只读的。如果更改现有对象上的主键值并保存它，则将在旧对象旁边创建一个新对象。</p><h4 id="unique"><a class="header-anchor" href="#unique">¶</a><code>unique</code></h4><p>如果设置为 <code>True</code>，这个字段必须在整个表中保持值唯一。</p><p>这是在数据库级和通过模型验证实现的。如果试图在惟一字段中保存具有重复值的模型，则模型的<code>save()</code>方法会产生一个<code>django.db.IntegrityError</code>。</p><p>这个选项对除了<code>ManyToManyField</code>和<code>OneToOneField</code>以外的所有字段类型都有效。</p><p>注意，当<code>unique</code>为真时，不需要指定<code>db_index</code>，因为<code>unique</code>意味着创建索引。</p><h4 id="verbose-name"><a class="header-anchor" href="#verbose-name">¶</a><code>verbose_name</code></h4><p>字段的可读名称。如果没有给出详细的名称，Django将使用字段的属性名自动创建它，将下划线转换为空格。</p><p>除了 <code>ForeignKey</code>， <code>ManyToManyField</code> 和 <code>OneToOneField</code>，任何字段类型都接收一个可选位置的参数 <code>verbose_name</code>，如果未指定该参数值， Django 会自动使用字段的属性名作为该参数值，并且把下划线转换为空格。</p><p>在该例中：备注名为 <code>&quot;person's first name&quot;</code>:</p><pre class=" language-language-python"><code class="language-language-python">first_name = models.CharField("person's first name", max_length=30)</code></pre><p>在该例中：备注名为 <code>&quot;first name&quot;</code>:</p><pre class=" language-language-python"><code class="language-language-python">first_name = models.CharField(max_length=30)</code></pre><p><code>ForeignKey</code>， <code>ManyToManyField</code> 和 <code>OneToOneField</code>接收的第一个参数为模型的类名，后面可以添加一个 <code>verbose_name</code>参数：</p><pre class=" language-language-python"><code class="language-language-python">poll = models.ForeignKey(    Poll,    on_delete=models.CASCADE,    verbose_name="the related poll",)sites = models.ManyToManyField(Site, verbose_name="list of sites")place = models.OneToOneField(    Place,    on_delete=models.CASCADE,    verbose_name="related place",)</code></pre><p>惯例是不将<code>verbose_name</code> 的首字母大写，必要时 <strong>Djanog</strong> 会自动把首字母转换为大写。</p><h4 id="validators"><a class="header-anchor" href="#validators">¶</a><code>validators</code></h4><p>要为此字段运行的验证器列表。</p><h5 id="编写验证器"><a class="header-anchor" href="#编写验证器">¶</a>编写验证器</h5><p><code>validator</code>是一个可调用的函数，它接受一个值，如果它不满足某些条件，就会引发<code>ValidationError</code>。验证器对于在不同类型的字段之间重用验证逻辑非常有用。</p><p>例如，这里有一个验证器，它只允许偶数:</p><pre class=" language-language-python"><code class="language-language-python">from django.core.exceptions import ValidationErrorfrom django.utils.translation import gettext_lazy as _def validate_even(value):    if value % 2 != 0:        raise ValidationError(            _('%(value)s is not an even number'),            params={'value': value},        )</code></pre><p>您可以通过字段的<code>validators</code>参数将其添加到模型字段:</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsclass MyModel(models.Model):    even_field = models.IntegerField(validators=[validate_even])</code></pre><p>因为值在运行验证器之前就转换成了Python，你甚至可以对表单使用相同的验证器:</p><pre class=" language-language-python"><code class="language-language-python">from django import formsclass MyForm(forms.Form):    even_field = forms.IntegerField(validators=[validate_even])</code></pre><p>对于更复杂或可配置的验证器，您还可以使用带有<code>__call__()</code>方法的类。例如， <code>RegexValidator</code>这类验证器。如果在<code>validators</code> <code>model</code>字段选项中使用基于类的验证器,应该添加<code>deconstruct()</code>装饰器和 <code>__eq__()</code> 方法让它可以被迁移框架序列化。</p><p><a href="https://docs.djangoproject.com/zh-hans/2.2/ref/validators/#built-in-validators" target="_blank" rel="noopener"><code>django.core.validators</code></a>模块包含一组可调用的验证器，用于模型和表单字段，可以在内部使用它们。</p><h3 id="4-Meta-选项"><a class="header-anchor" href="#4-Meta-选项">¶</a>4. <code>Meta</code> 选项</h3><p>使用内部 <code>Meta类</code> 来给模型赋予元数据，就像：</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsclass Ox(models.Model):    horn_length = models.IntegerField()    class Meta:        ordering = ["horn_length"]        verbose_name_plural = "oxen"</code></pre><h4 id="abstract"><a class="header-anchor" href="#abstract">¶</a><code>abstract</code></h4><p>抽象基类在你要将公共信息放入很多模型时会很有用。编写你的基类，并在 <strong>Meta</strong> 类中填入 <code>abstract=True</code>。该模型将不会创建任何数据表。当其用作其它模型类的基类时，它的字段会自动添加至子类。</p><p>一个例子:</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsclass CommonInfo(models.Model):    name = models.CharField(max_length=100)    age = models.PositiveIntegerField()    class Meta:        abstract = Trueclass Student(CommonInfo):    home_group = models.CharField(max_length=5)</code></pre><p><code>Student</code> 模型拥有3个字段： <code>name</code>， <code>age</code> 和 <code>home_group</code>。 <code>CommonInfo</code> 模型不能用作普通的 Django 模型，因为它是一个抽象基类。它不会生成数据表，也没有管理器，也不能被实例化和保存。</p><p>从抽象基类继承来的字段可被其它字段或值重写，或用 <code>None</code> 删除。</p><p>对很多用户来说，这种继承可能就是你想要的。它提供了一种在 Python 级抽出公共信息的方法，但仍会在子类模型中创建数据表。</p><h4 id="app-label"><a class="header-anchor" href="#app-label">¶</a><code>app_label</code></h4><p>如果一个模型是在<code>INSTALLED_APPS</code>中注册的<strong>APP</strong>外部定义的，它必须声明它属于哪个应用程序:</p><pre class=" language-language-python"><code class="language-language-python">app_label = 'myapp'</code></pre><h4 id="db-table"><a class="header-anchor" href="#db-table">¶</a><code>db_table</code></h4><p>要用于模型的数据库表的名称:</p><pre class=" language-language-python"><code class="language-language-python">db_table = 'music_album'</code></pre><p>为了节省时间，Django自动从模型类和包含它的应用程序的名称派生数据库表的名称。模型的数据库表名是通过将模型的**“app label”**(您在<code>manage.py startapp</code>中使用的名称)与模型的类名连接在一起，并在它们之间加一个下划线来构造的。</p><p>例如，如果您有一个应用<strong>bookstore</strong>(由 <code>manage.py startapp bookstore</code>创建)，定义为<strong>Book</strong>的模型类将有一个名为<code>bookstore_book</code>的数据库表。</p><p>要覆盖数据库表名，请使用类元中的db_table参数。</p><blockquote><p>强烈建议在通过db_table覆盖表名时使用小写的表名，特别是在使用MySQL后端时。</p></blockquote><h4 id="ordering"><a class="header-anchor" href="#ordering">¶</a><code>ordering</code></h4><p>对象的默认顺序，用于获取对象列表:</p><pre class=" language-language-python"><code class="language-language-python">ordering = ['-order_date']</code></pre><p>这是一个 包含由字符串和/或构成的查询表达式的元组或列表。每个字符串都是一个带有可选<code>&quot;-&quot;</code>前缀的字段名，表示按降序排列。没有前缀<code>&quot;-&quot;</code>的字段将按升序排列。使用字符串<code>&quot;?&quot;</code>随机排序。</p><p>例如，要按<code>pub_date</code>字段升序排序，可以使用以下命令:</p><pre class=" language-language-python"><code class="language-language-python">ordering = ['pub_date']</code></pre><p>要按pub_date降序排列，请使用以下命令:</p><pre class=" language-language-python"><code class="language-language-python">ordering = ['-pub_date']</code></pre><p>按pub_date降序排列，然后按author升序排列，使用以下命令:</p><pre class=" language-language-python"><code class="language-language-python">ordering = ['-pub_date', 'author']</code></pre><p>您还可以使用查询表达式。要按作者升序排序并使空值排序持续，请使用以下命令:</p><pre class=" language-language-python"><code class="language-language-python">from django.db.models import Fordering = [F('author').asc(nulls_last=True)]</code></pre><h4 id="permissions"><a class="header-anchor" href="#permissions">¶</a><code>permissions</code></h4><p>创建此对象时进入权限表的额外权限。为每个模型自动创建添加、更改、删除和视图权限。这个例子指定了一个额外的权限<code>can_deliver_pizzas</code>:</p><pre class=" language-language-python"><code class="language-language-python">permissions = [('can_deliver_pizzas', 'Can deliver pizzas')]</code></pre><p>这是一个格式为**(permission_code,** **human_readable_permission_name)**的二元列表或元组。</p><h4 id="indexes"><a class="header-anchor" href="#indexes">¶</a><code>indexes</code></h4><p>要在模型上定义的索引列表:</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsclass Customer(models.Model):    first_name = models.CharField(max_length=100)    last_name = models.CharField(max_length=100)    class Meta:        indexes = [            models.Index(fields=['last_name', 'first_name']),            models.Index(fields=['first_name'], name='first_name_idx'),        ]</code></pre><h4 id="verbose-name-v2"><a class="header-anchor" href="#verbose-name-v2">¶</a><code>verbose_name</code></h4><p>模型对象的人类可读的单数名称:</p><pre class=" language-language-python"><code class="language-language-python">verbose_name = "pizza"</code></pre><p>如果没有给出这个值，Django将使用类名的一个简化版本:<code>CamelCase</code>变成<code>camel case</code>。</p><h4 id="verbose-name-plural"><a class="header-anchor" href="#verbose-name-plural">¶</a><code>verbose_name_plural</code></h4><p>对象的复数名称:</p><pre class=" language-language-python"><code class="language-language-python">verbose_name_plural = "stories"</code></pre><p>如果没有给出，Django将使用 <code>verbose_name</code>+ <code>&quot;s&quot;</code></p><h3 id="5-关联关系"><a class="header-anchor" href="#5-关联关系">¶</a>5.关联关系</h3><p>显然，关系型数据库的强大之处在于各表之间的关联关系。 Django 提供了定义三种最常见的数据库关联关系的方法：多对一，多对多，一对一。</p><h4 id="1、多对一关联"><a class="header-anchor" href="#1、多对一关联">¶</a>1、多对一关联</h4><p>定义一个多对一的关联关系，使用 <code>django.db.models.ForeignKey</code> 类。就和其它 <code>Field</code>字段类型一样，只需要在你模型中添加一个值为该类的属性。</p><p><code>ForeignKey</code> 类需要添加一个位置参数，即你想要关联的模型类名。</p><pre class=" language-language-python"><code class="language-language-python"># 关键字ForeignKeypublish = models.ForeignKey(to='Publish')  # to用来指代跟哪张表有关系 默认关联的就是表的主键字段# 外键字段名在创建时会自动加上_id后缀</code></pre><h5 id="字段参数"><a class="header-anchor" href="#字段参数">¶</a>字段参数</h5><ol><li><p><code>to</code>:设置要关联的表</p></li><li><p><code>to_field</code>:设置要关联的表的字段(一般不设置，默认使用主键id关联)</p></li><li><p><code>related_name</code>:反向操作时，使用的字段名，用于代替原反向查询时的’表名_set’</p></li><li><p><code>related_query_name</code>:反向查询操作时，使用的连接前缀，用于替换表名</p></li><li><p><code>db_constraint</code>:是否在数据库中创建外键约束，默认为True。</p></li><li><p><code>on_delete</code>:当删除关联表中的数据时，当前表与其关联的行的行为。</p><ol><li><p><code>models.CASCADE</code>:删除关联数据，与之关联的数据也删联(<code>on_delete=models.CASCADE</code>)</p></li><li><p>抛出异常(错误)</p><ol><li><code>models.DO_NOTHING</code>:删除关联数据，引发错误<code>IntegrityError</code></li><li><code>models.PROTECT</code><br>删除关联数据，引发错误<code>ProtectedError </code></li></ol></li><li><p><code>models.SET_NULL</code>:删除关联数据，与之关联的值设置为<code>null</code>（前提FK字段需要设置为可空）</p></li><li><p><code>models.SET_DEFAULT</code>:删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）</p></li><li><p><code>models.SET</code>:删除关联数据</p><ol><li>与之关联的值设置为指定值，设置：<code>models.SET(值)</code></li><li>与之关联的值设置为可执行对象的返回值，设置：<code>models.SET(可执行对象)</code></li></ol></li></ol></li></ol><h4 id="2、OneToOneField-一对一"><a class="header-anchor" href="#2、OneToOneField-一对一">¶</a>2、OneToOneField(一对一)</h4><blockquote><p>外键字段创建在任意一张表都可以，建议外键添加在查询频率较高的一方</p></blockquote><pre class=" language-language-python"><code class="language-language-python"># 关键字OneToOneFieldauthor_detail = models.OneToOneField(to='Author_detail')  # 外键本质fk + unique</code></pre><h5 id="字段参数-v2"><a class="header-anchor" href="#字段参数-v2">¶</a>字段参数</h5><ol><li><p><code>to</code> :设置要关联的表。</p></li><li><p><code>to_field</code>:设置要关联的字段。</p></li><li><p><code>on_delete</code>:同ForeignKey字段。</p></li></ol><h4 id="3、ManyToManyField-多对多"><a class="header-anchor" href="#3、ManyToManyField-多对多">¶</a>3、ManyToManyField(多对多)</h4><blockquote><p>用于表示多对多的关联关系。在数据库中通过第三张表来建立关联关系。</p></blockquote><pre class=" language-language-python"><code class="language-language-python"># 关键字ManyToManyFieldauthor = models.ManyToManyField(to='Author')  # django orm会自动帮你创建第三张关系表，表名为两个关联的表名用_连接</code></pre><h5 id="字段参数-v3"><a class="header-anchor" href="#字段参数-v3">¶</a>字段参数</h5><ol><li><p><code>to</code>:设置要关联的表</p></li><li><p><code>related_name</code>:同<code>ForeignKey</code>字段(反向操作时，使用的字段名，用于代替原反向查询时的<code>'表名_set'</code>)</p></li><li><p><code>related_query_name</code>:同<code>ForeignKey</code>字段(反向查询操作时，使用的连接前缀，用于替换表名)</p></li><li><p><code>symmetric</code>:仅用于多对多自关联时，指定内部是否创建反向操作的字段。默认为<code>True</code>。</p><pre class=" language-language-python"><code class="language-language-python"> class Person(models.Model):     name = models.CharField(max_length=16)     friends = models.ManyToManyField("self")     # 此时，person对象就没有person_set属性。 class Person(models.Model):     name = models.CharField(max_length=16)     friends = models.ManyToManyField("self",symmetrical=False)     # 此时，person对象现在就可以使用person_set属性进行反向查询。</code></pre></li><li><p><code>through</code>:在使用<code>ManyToManyField</code>字段时，<code>Django</code>将自动生成一张表        来管理多对多的关联关系。但我们也可以手动创建第三张表来管理多对多关系，此时就需要通过<code>through</code>来指定第三张表的表名。</p></li><li><p><code>through_fields</code>:设置关联的字段。</p></li><li><p><code>db_table</code>:默认创建第三张表时，数据库中表的名称。</p></li></ol><h5 id="多对多的三种创建方式"><a class="header-anchor" href="#多对多的三种创建方式">¶</a>多对多的三种创建方式</h5><ol><li><p>自己建立第三张关系表，外键分别关联两个表</p><ul><li><p>优点:可以扩充第三张关系标的字段</p></li><li><p>缺点:自己做连表查询</p></li><li><p>建表例子</p><pre class=" language-language-python"><code class="language-language-python">class Book(models.Model):    title = models.CharField(max_length=12) class Author(models.Model):     name = models.CharField(max_length=12) # 1. 多对多第一种创建方式：自己创建第三张关系表 class Author2Book(models.Model):     id = models.AutoField(primary_key=True)     author_id = models.ForeignKey(to='Author')     book_id = models.ForeignKey(to='Book')     price = models.IntegerField()  # 可以自己扩充需要的字段</code></pre></li></ul></li><li><p>通过ORM内置的ManyToManyField，自动创建第三张关系表</p><ul><li><p>优点:提供了很多连表操作的快捷方法,<code>all()</code>, <code>add()</code>, <code>set()</code>, <code>clear()</code>, <code>remove()</code></p></li><li><p>缺点:无法扩展第三张关系表</p></li><li><p>建表例子</p><pre class=" language-language-python"><code class="language-language-python">class Book(models.Model):    title = models.CharField(max_length=12) class Author(models.Model):     name = models.CharField(max_length=12)     books = models.ManyToManyField(to='Book')  # 字段就这些，无法扩充其他字段</code></pre></li></ul></li><li><p>自己创建第三张关系表，通过ManyToManyField关联</p><ul><li><p>优点：</p><ul><li>既能够使用多对多查询的快捷方法all()(只能用all，不能使用add,set等)</li><li>还能够自己扩展第三张关系表的字段</li></ul></li><li><p>建表例子</p><pre class=" language-language-python"><code class="language-language-python">class Book(models.Model):    title = models.CharField(max_length=12)class Author(models.Model):     name = models.CharField(max_length=12)     # 告诉ManyToManyField通过(through)Author2Book这张表进行关联，不使用ORM自动创建的第三张表，而是使用我自己创建的表     # through_fields告诉ORM通过哪几个字段进行多对多关联     books = models.ManyToManyField(to='Book', through='Author2Book', through_fields=('author', 'book')) # 1. 多对多第三种创建方式：自己创建第三张关系表，此时外键不需要添加_id了，因为ORM会默认帮你在外键后面加_id class Author2Book(models.Model):     id = models.AutoField(primary_key=True)     author = models.ForeignKey(to='Author')     book = models.ForeignKey(to='Book')     price = models.IntegerField(null=True)      # author_id和book_id要联合唯一     class Meta:         unique_together = (('author', 'book'),)</code></pre></li><li><p>操作例子</p><pre class=" language-language-python"><code class="language-language-python"># 多对多的第三张方式也支持all查询author_obj = Author.objects.first()# 第一个作者的所有书籍ret = author_obj.books.all() # 给第一个作者添加一本书# author_obj.books.add(4) # 报错Author2Book.objects.create(author_id=1, book_id=4)</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> ORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS攻击和CSRF攻击</title>
      <link href="/2020/05/24/xss-gong-ji-he-csrf-gong-ji/"/>
      <url>/2020/05/24/xss-gong-ji-he-csrf-gong-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="CSRF"><a class="header-anchor" href="#CSRF">¶</a>CSRF</h2><h3 id="1-CSRF-的基本概念、缩写、全称"><a class="header-anchor" href="#1-CSRF-的基本概念、缩写、全称">¶</a>1. CSRF 的基本概念、缩写、全称</h3><p>CSRF（Cross-site request forgery）：跨站请求伪造。</p><h3 id="2-CSRF-的攻击原理"><a class="header-anchor" href="#2-CSRF-的攻击原理">¶</a>2. CSRF 的攻击原理</h3><p><img src="https://img2018.cnblogs.com/blog/941968/201904/941968-20190422203527996-279231194.jpg" alt=""></p><p>用户是网站 A 的注册用户，且登录进去，于是网站 A 就给用户下发 cookie。</p><p>从上图可以看出，要完成一次 CSRF 攻击，受害者必须满足两个必要的条件：</p><p>（1）登录受信任网站 A，并在本地生成 Cookie。（如果用户没有登录网站 A，那么网站 B 在诱导的时候，请求网站 A 的 api 接口时，会提示你登录）</p><p>（2）在不登出 A 的情况下，访问危险网站 B（其实是利用了网站 A 的漏洞）。</p><p>我们在讲 CSRF 时，一定要把上面的两点说清楚。</p><p>温馨提示一下，cookie 保证了用户可以处于登录状态，但网站 B 其实拿不到 cookie。</p><h3 id="3-CSRF的防范措施"><a class="header-anchor" href="#3-CSRF的防范措施">¶</a>3. CSRF的防范措施</h3><h4 id="1、判断请求头中的-Referer"><a class="header-anchor" href="#1、判断请求头中的-Referer">¶</a>1、判断请求头中的 Referer</h4><p>这个字段记录的是请求的来源。比如前端<em>Vue</em>页面 <code>http://localhost:8080/#/showbooks</code>上调用了服务端<em>Django</em>的接口 <code>http://127.0.0.1:8000/books/?page=2&amp;page_size=10</code>， 那么在服务端，就可以通过 <code>Referer</code> 判断这个请求是来自哪里。</p><p>在实际应用中，这些跟业务逻辑无关的操作往往会放在拦截器中（或者说过滤器，不同技术使用的名词可能不同）。意思是说，在进入到业务逻辑之前，就应该要根据 Referer 的值来决定这个请求能不能处理。</p><p>用Flask 的话可以使用装饰器；在Django 中是叫中间件。每种技术它走的流程其实都一样。</p><p>而在 Django 可以通过以下代码获取对应信息</p><pre class=" language-language-python"><code class="language-language-python">request.META['HTTP_REFERER']  # 来路request.META.get("HTTP_USER_AGENT")  # 请求头</code></pre><p>在Flask中，则获取方式不同。</p><pre class=" language-language-python"><code class="language-language-python">request.referrer  # 来路request.headers.get('User-Agent')  # 请求头</code></pre><p>但要注意的是，Referer 是浏览器设置的，在浏览器兼容性大不相同的时代中，如果存在某种浏览器允许用户修改这个值，那么 CSRF 漏洞依然存在。</p><h4 id="2、在请求参数中加入-csrf-token"><a class="header-anchor" href="#2、在请求参数中加入-csrf-token">¶</a>2、在请求参数中加入 csrf token</h4><p>讨论 GET 和 POST 两种请求，对于 GET，其实也没什么需要防范的。为什么？</p><p>因为 GET 在 “约定” 当中，被认为是查询操作，查询的意思就是，你查一次，查两次，无数次，结果都不会改变（用户得到的数据可能会变），这不会对数据库造成任何影响，所以不需要加其他额外的参数。</p><blockquote><p>所以这里要提醒各位的是，尽量遵从这些约定，不要在 GET 请求中出现 /delete, /update, /edit 这种单词。把 “写” 操作放到 POST 中。</p></blockquote><p>对于 POST，服务端在创建表单的时候可以加一个隐藏字段，也是通过某种加密算法得到的。在处理请求时，验证这个字段是否合法，如果合法就继续处理，否则就认为是恶意操作。</p><pre class=" language-language-html"><code class="language-language-html"><form method="post" action="/delete">  <!-- 其他字段 -->  <input type="hidden" /></form></code></pre><p>这个 html 片段由服务端生成。</p><p>这的确是一个很好的防范措施，再增加一些处理的话，还能防止表单重复提交。</p><p>可是对于一些新兴网站，很多都采用了 “前后端分离开发” 的设计，或者退一步，无论是不是前后端分离，它的 HTML 可能是由 JavaScript 拼接而成，并且表单也都是异步提交。所以这个办法有它的应用场景，也有局限性。</p><h4 id="3、新增-HTTP-Header"><a class="header-anchor" href="#3、新增-HTTP-Header">¶</a>3、新增 HTTP Header</h4><p>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p><p>把 token 隐藏在 http 的 head 头中。</p><p>服务端可以像获取 Referer 一样获取这个请求头，不同的是，这个 token 是由服务端生成的，所以攻击者他没办法猜。</p><p>另一篇文章讲解的——<strong><code>JWT</code></strong>——就是基于这个方式。抛开 JWT 不谈，它的工作原理是这样的:</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/10/image-20201010164929032.png" alt="image-20201010164929032"></p><p>解释一下这四个请求，类型都是 POST 。</p><ol><li><p>通过 <code>/login</code> 接口，用户登录，服务端传回一个 <code>access_token</code>，前端把它保存起来，可以是内存当中，如果你希望用来模拟 <code>session</code> 的话。也可以保存到 <code>localStorage</code> 中，这样可以实现自动登录。</p></li><li><p>调用 <code>/delete</code> 接口，参数是某样商品的 id。仔细看，在这个请求中，多了一个名为 <code>Authoriaztion</code> 的 <code>header</code>，它的值是之前从服务端传回来的 <code>access_token</code>，在前面加了一个 “<code>Bearer</code>”（这是和服务端的约定，约定就是说，说好了加就一起加，不加就都不加……）</p></li><li><p>调用 <code>/logout</code> 接口，同样把 <code>access_token</code> 加在 <code>header</code> 中传过去。成功之后，服务端和前端都会把这个 <code>token</code> 置为失效，或直接删除。</p></li><li><p>再调用 <code>/delete</code> 接口，由于此时已经没有 <code>access_token</code> 了，所以服务端判断该请求没权限，返回 401 。</p></li></ol><p>从头至尾，整个过程没有涉及 cookie，所以 CSRF 是不可能发生的！</p><h2 id="XSS"><a class="header-anchor" href="#XSS">¶</a>XSS</h2><h3 id="1-XSS-的基本概念"><a class="header-anchor" href="#1-XSS-的基本概念">¶</a>1. XSS 的基本概念</h3><p>XSS（Cross Site Scripting）：跨域脚本攻击。</p><h3 id="2-XSS-的攻击原理"><a class="header-anchor" href="#2-XSS-的攻击原理">¶</a>2. XSS 的攻击原理</h3><p>XSS 攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入），向你的页面注入脚本（可能是 js、hmtl 代码块等）。</p><p>最后导致的结果可能是：</p><p>盗用 Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss 攻击</p><h3 id="3-XSS-的攻击方式"><a class="header-anchor" href="#3-XSS-的攻击方式">¶</a>3. XSS 的攻击方式</h3><h4 id="1、反射型"><a class="header-anchor" href="#1、反射型">¶</a>1、反射型</h4><p>发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。</p><h4 id="2、存储型存"><a class="header-anchor" href="#2、存储型存">¶</a>2、存储型存</h4><p>储型 XSS 和反射型 XSS 的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交 XSS 代码。</p><h3 id="4-XSS-的防范措施"><a class="header-anchor" href="#4-XSS-的防范措施">¶</a>4. XSS 的防范措施</h3><p>XSS 的防范措施主要有三个：</p><h4 id="1、编码"><a class="header-anchor" href="#1、编码">¶</a>1、编码</h4><p>对用户输入的数据进行<code>HTML Entity</code> 编码。</p><p>比如说这段代码：</p><pre class=" language-language-js"><code class="language-language-js"><script>alert(1)</script></code></pre><p>若不进行任何处理，则浏览器会执行 <code>alert</code> 的 js 操作，实现 <code>XSS</code> 注入。</p><p>进行编码处理之后，在浏览器中的显示结果就是 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，实现了将 <code>$var</code> 作为纯文本进行输出，且不引起 <code>JavaScript</code> 的执行。</p><h4 id="2、过滤"><a class="header-anchor" href="#2、过滤">¶</a>2、过滤</h4><p>移除用户输入的和事件相关的属性。如 <code>onerror</code> 可以自动触发攻击，还有 <code>onclick</code> 等。（总而言是，过滤掉一些不安全的内容）移除用户输入的 <code>Style</code> 节点、<code>Script</code> 节点、<code>Iframe</code> 节点。（尤其是 <code>Script</code> 节点，它可是支持跨域的，一定要移除）。</p><h4 id="3、校正"><a class="header-anchor" href="#3、校正">¶</a>3、校正</h4><p>避免直接对 <code>HTML Entity</code> 进行解码。使用 <code>DOM Parse</code> 转换，校正不配对的 <code>DOM</code> 标签。备注：我们应该去了解一下<code>DOM Parse</code>这个概念，它的作用是把文本解析成 <code>DOM</code> 结构。</p><p>比较常用的做法是，通过第一步的编码转成文本，然后第三步转成 DOM 对象，然后经过第二步的过滤。</p><h2 id="CSRF-和-XSS-的区别"><a class="header-anchor" href="#CSRF-和-XSS-的区别">¶</a>CSRF 和 XSS 的区别</h2><h3 id="区别一："><a class="header-anchor" href="#区别一：">¶</a>区别一：</h3><ul><li>CSRF：需要用户先登录网站 A，获取 cookie。</li><li>XSS：不需要登录。</li></ul><h3 id="区别二：（原理的区别）"><a class="header-anchor" href="#区别二：（原理的区别）">¶</a>区别二：（原理的区别）</h3><ul><li><p>CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api。</p></li><li><p>XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令</title>
      <link href="/2020/05/23/shu-ju-ku-redis-ming-ling/"/>
      <url>/2020/05/23/shu-ju-ku-redis-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>简单对redis 命令进行总结、归纳。</p><a id="more"></a><h3 id="键"><a class="header-anchor" href="#键">¶</a>键</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/%E9%94%AE%20.png" alt="键"></p><h3 id="String"><a class="header-anchor" href="#String">¶</a>String</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89%20.png" alt="String（字符串）"></p><h3 id="List"><a class="header-anchor" href="#List">¶</a>List</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89%20.png" alt="List（列表）"></p><h3 id="Hash"><a class="header-anchor" href="#Hash">¶</a>Hash</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/Hash%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%20.png" alt="Hash（哈希表）"></p><h3 id="Set"><a class="header-anchor" href="#Set">¶</a>Set</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89%20.png" alt="Set（集合）"></p><h3 id="Zset"><a class="header-anchor" href="#Zset">¶</a>Zset</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/ZSet%EF%BC%88SortedSet_%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89%20.png" alt="ZSet（SortedSet_有序集合）"></p><p>更多命令参考<a href="https://cloud.tencent.com/developer/doc/1203" target="_blank" rel="noopener">Redis教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除office最近文件</title>
      <link href="/2020/05/23/xi-tong-mac-qing-chu-office-zui-jin-wen-jian/"/>
      <url>/2020/05/23/xi-tong-mac-qing-chu-office-zui-jin-wen-jian/</url>
      
        <content type="html"><![CDATA[<ol><li><p>批量删除Mac系统下office最近文件</p><pre class=" language-language-bash"><code class="language-language-bash">rm -rf ~/Library/Containers/com.microsoft.Word/Data/Library/Preferences/com.microsoft.Word.securebookmarks.plistrm -rf ~/Library/Containers/com.microsoft.Excel/Data/Library/Preferences/com.microsoft.Excel.securebookmarks.plistrm -rf ~/Library/Containers/com.microsoft.Powerpoint/Data/Library/Preferences/com.microsoft.Powerpoint.securebookmarks.plist</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue事件绑定以及事件修饰符</title>
      <link href="/2020/05/16/vue-shi-jian-bang-ding-yi-ji-shi-jian-xiu-shi-fu/"/>
      <url>/2020/05/16/vue-shi-jian-bang-ding-yi-ji-shi-jian-xiu-shi-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="事件"><a class="header-anchor" href="#事件">¶</a>事件</h2><p>要理解事件绑定，就得先了解事件。</p><p>浏览器是事件驱动型的，根据用户的行为触发不同的事件，根据事件执行相应的操作。我们较为熟悉的事件有三大类型：</p><h3 id="鼠标键盘事件"><a class="header-anchor" href="#鼠标键盘事件">¶</a>鼠标键盘事件</h3><table><thead><tr><th style="text-align:left">鼠标键盘事件</th><th style="text-align:left">事件介绍</th></tr></thead><tbody><tr><td style="text-align:left">onclick</td><td style="text-align:left">鼠标点击某个对象</td></tr><tr><td style="text-align:left">ondbclick</td><td style="text-align:left">鼠标双击某个对象</td></tr><tr><td style="text-align:left">onmousedown</td><td style="text-align:left">某个鼠标按键被按下</td></tr><tr><td style="text-align:left">onmouseup</td><td style="text-align:left">某个鼠标按键被松开</td></tr><tr><td style="text-align:left">onmousemove</td><td style="text-align:left">鼠标被移动</td></tr><tr><td style="text-align:left">onmouseover</td><td style="text-align:left">鼠标被移到某元素之上</td></tr><tr><td style="text-align:left">onmouseout</td><td style="text-align:left">鼠标从某元素移开</td></tr><tr><td style="text-align:left">onkeypress</td><td style="text-align:left">某个键盘的键被按下或按住</td></tr><tr><td style="text-align:left">onkeydown</td><td style="text-align:left">某个键盘的键被按下</td></tr><tr><td style="text-align:left">onkeyup</td><td style="text-align:left">某个键盘的键被松开</td></tr></tbody></table><h3 id="页面事件"><a class="header-anchor" href="#页面事件">¶</a>页面事件</h3><table><thead><tr><th style="text-align:left">页面事件</th><th style="text-align:left">事件介绍</th></tr></thead><tbody><tr><td style="text-align:left">onload</td><td style="text-align:left">某个页面或图像被完成加载</td></tr><tr><td style="text-align:left">onunload</td><td style="text-align:left">用户退出页面</td></tr><tr><td style="text-align:left">onresize</td><td style="text-align:left">窗口或框架被调整尺寸</td></tr><tr><td style="text-align:left">onerror</td><td style="text-align:left">当加载文档或图像时发生某个错误</td></tr><tr><td style="text-align:left">onabort</td><td style="text-align:left">图像加载被中断</td></tr></tbody></table><h3 id="表单相关事件"><a class="header-anchor" href="#表单相关事件">¶</a>表单相关事件</h3><table><thead><tr><th style="text-align:left">表单相关事件</th><th style="text-align:left">事件介绍</th></tr></thead><tbody><tr><td style="text-align:left">onblur</td><td style="text-align:left">元素失去焦点</td></tr><tr><td style="text-align:left">onfocus</td><td style="text-align:left">元素获得焦点</td></tr><tr><td style="text-align:left">onchange</td><td style="text-align:left">用户改变域的内容</td></tr><tr><td style="text-align:left">onreset</td><td style="text-align:left">重置按钮被点击</td></tr><tr><td style="text-align:left">onsubmit</td><td style="text-align:left">提交按钮被点击</td></tr><tr><td style="text-align:left">onselect</td><td style="text-align:left">文本被选定</td></tr></tbody></table><blockquote><p>需要注意的是事件处理程序中的变量<code>event</code>保留着事件对象的信息，包括比如<code>click</code>事件，事件属性里有点击位置相对于浏览器，以及页面的坐标信息，事件的类型（<code>click</code>）,触发事件的DOM节点信息等;可以将<code>evenet</code>作为参数传递，在函数内部获取具体的evenet对象信息。</p></blockquote><h2 id="事件绑定"><a class="header-anchor" href="#事件绑定">¶</a>事件绑定</h2><ul><li><p>在Vue.js中<code>v-on</code>指令用来监听<code>DOM</code>事件，并在触发事件时运行一些<code>JavaScript</code>代码;当然<code>v-on</code>也可以简写为<code>@</code></p><pre class=" language-language-html"><code class="language-language-html"><!DOCTYPE html><html lang="zh-CN"><head>    <meta charset="UTF-8">    <title>事件绑定</title>    <script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script></head><body>    <div id='app'>        <button v-on:click='func'> 显示 </button>        <h1> {{msg}} </h1>    </div>    <script>        var vm = new Vue({            el: '#app',            data() {                return {                    msg: '',                }            },            methods: {                func() {                    this.msg = '这是一个大大的H1'                }            },        })    </script></body></html></code></pre></li></ul><h2 id="事件修饰符"><a class="header-anchor" href="#事件修饰符">¶</a>事件修饰符</h2><blockquote><p><code>Vue.js</code> 为 <code>v-on</code> 提供了事件修饰符来处理 <code>DOM</code> 事件细节;<code>Vue.js</code>通过由点(<code>.</code>)表示的指令后缀来调用修饰符。</p></blockquote><h3 id="事件修饰符分类"><a class="header-anchor" href="#事件修饰符分类">¶</a>事件修饰符分类</h3><p>Vue.js提供的事件修饰符主要针对两类情况:</p><ul><li><p>冒泡机制修饰符</p><ul><li><code>.stop</code></li><li><code>.capture</code></li><li><code>.self</code></li></ul></li><li><p>事件本身修饰符</p><ul><li><code>.prevent</code></li><li><code>.once</code></li></ul></li></ul><h3 id="冒泡机制修饰符"><a class="header-anchor" href="#冒泡机制修饰符">¶</a>冒泡机制修饰符</h3><h4 id="事件冒泡"><a class="header-anchor" href="#事件冒泡">¶</a>事件冒泡</h4><p><code>DOM</code>中，树状结构决定了子元素肯定在父元素里，所以点击子元素，就同时点击了子元素和父元素，以及父元素的父元素，以此类推，当然最终的根节点都是文档，以及<code>window</code>。</p><p>试想，当一个子元素被点击的时候，不仅仅这个元素本身被点击了，因为这个元素也在其上一级父元素中(属于父级元素的地盘)，所以相当于其父元素也被点击了，以此类推，一层一层往外推，最终整个文档也是被点击了，如果每个层级的节点元素都绑定了<code>click</code>事件，那么每个节点的<code>click</code>事件函数都会被执行。举个形象的例子，一个村里的人被打了（<code>click</code>），首先就要按照村里的规矩处理，同时这个村属于某个乡镇，当然也是相当于这个乡镇的人被打了，那么也要按照这个乡镇的规矩处理，以此一层一层往上报。这个例子不准确的地方就是，现实中一个人因为一个事件只会被处理一次，不会因为同一件事情多次处理。</p><h4 id="冒泡带来的烦恼"><a class="header-anchor" href="#冒泡带来的烦恼">¶</a>冒泡带来的烦恼</h4><p>当上层（以及上上层，直至<code>body</code>元素）父级有子元素同样的方法，但你子元素的事件后，所有父级元素的同名函数也会从下到上，由里往外，挨个执行，但是大多数情况下，我们只希望子当事元素事件执行，不希望层层执行，这就要想办法阻止这种冒泡的情况发生。比如我们点击<code>Child Span</code>的时候只显示 <code>Child Span</code>的内容。结合刚刚的例子就是，村里发生了打人事件，在村里解决了，就没必要一层一层往上报，在层层处理了。</p><h4 id="事件修饰符-v2"><a class="header-anchor" href="#事件修饰符-v2">¶</a>事件修饰符</h4><p>在Vue.js中针对Js事件本身的冒泡机制提供一些事件修饰符以便使用</p><ul><li><p><code>.stop</code>: 阻止冒泡事件</p><pre class=" language-language-html"><code class="language-language-html"><!DOCTYPE html><html lang="zh-CN"><head>    <meta charset="UTF-8">    <title>冒泡机制</title>    <script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script>    <style>        #outer {            width: 400px;            height: 200px;            background-color: aqua;            position: absolute;        }        #inner {            width: 200px;            height: 100px;            background-color: darkcyan;            margin: 50px auto;        }        #btn {            width: 40px;            height: 30px;            background-color: gold;            margin: 35px 80px;        }    </style></head><body>    <div id='app'>        <div id="outer" @click='outer'>            <div id="inner" @click='inner'>                <button id="btn" @click.stop='btn'>按钮 </button>            </div>        </div>    </div>    <script>        var vm = new Vue({            el: '#app',            methods: {                inner() {                    console.log("inner触发了")                },                outer() {                    console.log("outer触发了")                },                btn() {                    console.log("btn触发了")                }            },        })    </script></body></html></code></pre><blockquote><p>当点击按钮时，只会触发<code>button</code>本身的<code>click</code>事件,不会继续传递</p></blockquote></li><li><p><code>.self</code>:  只当事件在该元素本身（而不是子元素）触发时触发回调函数</p><pre class=" language-language-html"><code class="language-language-html"><div id="outer" @click='outer'>    <div id="inner" @click.self='inner'>        <button id="btn" @click='btn'>按钮 </button>    </div></div></code></pre><blockquote><p>当点击按钮时, 继续触发冒泡机制，因此<code>outter</code>盒子同样会触发对应的回调函数,但是<code>inner</code>盒子并不会触发回调函数，只有点击<code>inner</code>本身时，才会正常执行回调函数</p></blockquote></li><li><p><code>.capture</code>: 添加事件侦听器时使用事件捕获模式,即拥有该事件修饰符的元素会优先触发对应事件</p><pre class=" language-language-html"><code class="language-language-html"><div id="outer" @click.capture='outer'>    <div id="inner" @click='inner'>        <button id="btn" @click='btn'>按钮 </button>    </div></div></code></pre><blockquote><p>当点击按钮时, 继续触发冒泡机制，但是会优先触发<code>outer</code>的回调函数,其次，按照正常的冒泡顺序，由内向外</p></blockquote></li></ul><h3 id="事件本身修饰符"><a class="header-anchor" href="#事件本身修饰符">¶</a>事件本身修饰符</h3><ul><li><p><code>.prevent</code>:阻止默认行为</p><pre class=" language-language-html"><code class="language-language-html"><!DOCTYPE html><html lang="zh-CN"><head>    <meta charset="UTF-8">    <title>VueDemo</title>    <script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script>    <style>        form {            width: 210px;            height: 300px;            position: relative;            margin: 0 auto;        }        .user {            width: 200px;            height: 20px;            display: block;            margin: 5px auto;        }        #btn {            width: 70px;            float: right;        }    </style></head><body>    <div id='app'>        <form action="/userinfo" method="POST" v-on:submit.prevent='onsubmit'>            <input type="text" name="user" class="user" v-model='user.name' placeholder="请输入用户名。。。">            <input type="password" name="user" class="user" v-model='user.pwd' placeholder="请输入密码。。。">            <input type="submit" id="btn" value="提交">        </form>    </div>    <script>        var vm = new Vue({            el: '#app',            data() {                return {                    user: {                        name: "",                        pwd: ""                    }                }            },            methods: {                onsubmit() {                    console.log(`表单信息:${this.user.name}和${this.user.pwd}提交`)                }            },        })    </script></body></html></code></pre><blockquote><p>表单本身的提交行为会进行页面跳转，现在使用<code>.prevent</code>修饰符之后，只执行绑定的方法，不跳转页面;类似的还有超链接等的默认行为都可以使用该修饰符阻止</p></blockquote></li><li><p><code>.once</code>: 事件只能触发一次</p><pre class=" language-language-html"><code class="language-language-html"><!DOCTYPE html><html lang="zh-CN"><head>    <meta charset="UTF-8">    <title>VueDemo</title>    <script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script></head><body>    <div id='app'>        <button @click.once='btn'> 你只能评论一次 </button>    </div>    <script>        var vm = new Vue({            el: '#app',            methods: {                btn() {                    alert("已评论")                }            },        })    </script></body></html></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> v-on </tag>
            
            <tag> Js事件 </tag>
            
            <tag> 事件修饰符 </tag>
            
            <tag> 事件绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql常见错误</title>
      <link href="/2020/04/21/shu-ju-ku-mysql-chang-jian-cuo-wu/"/>
      <url>/2020/04/21/shu-ju-ku-mysql-chang-jian-cuo-wu/</url>
      
        <content type="html"><![CDATA[<p>简单对常见错误进行总结、归纳。</p><a id="more"></a><h2 id="Ubuntu系统"><a class="header-anchor" href="#Ubuntu系统">¶</a>Ubuntu系统</h2><h3 id="1698-只能root用户登录Mysql"><a class="header-anchor" href="#1698-只能root用户登录Mysql">¶</a>1698 只能root用户登录Mysql</h3><h4 id="一、问题描述"><a class="header-anchor" href="#一、问题描述">¶</a>一、问题描述</h4><p>如果mysql安装时，没有提示输入密码，则会随机分配密码，直接mysql -u root -p则无法登录，报错：</p><pre class=" language-language-shell"><code class="language-language-shell">ERROR 1698 (28000): Access denied for user 'root'@'localhost</code></pre><h4 id="二、解决方案"><a class="header-anchor" href="#二、解决方案">¶</a>二、解决方案</h4><ol><li><p>用管理员权限进入数据库</p><pre class=" language-language-shell"><code class="language-language-shell"> sudo mysql -uroot -p</code></pre></li><li><p>修改加密方式和密码</p><pre class=" language-language-sql"><code class="language-language-sql"> alter user 'username'@'host' identified with mysql_native_password BY 'password';</code></pre></li><li><p>刷新</p><pre class=" language-language-sql"><code class="language-language-sql"> flush privileges;</code></pre></li><li><p>最后重启终端，就可通过 <code>mysql -u root -p</code> 免sudo登录mysql啦！</p></li></ol><h2 id="Windows系统"><a class="header-anchor" href="#Windows系统">¶</a>Windows系统</h2><h3 id="1042服务启动异常"><a class="header-anchor" href="#1042服务启动异常">¶</a>1042服务启动异常</h3><h4 id="一、问题描述-v2"><a class="header-anchor" href="#一、问题描述-v2">¶</a>一、问题描述</h4><p>mysql已经发展到了8.0阶段，但是很多人在下载了安装了mysql8.0后，在快接近完成的阶段下出现了异常：</p><pre class=" language-language-bash"><code class="language-language-bash">error 1042：Unable to connect to any of the specified MySQL hosts</code></pre><p>上述异常直接导致mysql无法正常Finish，如图所示：</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/Mysql-1042.png" alt="Mysql-1042"></p><h4 id="二、解决方案-v2"><a class="header-anchor" href="#二、解决方案-v2">¶</a>二、解决方案</h4><ol><li><p>windows端使用<code>Win+R</code> --&gt; 运行 <code>&quot;services.msc&quot;</code> --&gt; 打开service服务管理器，找到刚才安装mysql的服务名称</p></li><li><p>右键 --&gt; 属性 --&gt; 登录，更改成&quot;本地系统账户&quot; --&gt; 确定</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020/08/Mysql%E7%99%BB%E5%BD%95%E8%BA%AB%E4%BB%BD%E4%BF%AE%E6%94%B9.png" alt="Mysql登录身份修改"></p></li><li><p>回到安装程序，在次点击Execute，会发现已经可以成功到Finish界面</p></li></ol><h3 id="1045用户密码错误"><a class="header-anchor" href="#1045用户密码错误">¶</a>1045用户密码错误</h3><h4 id="一、问题描述-v3"><a class="header-anchor" href="#一、问题描述-v3">¶</a>一、问题描述</h4><p>在数据库安装之后，使用<code>mysql -uroot -p</code>链接数据库时，出现以下异常:</p><pre class=" language-language-bash"><code class="language-language-bash">1045    Access denied for user 'root'@'localhost' (using password:YES)</code></pre><p>这个意思是说：用户“root”@本地主机的访问被拒绝</p><p>那为什么会出现这种错误呢？</p><p>答案是这样：这种问题的本质是用户密码出现错误。</p><h4 id="二、解决方案-v3"><a class="header-anchor" href="#二、解决方案-v3">¶</a>二、解决方案</h4><ol><li><p>打开命令窗口cmd，停止MySQL服务，输入命令：</p><pre class=" language-language-bash"><code class="language-language-bash"> net stop mysql</code></pre></li><li><p>开启跳过密码验证登录的MySQL服务,输入命令</p><pre class=" language-language-bash"><code class="language-language-bash"> mysqld --console --skip-grant-tables --shared-memory</code></pre></li><li><p>再打开一个新的cmd，无密码登录MySQL，输入登录命令</p><pre class=" language-language-bash"><code class="language-language-bash"> mysql -u root -p</code></pre></li><li><p>重置用户名对应的密码，命令如下：</p><pre class=" language-language-sql"><code class="language-language-sql"> use mysql; update user set authentication_string='' where user='root'; --修改密码为空 flush privileges; --刷新权限</code></pre></li><li><p>退出mysql</p></li><li><p>关闭以<code>--console --skip-grant-tables --shared-memory</code> 启动的MySQL服务，</p></li><li><p>打开命令框，启动MySQL服务。输入</p><pre class=" language-language-bash"><code class="language-language-bash"> net start mysql</code></pre></li><li><p>再次登录无密码登录：</p><pre class=" language-language-bash"><code class="language-language-bash"> mysql -u root -p</code></pre></li><li><p>正确修改root密码</p><pre class=" language-language-sql"><code class="language-language-sql">alter user 'root'@'host' identified with mysql_native_password BY 'mysql';flush privileges;</code></pre></li><li><p>退出，再次成功登录，到此，重置密码结束。</p></li></ol><h3 id="Mysql数据库初始化"><a class="header-anchor" href="#Mysql数据库初始化">¶</a>Mysql数据库初始化</h3><p>当Mysql数据库链接失败， 跳过用户名验证也失败， 需要先删除 安装目录下的<code>data</code>文件夹, 然后重新初始化,生成初始化密码</p><ol><li><p>以管理员的身份打开cmd窗口跳转路径到<code>X:\xxx\mysql-8.0.11-winx64\bin</code></p><pre class=" language-language-bash"><code class="language-language-bash"> mysqld --initialize --user=mysql --console</code></pre></li><li><p>按照上面的流程，就可以跳过用户名验证，重新设置mysql密码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router</title>
      <link href="/2020/04/14/vue-vue-router/"/>
      <url>/2020/04/14/vue-vue-router/</url>
      
        <content type="html"><![CDATA[<p>Vue.js官方提供了一套专用的路由工具库 Vue Router,其使用和配置都非常简单。</p><h2 id="安装路由"><a class="header-anchor" href="#安装路由">¶</a>安装路由</h2><p>可以使用npm包的方式来安装路由</p><pre class=" language-language-bash"><code class="language-language-bash">cnpm install vue-router --save</code></pre><blockquote><p>其实通过Vue-cli脚手架快速搭建项目时，命令行会询问是否安装路由功能，从而并不需要额外安装路由功能</p></blockquote><p>通过Vue-cli脚手架搭建的项目，在<code>src/router</code>文件夹内部有<code>index.js</code>文件，打开index.js文件会看到以下引用。</p><pre class=" language-language-javascript"><code class="language-language-javascript">import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)</code></pre><p>在入口文件<code>src/main.js</code>中导入<code>src/router/index.js</code>文件，即可使用路由配置的信息</p><pre class=" language-language-javascript"><code class="language-language-javascript">import router from './router'//等效于//import router from './router/index.js'</code></pre><h2 id="建立路由模块"><a class="header-anchor" href="#建立路由模块">¶</a>建立路由模块</h2><p>先建立一个路由器模块,主要用来配置和绑定相关信息。</p><p>在<code>src/router/index.js</code>文件中使用<code>new Router</code>命令创建一个路由,一个路由是一个对象。</p><p>一条路由的实现需要三部分:<code>name</code> 、<code>path</code>和<code>component</code>。<code>name</code>是命名,<code>path</code>是路径,<code>component</code>是组件</p><pre class=" language-language-javascript"><code class="language-language-javascript">// src/router/index.jsimport Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'// 把对应的组件或页面引入进来import Login from '@/pages/login' // @指src根路径Vue.use(Router)export default new Router({  routes: [    {      path: '/', // 这里默认是跳转到HelloWorld 组件， 后期会改为项目首页      name: 'HelloWorld',      component: HelloWorld    },    {      path:'/login',      name: 'Login',      component: Login  // 后续如果还有页面要跳转，就按照这样的格式继续书写    }  ]})</code></pre><blockquote><p>导入<code>HelloWorld</code>组件的时候，实际上导入的是<code>src/components/HelloWorld.vue</code>.因为在<code>Webpack</code>中配置了，所以可以省略vue后缀。<code>*.vue</code>文件是Vue的单文件组件格式，可以同时包括模板定义、样式定义和组件模块定义。</p></blockquote><h2 id="启动路由器"><a class="header-anchor" href="#启动路由器">¶</a>启动路由器</h2><ol><li><p>在<code>main.js</code>入口文件中启用该路由器。</p><p><code>main.js</code>作为入口文件，使用<code>import</code>可以把所有要用到的包都导入到这里，然后在Vue项目中去运用它们。</p><p>创建和挂载根实例，通过<code>router</code>配置参数注入路由，从而让整个应用都有路由功能</p><pre class=" language-language-javascript"><code class="language-language-javascript"> // src/main.js import Vue from 'vue' import App from './App' import router from './router' new Vue({ el: '#app', router, components: { App }, template: '<App/>' })</code></pre><blockquote><p>浅析 导包方式</p></blockquote><p>这个不是vue的规定而是node加载模块的方式,当require(’./router’)(import会被转为require),node是这样的寻找目标的:</p><ol><li><p>首先寻找目录下有没有router.js或者router.node,如果有就导入</p></li><li><p>如果没有看是否有router目录,如果没有就require失败,抛出异常&quot;Cannot find module ‘./router’&quot;</p></li><li><p>如果有router目录会在其下寻找package.json文件,如果有则按照package的配置来导入</p></li><li><p>如果没有package.json,看是否有index.js或者index.node,如果有就导入没有就失败</p><p>详细见node文档：<a href="https://nodejs.org/api/modules.html#modules_folders_as_module" target="_blank" rel="noopener">https://nodejs.org/api/modules.html#modules_folders_as_module</a></p></li></ol></li><li><p>配置之后，路由匹配到的组件将会渲染到<code>App.vue</code>的<code>＜router-view&gt;&lt;/router-view&gt;</code></p><pre class=" language-language-javascript"><code class="language-language-javascript"> // src/App.vue <template> <div id="app">     <router-view/> </div> </template></code></pre></li><li><p>最后App.vue 会渲染到<code>index.html</code></p><pre class=" language-language-html"><code class="language-language-html"> <body> <div id=”app”></div> </body></code></pre><p>这样就会把渲染出来的页面挂载到id为app的div里了</p></li></ol><h2 id="路由重定向"><a class="header-anchor" href="#路由重定向">¶</a>路由重定向</h2><ol><li><p>项目应用通常都会有一个首页，默认首先打开的是首页，要跳转到哪个页面都可以设置路由路径发生跳转。重定向也是通过<code>routes</code>配置来完成的</p><pre class=" language-language-javascript"><code class="language-language-javascript"> routes: [     {     path: '/index',     name: 'index',     component: HelloWorld     },     // 从"/"重定向到"/index"     {     path:"/",     redirect:'/index'     },     // 重定向的目标也可以是一个命名的路由     {     path:"/p1",     redirect: { name:"index" }     },     // 重定向的目标甚至可以是一个方法，动态返回重定向目标     {     path:"/p2",     redirect:to=>{         // 方法接收 "目标路由" 作为参数         // return 重定向的 "字符串路径／路径对象"         // return '/index'         return {name: 'index'}     }     } ]</code></pre></li></ol><h2 id="router-link"><a class="header-anchor" href="#router-link">¶</a><code>&lt;router-link&gt;</code></h2><ol><li><p><code>&lt;router-link＞</code>组件支持用户在具有路由功能的应用中单击导航。</p><p>通过<code>to</code>属性可以指定目标地址,默认渲染成带有正确链接的<code>＜a＞</code>标签,通过配置<code>tag</code>属性可以生成别的标签。</p><p>另外,当目标路由成功激活时,链接元素会自动设置一个表示激活的<code>css</code>类名。</p><pre class=" language-language-html"><code class="language-language-html"> <!-- 直接给to指定属性值, 不提倡使用，尽量使用属性绑定 --> <router-link to='/goods'>商品</router-link> <!-- 使用v-bind 绑定 JS表达式--> <router-link :to="'/goods'">商品</router-link> <!-- 绑定data中的变量path --> <router-link :to='path'>商品</router-link> <!-- 绑定对象，自定义网址，携带查询参数 ==> /goods?id=1 --> <router-link :to="{'path':'/goods', , query:{'id':1}}}">商品</router-link> <!-- 绑定 对象，命名路由，携带params参数 ==> /goods/1 --> <router-link :to="{name:'goods', params:{'id':1}}">商品</router-link></code></pre></li></ol><h2 id="路由对象属性"><a class="header-anchor" href="#路由对象属性">¶</a>路由对象属性</h2><blockquote><p><code>route</code>和<code>router</code>区别:<code>vue-router</code>中经常会操作的两个对象<code>router</code>和<code>route</code>两个</p></blockquote><ol><li><p><code>route</code>是一个跳转的路由对象，每一个路由都会有一个<code>route</code>对象，是一个局部的对象，可以获取对应的<code>name</code>,<code>path</code>,<code>params</code>,<code>query</code>等</p><p>下面列出了常用的路由信息对象属性</p><ul><li><code>$route.path</code>: 字符串，对应当前路由的路径，总是解析为绝对路径,如<code>&quot;/goods&quot;</code></li><li><code>$route.params</code>: 一个<code>key/value</code>对象, 包含了动态片段和全匹配片段，如果没有路由参数，就为空对象。</li><li><code>$route.query</code>: 一个<code>key/value</code>对象, 表示URL查询参数。例如: 对于路径<code>/goods?cate_id=1</code>,则有<code>$route.query.cate_id == 1</code>；如果没有查询参数,则为空对象</li><li><code>$route.hash</code>: 当前路由的<code>hash</code>值(不带#)，如果没有<code>hash</code>值，则为空字符串。</li><li><code>$route.ful1Path</code>: 完成解析后的URL，包含查询参数和hash的完整路径。</li><li><code>$route.matched</code>: 一个数组，包含当前路由的所有嵌套路径片段的路由记录。路由记录就是<code>routes</code>配置数组中的对象副本(还有一些在children数组)。</li></ul></li><li><p><code>router</code>是<code>VueRouter</code>的一个对象，通过<code>Vue.use(VueRouter)</code>和<code>VueRouter</code>构造函数得到一个<code>router</code>的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。</p><p>下面列出了常用的路由信息对象方法</p><ul><li><p><code>router.push(location)</code>: 要导航到不同的URL，则使用<code>router.push</code>方法。该方法会向<code>history</code>栈添加一个新的记录，当用户单击浏览器的后退按钮时，回到之前的URL。</p><pre class=" language-language-javascript"><code class="language-language-javascript">  router.push('/goods') // 字符串  router.push({path: '/goods'}) // 对象  // 自定义网址，携带查询参数  router.push({ path: "/goods", query: { id: 1 } }) // -> /goods?id=1  // 命名路由，携带params参数  router.push({ name: "goods", params: { id: 1 } }) // -> /goods/1</code></pre><p>由一个页面跳转到另一个页面时，需要携带一些数据，这时就需要用到这种带参数的路由跳转方式了。</p><blockquote><p>当单击<code>＜router-link＞</code>时，会在内部调用<code>router.push(...)</code>方法，所以说单击<code>＜router-link:to＝&quot;...&quot;&gt;</code>等同于调用<code>router.push(...)</code>。</p></blockquote><pre class=" language-language-javascript"><code class="language-language-javascript">  // 当跳转之前，两种方式可以携带params参数  // <router-link :to="{name:'goods', params:{'id':1}}">商品</router-link>  // router.push({ name: "goods", params: { id: 1 } })  // 对应的路由配置有两种方式:  // 1. 将参数获取直接体现在网址上  routes: [      {      path: '/goods/:id',      name: 'goods',      component: goods      }  ]  // 此时会导致之前的params参数拼接在网址上， 为"/goods/1"，刷新不丢失数据  // 2. 不在网址上体现  routes: [      {      path: '/goods',      name: 'goods',      component: goods      }  ]  // 此时会导致之前的参数不能表现出来，网址仍为"/goods"，刷新之后，参数丢失  // 但是不管怎么配置路由，参数获取方式相同</code></pre></li><li><p><code>router.replace(location)</code>: <code>router.replace</code>与<code>router.push</code>很像，唯一的不同是它不会向<code>history</code>栈添加新记录，而是跟它的方法名一样只替换掉当前的history 记录。<code>router.replace(...)</code>等价于<code>＜router-link :to＝&quot;...&quot; replace＞</code></p></li><li><p><code>router.go(n)</code>: 参数是一个整数，表示在<code>history</code>记录中向前进多少步或向后退多少步</p><pre class=" language-language-javascript"><code class="language-language-javascript">  // 在浏览器记录中前进一步，等同于history.forward()  router.go(1)  // 后退一步，等同于history.back()  router.go(-1)  // 前进三步  router.go(3)  // 如果history记录不够，就会失败  router.go(-100)  router.go(100)</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-router </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6语法</title>
      <link href="/2020/04/12/js-es6-yu-fa/"/>
      <url>/2020/04/12/js-es6-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="变量声明"><a class="header-anchor" href="#变量声明">¶</a>变量声明</h2><h3 id="1-let"><a class="header-anchor" href="#1-let">¶</a>1. <code>let</code></h3><ul><li><p><code>let</code>作用域只局限于当前代码块</p><pre class=" language-language-javascript"><code class="language-language-javascript">{   var a = 10   let b = 20}console.log(a)  // 输出 10console.log(b)  // 报错 b is not defined</code></pre></li><li><p>使用<code>let</code>声明的变量作用域不会提前</p><pre class=" language-language-javascript"><code class="language-language-javascript">console.log(a)  // 输出 undefinedconsole.log(b)  // 报错 Cannot access 'b' before initializationvar a = 10let b = 20</code></pre></li><li><p>在相同的作用域下不能声明相同的变量</p><pre class=" language-language-javascript"><code class="language-language-javascript">      {     let a = 10 } let a = 20</code></pre><pre class=" language-language-javascript"><code class="language-language-javascript"> var a = 10 let a = 20  // 报错 Identifier 'a' has already been declared</code></pre></li></ul><h3 id="2-const"><a class="header-anchor" href="#2-const">¶</a>2. const</h3><ul><li><p>声明一个只读的常量。一旦声明，常量的值就不能改变</p></li><li><p><code>const</code>只声明，不赋值，就会报错，这意味着<code>const</code>一旦声明常量，就必须立即初始化</p></li><li><p><code>const</code>作用域与<code>let</code>相同，只在所在的块级作用域内有效</p></li><li><p><code>const</code>声明的常量不支持提升，和<code>let</code>一样，只能在声明后使用</p></li><li><p><code>const</code>声明的常量，也与<code>let</code>一样， 不可重复声明</p></li><li><p><code>const</code>实际保证的并不是常量的值不变，而是常量指向的内存地址不得改变</p><ul><li><p>对于简单的数据类型(数字、字符串、布尔值),值就保存在常量指向的地址，因此等同常量</p></li><li><p>对于复合类型的数据(数组、对象)，常量指向的内存地址保存的只是一个指针，const只能保证指针是固定的，但是指针指向的数据结构是不是可变的，并不能保证</p><pre class=" language-language-javascript"><code class="language-language-javascript">const a = 5// a = 10 // 报错 Assignment to constant variableconst obj = {}obj.a = 20 // 可执行console.log(obj) // 可执行 {a: 20}// obj = {} // 报错const arry = []arry.push(1) // 可执行arry.length = 0 // 可执行// arry = [] // 报错 Assignment to constant variable</code></pre></li></ul></li></ul><h3 id="3-实例演示"><a class="header-anchor" href="#3-实例演示">¶</a>3. 实例演示</h3><ul><li><p>使用var声明循环变量，会导致全局共用一个变量</p><pre class=" language-language-html"><code class="language-language-html"><button>按钮</button><button>按钮</button><button>按钮</button><button>按钮</button><button>按钮</button><script>    var btns = document.querySelectorAll('button')    for (var i = 0; i < btns.length; i++) {        btns[i].onclick = function () {            console.log(`这是第${i}个按钮`)        }    }    // 此时点击任何按钮，输出都是"这是第5个按钮"    for (let j = 0; j < btns.length; j++) {        btns[j].onclick = function () {            console.log(`这是第${j}个按钮`)        }    }    // 把循环中的var改为let,则为正确的结果，即输出对应的按钮序号</script></code></pre></li><li><p>下面的例子也是for循环中全局共用同一变量的弊端</p><pre class=" language-language-javascript"><code class="language-language-javascript">for(var i=1;i<10;i++){    setTimeout(()=>{        console.log(i) // 输出 10个9    }, 100)}console.log(i) // 9for(let j=1;j<10;j++){    setTimeout(()=>{        console.log(j) // 输出 0-9    }, 100)}console.log(j) // 报错 j is not defined</code></pre><blockquote><p>解释</p></blockquote></li><li><p>var是全局作用域，有变量提升的作用，所以在for中定义一个变量，全局可以使用，循环中的每一次给变量i赋值都是给全局变量i赋值。</p></li><li><p>let是块级作用域,只能在代码块中起作用，在js中一个{}中的语句我们也称为叫一个代码块，每次循环会产生一个代码块，每个代码块中的都是一个新的变量j</p></li></ul><h3 id="4-小结"><a class="header-anchor" href="#4-小结">¶</a>4. 小结</h3><blockquote><p><code>let</code>、<code>const</code>使用场景</p></blockquote><ul><li><code>const</code>一般用在需要一个模块时使用或者定义一些全局常量时使用</li><li><code>let</code>限制了变量的作用域，保证变量不会影响全局变量，所以尽量将<code>var</code>改为<code>let</code></li></ul><h2 id="箭头函数"><a class="header-anchor" href="#箭头函数">¶</a>箭头函数</h2><h3 id="1-箭头函数"><a class="header-anchor" href="#1-箭头函数">¶</a>1. 箭头函数</h3><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。</p><p>为什么叫Arrow Function？因为它的定义用的就是一个箭头</p><pre class=" language-language-javascript"><code class="language-language-javascript">x => x * x</code></pre><p>上面的箭头函数相当于：</p><pre class=" language-language-javascript"><code class="language-language-javascript">function (x) {    return x * x;}</code></pre><p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式。一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code>：</p><pre class=" language-language-javascript"><code class="language-language-javascript">x => {    if (x > 0) {        return x * x;    }    else {        return - x * x;    }}</code></pre><p>如果参数不是一个，就需要用括号()括起来：</p><pre class=" language-language-javascript"><code class="language-language-javascript">// 两个参数:(x, y) => x * x + y * y// 无参数:() => 3.14// 可变参数:(x, y, ...rest) => {    var i, sum = x + y;    for (i=0; i<rest.length; i++) {        sum += rest[i];    }    return sum;}</code></pre><p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p><pre class=" language-language-javascript"><code class="language-language-javascript">// SyntaxError:x => { foo: x }</code></pre><p>因为和函数体的{ … }有语法冲突，所以要改为：</p><pre class=" language-language-javascript"><code class="language-language-javascript">// ok:x => ({ foo: x })</code></pre><h3 id="2-箭头函数与匿名函数异同"><a class="header-anchor" href="#2-箭头函数与匿名函数异同">¶</a>2. 箭头函数与匿名函数异同</h3><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别:</p><p>箭头函数的提出，主要是为了解决多层函数嵌套中this指代混乱的问题；箭头函数内部的this是词法作用域，由上下文确定。</p><ul><li><p>使用普通函数嵌套会产生this指代混乱的问题</p><pre class=" language-language-javascript"><code class="language-language-javascript">var person = {    age: 18,    getBirth: function () {        var bth = function () {          // 多层嵌套函数中，this优先寻找父级作用域对象，不存在，即指向全局window对象            return new Date().getFullYear() - this.age  // this.age   undefined        }        return bth()    }}console.log(person.getBirth()) // NaN</code></pre></li><li><p>使用箭头函数即可解决问题</p><pre class=" language-language-javascript"><code class="language-language-javascript">var person = {    age: 18,    getBirth: function () {        var bth = ()=>{          // 在箭头函数中 this会寻找父级作用域的对象，找到为止            return new Date().getFullYear() - this.age  // this.age  18        }        return bth()    }}console.log(person.getBirth()) // 2002</code></pre></li></ul><h3 id="3-箭头函数不适用的场景"><a class="header-anchor" href="#3-箭头函数不适用的场景">¶</a>3. 箭头函数不适用的场景</h3><ol><li><p>作为对象的属性</p><pre class=" language-language-javascript"><code class="language-language-javascript">var obj = {    a: () => {        console.log(this); // window    }};</code></pre><p>作为对象的属性时，this的指向则不再是对象本身了，这就造成了意想不到的结果</p></li><li><p>不可以作为构造函数来使用</p><pre class=" language-language-javascript"><code class="language-language-javascript">var Person = (name) => { // Uncaught TypeError: Person is not a constructor    this.name = name;}var person = new Person('Jack');</code></pre><p>这个特性很容易测试，如果上一条明白的话也很容易理解： 箭头函数压根就没有this，当然不能作为构造函数（如果明白构造函数new的过程的话，插一句： new的过程其实就是创建一个对象，将this指向该对象，然后执行代码初始化这个对象，最后返回）</p></li><li><p>不可以作为原型方法</p><p>同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误</p><pre class=" language-language-javascript"><code class="language-language-javascript">function Cat(name) {    this.name = name;}Cat.prototype.sayCatName = () => {    console.log(this === window); // => true    return this.name;};const cat = new Cat('Mew');cat.sayCatName(); // => undefined</code></pre><p>使用传统的函数表达式就能解决问题：</p><pre class=" language-language-javascript"><code class="language-language-javascript">function Cat(name) {    this.name = name;}Cat.prototype.sayCatName = function () {    console.log(this === cat); // => true    return this.name;};const cat = new Cat('Mew');cat.sayCatName(); // => 'Mew'</code></pre><p>sayCatName 变成普通函数之后，被调用时的执行上下文就会指向新创建的 cat 实例。</p></li><li><p>不绑定arguments（如果有要使用arguments的时候可以使用rest参数代替）</p><pre class=" language-language-javascript"><code class="language-language-javascript">var foo = (val) => {    console.log(arguments); // Uncaught ReferenceError: arguments is not defined};foo();</code></pre><p>这个特性也很好测试，但是实在要使用<code>arguments</code>对象要怎么办呢？我们可以使用es6的另一个新特性rest参数，完美替代</p><pre class=" language-language-javascript"><code class="language-language-javascript">var foo = (...args) => {    console.log(args); // [1, 2, 3]};foo(1, 2, 3);</code></pre></li></ol><h2 id="JS对象嵌套函数"><a class="header-anchor" href="#JS对象嵌套函数">¶</a>JS对象嵌套函数</h2><p>在 <code>js</code> 的语法规则中，如果一个对象内存在方法，则该方法 <code>this</code> 指向当前对象。<br>如下所示：</p><pre class=" language-language-js"><code class="language-language-js">let obj = {    age: 10,    getAge: function () {         console.log(this.age)    }}obj.getAge();// 10</code></pre><p>若方法中再次包含函数方法，则该嵌套函数指向全局。不能获取到本对象中的属性。<br>如下所示：</p><pre class=" language-language-js"><code class="language-language-js">let obj = {    age: 10,    getAge: function () {         setTimeout(function(){ alert(this.age)}, 1000)    }}obj.getAge();// undefined</code></pre><p>可以通过如下几种办法来解决此问题：<br>（1）定义变量，保存对象 <code>this</code></p><pre class=" language-language-js"><code class="language-language-js">getAge: function () { let self = this;        setTimeout(function(){ alert(self.age)}, 1000)    }</code></pre><p>(2) 通过箭头函数的方式</p><p>由于箭头函数具有默认指向父级调用对象 obj 的特点，因此也可以解决本问题</p><pre class=" language-language-js"><code class="language-language-js">getAge: function () { setTimeout(() => { alert(this.age)}, 1000)}</code></pre><h2 id="解构赋值"><a class="header-anchor" href="#解构赋值">¶</a>解构赋值</h2><h3 id="什么是解构赋值？"><a class="header-anchor" href="#什么是解构赋值？">¶</a>什么是解构赋值？</h3><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。</p><p>通常来说，你很可能这样访问数组中的前三个元素：</p><pre class=" language-language-js"><code class="language-language-js">var first = someArray[0];var second = someArray[1];var third = someArray[2];</code></pre><p>如果使用解构赋值的特性，将会使等效的代码变得更加简洁并且可读性更高：</p><pre class=" language-language-js"><code class="language-language-js">var [first, second, third] = someArray;</code></pre><p><code>SpiderMonkey</code>（Firefox 的 JavaScript 引擎）已经支持解构的大部分功能，但是仍不健全。你可以通过 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=694100" target="_blank" rel="noopener">bug 694100</a> 跟踪解构和其它 ES6 特性在 <code>SpiderMonkey</code> 中的支持情况。</p><h3 id="数组与迭代器的解构"><a class="header-anchor" href="#数组与迭代器的解构">¶</a>数组与迭代器的解构</h3><p>以上是数组解构赋值的一个简单示例，其语法的一般形式为：</p><pre class=" language-language-js"><code class="language-language-js">[ variable1, variable2, ..., variableN ] = array;</code></pre><p>这将为 variable1 到 variableN 的变量赋予数组中相应元素项的值。如果你想在赋值的同时声明变量，可在赋值语句前加入<code>var</code>、<code>let</code>或<code>const</code>关键字，例如：</p><pre class=" language-language-js"><code class="language-language-js">var [ variable1, variable2, ..., variableN ] = array;let [ variable1, variable2, ..., variableN ] = array;const [ variable1, variable2, ..., variableN ] = array;</code></pre><p>事实上，用<code>变量</code>来描述并不恰当，因为你可以对任意深度的嵌套数组进行解构：</p><pre class=" language-language-js"><code class="language-language-js">var [foo, [[bar], baz]] = [1, [[2], 3]];console.log(foo);  // 1console.log(bar);  // 2console.log(baz);  // 3</code></pre><p>此外，你可以在对应位留空来跳过被解构数组中的某些元素：</p><pre class=" language-language-js"><code class="language-language-js">var [,,third] = ["foo", "bar", "baz"];console.log(third);  // "baz"</code></pre><p>而且你还可以通过 “<a href="http://www.infoq.com/cn/articles/es6-in-depth-rest-parameters-and-defaults" target="_blank" rel="noopener">不定参数</a>” 模式捕获数组中的所有尾随元素：</p><pre class=" language-language-js"><code class="language-language-js">var [head, ...tail] = [1, 2, 3, 4];console.log(tail); // [2, 3, 4]</code></pre><p>当访问空数组或越界访问数组时，对其解构与对其索引的行为一致，最终得到的结果都是：<code>undefined</code>。</p><pre class=" language-language-js"><code class="language-language-js">console.log([][0]);   // undefinedvar [missing] = [];console.log(missing); // undefined</code></pre><p>请注意，数组解构赋值的模式同样适用于任意迭代器：</p><pre class=" language-language-js"><code class="language-language-js">function* fibs() {      var a = 0;      var b = 1;      while (true) {        yield a;        [a, b] = [b, a + b];      }}var [first, second, third, fourth, fifth, sixth] = fibs();console.log(sixth);  // 5</code></pre><h3 id="对象的解构"><a class="header-anchor" href="#对象的解构">¶</a>对象的解构</h3><p>通过解构对象，你可以把它的每个属性与不同的变量绑定，首先指定被绑定的属性，然后紧跟一个要解构的变量。</p><pre class=" language-language-js"><code class="language-language-js">var robotA = { name: "Bender" };var robotB = { name: "Flexo" };var { name: nameA } = robotA;var { name: nameB } = robotB;console.log(nameA);  // "Bender"console.log(nameB);  // "Flexo"</code></pre><p>当属性名与变量名一致时，可以通过一种实用的句法简写：</p><pre class=" language-language-js"><code class="language-language-js">var { foo, bar } = { foo: "lorem", bar: "ipsum" };console.log(foo);  // "lorem"console.log(bar);  // "ipsum"</code></pre><p>与数组解构一样，你可以随意嵌套并进一步组合对象解构：</p><pre class=" language-language-js"><code class="language-language-js">var complicatedObj = {  arrayProp: [    "Zapp",    { second: "Brannigan" }  ]};var { arrayProp: [first, { second }] } = complicatedObj;console.log(first);// "Zapp"console.log(second);// "Brannigan"</code></pre><p>当你解构一个未定义的属性时，得到的值为<code>undefined</code>：</p><pre class=" language-language-js"><code class="language-language-js">var { missing } = {};console.log(missing);// undefined</code></pre><p>请注意，当你解构对象并赋值给变量时，如果你已经声明或不打算声明这些变量（亦即赋值语句前没有<code>let</code>、<code>const</code>或<code>var</code>关键字），你应该注意这样一个潜在的语法错误：</p><pre class=" language-language-js"><code class="language-language-js">{ blowUp } = { blowUp: 10 };// Syntax error 语法错误</code></pre><p>为什么会出错？这是因为 JavaScript 语法通知解析引擎将任何以 {开始的语句解析为一个块语句（例如，<code>{console}</code>是一个合法块语句）。解决方案是将整个表达式用一对小括号包裹：</p><pre class=" language-language-js"><code class="language-language-js">({ safe } = {});// No errors 没有语法错误</code></pre><h3 id="解构值不是对象、数组或迭代器"><a class="header-anchor" href="#解构值不是对象、数组或迭代器">¶</a>解构值不是对象、数组或迭代器</h3><p>当你尝试解构<code>null</code>或<code>undefined</code>时，你会得到一个类型错误：</p><pre class=" language-language-js"><code class="language-language-js">var {blowUp} = null;// TypeError: null has no properties（null没有属性）</code></pre><p>然而，你可以解构其它原始类型，例如：<code>布尔值</code>、<code>数值</code>、<code>字符串</code>，但是你将得到<code>undefined</code>：</p><pre class=" language-language-js"><code class="language-language-js">var {wtf} = NaN;console.log(wtf);// undefined</code></pre><p>你可能对此感到意外，但经过进一步审查你就会发现，原因其实非常简单。当使用对象赋值模式时，被解构的值<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible" target="_blank" rel="noopener">需要被强制转换为对象</a>。大多数类型都可以被转换为对象，但<code>null</code>和<code>undefined</code>却无法进行转换。当使用数组赋值模式时，被解构的值一定要<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-getiterator" target="_blank" rel="noopener">包含一个迭代器</a>。</p><h3 id="默认值"><a class="header-anchor" href="#默认值">¶</a>默认值</h3><p>当你要解构的属性未定义时你可以提供一个默认值：</p><pre class=" language-language-js"><code class="language-language-js">var [missing = true] = [];console.log(missing);// truevar { message: msg = "Something went wrong" } = {};console.log(msg);// "Something went wrong"var { x = 3 } = {};console.log(x);// 3</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> ES6 </tag>
            
            <tag> var </tag>
            
            <tag> let </tag>
            
            <tag> const </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python环境配置</title>
      <link href="/2020/04/11/gong-ju-python-huan-jing-pei-zhi/"/>
      <url>/2020/04/11/gong-ju-python-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>本篇文章将介绍如何在本地搭建Python开发环境。</p><p>Python可应用于多平台包括 Linux 和 Mac OS X。</p><p>你可以通过终端窗口输入 “python” 命令来查看本地是否已经安装Python以及Python的安装版本。</p><a id="more"></a><h2 id="Python环境配置"><a class="header-anchor" href="#Python环境配置">¶</a>Python环境配置</h2><pre class=" language-language-bash"><code class="language-language-bash"># ubuntusudo apt-get install python3-pipsudo apt-get install python-pip# windowspython3 -m pip install --upgrade pip --force-reinstallpython2 -m pip install --upgrade pip --force-reinstall# macbrew install python  # 这一步安装了python3和pip3brew install python@2 # 这一步安装了python2和pip2# ipython2pip install ipython # ipython3pip3 install ipython </code></pre><h2 id="pip镜像源"><a class="header-anchor" href="#pip镜像源">¶</a>pip镜像源</h2><h3 id="镜像源"><a class="header-anchor" href="#镜像源">¶</a>镜像源</h3><ul><li>清华：<code>https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>阿里云：<code>http://mirrors.aliyun.com/pypi/simple/</code></li><li>中国科技大学 <code>https://pypi.mirrors.ustc.edu.cn/simple/</code></li><li>华中理工大学：<code>http://pypi.hustunique.com/</code></li><li>山东理工大学：<code>http://pypi.sdutlinux.org/</code></li><li>豆瓣：<code>http://pypi.douban.com/simple/</code></li></ul><h3 id="文件修改"><a class="header-anchor" href="#文件修改">¶</a>文件修改</h3><h4 id="Linux-Mac"><a class="header-anchor" href="#Linux-Mac">¶</a>Linux/Mac</h4><p>修改 <code>~/.pip/pip.conf</code> (没有就创建一个文件夹及文件。文件夹要加<code>.</code>，表示是隐藏文件夹)</p><blockquote><p>内容如下</p></blockquote><pre class=" language-language-bash"><code class="language-language-bash">[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com</code></pre><h4 id="windows"><a class="header-anchor" href="#windows">¶</a>windows</h4><p>直接在 user 目录中创建一个 pip 目录，如：<code>C:\Users\xx\pip</code>，新建文件<code>pip.ini</code>。内容同上。</p><h3 id="终端修改"><a class="header-anchor" href="#终端修改">¶</a>终端修改</h3><pre class=" language-language-bash"><code class="language-language-bash">pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ # 终端使用命令设置pip镜像pip install pip -U  # 升级pip包管理工具</code></pre><h2 id="虚拟环境之pipenv"><a class="header-anchor" href="#虚拟环境之pipenv">¶</a>虚拟环境之pipenv</h2><ol><li><p>安装<code>pipenv</code></p><pre class=" language-language-bash"><code class="language-language-bash"> pip install pipenv</code></pre></li><li><p>使用<code>pipenv</code>创建虚拟环境</p><pre class=" language-language-bash"><code class="language-language-bash"> # 尽量在一个项目目录下创建虚拟环境 pip install</code></pre></li><li><p>激活虚拟环境</p><pre class=" language-language-bash"><code class="language-language-bash"> # 在创建虚拟环境的位置运行命令 pipenv shell</code></pre></li><li><p>修改虚拟环境的镜像源</p><p>打开虚拟环境下的配置文件: <code>Pipfile</code></p><pre class=" language-language-bash"><code class="language-language-bash">    [[source]]    name = "pypi"    url = "https://pypi.org/simple"    verify_ssl = true    [dev-packages]    [packages]    [requires]    python_version = "3.7"</code></pre><p>修改url为国内镜像源:</p><ul><li><p>清华: <code>https://pypi.tuna.tsinghua.edu.cn/simple</code></p></li><li><p>阿里云: <code>http://mirrors.aliyun.com/pypi/simple/</code></p></li><li><p>中国科技大学: <code>https://pypi.mirrors.ustc.edu.cn/simple/</code></p></li><li><p>华中理工大学: <code>http://pypi.hustunique.com/</code></p></li><li><p>山东理工大学: <code>http://pypi.sdutlinux.org/</code></p></li><li><p>豆瓣: <code>http://pypi.douban.com/simple/</code></p></li></ul></li><li><p>在虚拟环境安装第三方包</p><pre class=" language-language-bash"><code class="language-language-bash"> pipenv install django</code></pre></li><li><p>使用pipenv卸载第三方模块</p><pre class=" language-language-bash"><code class="language-language-bash"> pipev uninstall django</code></pre></li><li><p>查看依赖</p><pre class=" language-language-bash"><code class="language-language-bash"> pipenv graph</code></pre></li><li><p>将安装的模块打包到一个文件内</p><pre class=" language-language-bash"><code class="language-language-bash"> pip freeze > requirements.txt</code></pre></li><li><p>将一个文件内的第三方扩展安装到虚拟环境中</p><pre class=" language-language-bash"><code class="language-language-bash"> pip install -r requirements.txt</code></pre></li><li><p>退出虚拟环境</p><pre class=" language-language-bash"><code class="language-language-bash">exit</code></pre></li><li><p>删除虚拟环境</p><pre class=" language-language-bash"><code class="language-language-bash">pipenv --rm</code></pre></li><li><p>不激活虚拟环境，直接运行命令</p><pre class=" language-language-bash"><code class="language-language-bash">pipenv run django-amdin start project djangodemo</code></pre></li></ol><h2 id="虚拟环境之virtualenv"><a class="header-anchor" href="#虚拟环境之virtualenv">¶</a>虚拟环境之virtualenv</h2><ol><li><p>安装<code>virtualenv</code></p><pre class=" language-language-bash"><code class="language-language-bash"> pip install virtualenv # 虚拟环境 pip install virtualenvwrappern # mac/linux系统 pip install virtualenvwrapper-win # windows系统</code></pre></li><li><p>创建虚拟环境</p><pre class=" language-language-bash"><code class="language-language-bash"> mkvirtualenv django</code></pre></li><li><p>激活虚拟环境</p><pre class=" language-language-bash"><code class="language-language-bash"> # 在创建虚拟环境后会默认激活 workon django  # 激活django虚拟环境 workon  # 查看所有虚拟环境</code></pre></li><li><p>修改虚拟环境的镜像源</p><pre class=" language-language-bash"><code class="language-language-bash">pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ # 终端使用命令设置pip镜像pip install pip -U  # 升级pip包管理工具</code></pre></li><li><p>在虚拟环境安装第三方包</p><pre class=" language-language-bash"><code class="language-language-bash"> pip install django  # 先激活虚拟环境</code></pre></li><li><p>卸载第三方模块</p><pre class=" language-language-bash"><code class="language-language-bash"> pip uninstall django # 先激活虚拟环境</code></pre></li><li><p>将安装的模块打包到一个文件内</p><pre class=" language-language-bash"><code class="language-language-bash"> pip freeze > requirements.txt</code></pre></li><li><p>将一个文件内的第三方扩展安装到虚拟环境中</p><pre class=" language-language-bash"><code class="language-language-bash"> pip install -r requirements.txt</code></pre></li><li><p>退出虚拟环境</p><pre class=" language-language-bash"><code class="language-language-bash">exit</code></pre></li><li><p>删除虚拟环境</p><pre class=" language-language-bash"><code class="language-language-bash">rmvirtualenv django</code></pre></li></ol><h2 id="虚拟环境之conda"><a class="header-anchor" href="#虚拟环境之conda">¶</a>虚拟环境之conda</h2><h3 id="1-Anaconda简介"><a class="header-anchor" href="#1-Anaconda简介">¶</a>1. Anaconda简介</h3><ul><li><p>Anaconda是一个方便的python包管理和环境管理软件，一般用来配置不同的项目环境。</p></li><li><p>Anaconda通过管理工具包、开发环境、Python版本，大大简化了你的工作流程。不仅可以方便地安装、更新、卸载工具包，而且安装时能自动安装相应的依赖包，同时还能使用不同的虚拟环境隔离不同要求的项目。</p></li><li><p>Anaconda 镜像使用帮助</p><ul><li><p>Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算、数据分析的 Python 包。</p></li><li><p>Anaconda 安装包可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a> 下载。</p></li></ul></li><li><p>Miniconda 镜像使用帮助</p><ul><li><p>Miniconda 是一个 Anaconda 的轻量级替代，默认只包含了 python 和 conda，但是可以通过 pip 和 conda 来安装所需要的包。</p></li><li><p>Miniconda 安装包可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a> 下载。</p></li></ul></li></ul><h3 id="2-Anaconda安装"><a class="header-anchor" href="#2-Anaconda安装">¶</a>2. Anaconda安装</h3><ul><li><p>Windows安装</p><ul><li><p>点击安装文件<code>Anaconda3-2019.07-Windows-x86_64.exe</code>,选择安装路径,如<code>D:\python\Anaconda</code>,然后一直next即可。</p></li><li><p><strong>配置环境变量:</strong> 将安装的根路径,如<code>D:\python\Anaconda</code>和<code>scripts</code>文件夹路径<code>D:\python\Anaconda\scripts</code>添加到电脑环境变量之中</p></li></ul></li><li><p>Linux/Mac安装</p><ul><li><p>将安装文件<code>Anaconda3-2019.07-Linux-x86_64.sh</code>移动到用户家目录</p></li><li><p>在用户家目录,打开终端,执行<code>./Anaconda3-2019.07-Linux-x86_64.sh</code>,然后输入yes,一路回车即可。</p></li><li><p><strong>配置环境变量:</strong></p><ul><li><p>打开.bashrc 文件,在终端执行如下命令:</p><pre class=" language-language-bash"><code class="language-language-bash">vi ~/.bashrc</code></pre></li><li><p>输入G，跳转到文件末尾,在文件最后一行新增环境变量</p><pre class=" language-language-bash"><code class="language-language-bash">export PATH=~/anaconda3/bin:$PATH</code></pre></li><li><p>修改完成,先按esc键进入命令行模式，然后按<code>shift+：</code>进入末行模式，输入<code>wq</code>,保存退出</p></li><li><p>在终端执行如下命令,使其立即生效</p><pre class=" language-language-bash"><code class="language-language-bash">source ~/.bashrc</code></pre></li></ul><blockquote><p>注意：在Mac中，修改文件<code>.bash_profile</code>,其余和Linux操作一样</p></blockquote></li></ul></li></ul><h3 id="3-修改Anaconda镜像源"><a class="header-anchor" href="#3-修改Anaconda镜像源">¶</a>3. 修改Anaconda镜像源</h3><ul><li><p>Anaconda默认访问国外服务器，网速较慢，故需要修改默认镜像</p></li><li><p>TUNA 还提供了 Anaconda 仓库与第三方源（conda-forge、msys2、pytorch等，查看完整列表）的镜像，各系统都可以通过修改用户目录下的 .condarc 文件:</p><pre class=" language-language-bash"><code class="language-language-bash">channels:  - defaultsshow_channel_urls: truechannel_alias: https://mirrors.tuna.tsinghua.edu.cn/anacondadefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</code></pre><p>即可添加 Anaconda Python 免费仓库。Windows 用户无法直接创建名为 <code>.condarc</code> 的文件，可先执行 <code>conda config --set show_channel_urls yes</code> 生成该文件之后再修改。</p></li></ul><h3 id="4-Anconda基本使用"><a class="header-anchor" href="#4-Anconda基本使用">¶</a>4. Anconda基本使用</h3><h4 id="管理环境"><a class="header-anchor" href="#管理环境">¶</a>管理环境</h4><ul><li><p>检查conda版本</p><pre class=" language-language-bash"><code class="language-language-bash">conda --version</code></pre></li><li><p>升级当前版本conda</p><pre class=" language-language-bash"><code class="language-language-bash">conda update conda</code></pre></li><li><p>管理（虚拟）环境</p><pre class=" language-language-bash"><code class="language-language-bash"># 创建一个名为python37的环境，指定Python版本是3.7（不用管是3.7.x，conda会为我们自动寻找3.7.x中的最新版本）conda create --name python37 python=3.7# 安装好后，使用activate激活某个环境activate python37 # for Windowssource activate python37 # for Linux & Mac# 激活后，会发现terminal输入的地方多了python37的字样# 如果想返回默认的python环境，运行deactivate python37 # for Windowssource deactivate python37 # for Linux & Mac# 删除一个已有的环境conda remove --name python37 --all# 另外，我们可以使用conda命令替换source命令用来激活和关闭环境conda activate python37conda deactivate# 取消每次打开终端，默认激活bash环境conda config --set auto_activate_base false# 重新激活每次打开终端，默认进入base环境conda config --set auto_activate_base true</code></pre><p>新的开发环境会被默认安装在你conda目录下的envs文件目录下。</p><p>如果我们没有指定安装python的版本，conda会安装我们最初安装conda时所装的那个版本的python。</p></li><li><p>列出所有环境</p><pre class=" language-language-bash"><code class="language-language-bash">conda info -econda info –-envs</code></pre><blockquote><p>注意:conda会对当前活动的环境追加星号标记。</p></blockquote><pre class=" language-language-bash"><code class="language-language-bash">macdeMacBook-Pro:~ mac$ conda info -e# conda environments:#base                  *  /Users/mac/anaconda3myenv                    /Users/mac/anaconda3/envs/myenvpy3                      /Users/mac/anaconda3/envs/py3</code></pre></li><li><p>复制一个环境<br>通过克隆来复制一个环境。这儿将通过克隆py3来创建一个称为py32的副本。</p><pre class=" language-language-bash"><code class="language-language-bash">conda create -n py32 --clone py3</code></pre><p>通过</p><pre class=" language-language-bash"><code class="language-language-bash">conda info –-envs</code></pre><p>来检查环境。</p></li><li><p>重命名env</p><p>conda是没有重命名环境的功能的, 要实现这个基本需求, 只能通过愚蠢的克隆-删除的过程。</p><p>切记不要直接mv移动环境的文件夹来重命名, 会导致一系列无法想象的错误的发生!</p><pre class=" language-language-bash"><code class="language-language-bash">conda create --name newname --clone oldname      # 克隆环境conda remove --name oldname --all      # 彻底删除旧环境</code></pre></li><li><p>分享环境</p><p>如果你想把你当前的环境配置与别人分享，这样ta可以快速建立一个与你一模一样的环境（同一个版本的python及各种包）来共同开发/进行新的实验。</p><p><strong>一个分享环境的快速方法就是给ta一个你的环境的.yml文件。</strong></p><p>首先通过activate target_env要分享的环境target_env，然后输入下面的命令会在当前工作目录下生成一个environment.yml文件</p><pre class=" language-language-bash"><code class="language-language-bash">conda env export > environment.yml</code></pre><p>小伙伴拿到environment.yml文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境</p><pre class=" language-language-bash"><code class="language-language-bash">conda env create -f environment.yml</code></pre></li></ul><h4 id="管理包"><a class="header-anchor" href="#管理包">¶</a>管理包</h4><ul><li><p>conda安装和管理python包非常方便，可以在指定的python环境中安装包，且自动安装所需要的依赖包，避免了很多拓展包冲突兼容问题。</p></li><li><p><strong>不建议使用easy_install安装包</strong>。大部分包都可以使用conda安装，无法使用conda和anaconda.org安装的包可以通过pip命令安装</p></li><li><p>使用合适的源可以提升安装的速度</p></li><li><p>查看已安装包</p><pre class=" language-language-bash"><code class="language-language-bash">conda list</code></pre><p>使用这条命令来查看哪个版本的python或其他程序安装在了该环境中，或者确保某些包已经被安装了或被删除了。</p></li><li><p>向指定环境安装包<br>我们在指定环境中安装requests包，有两种方式:</p><ul><li><p>直接通过-n选项指定安装环境的名字</p><pre class=" language-language-bash"><code class="language-language-bash">conda install --name py3 requests</code></pre><blockquote><p>提示：你必须告诉conda你要安装环境的名字（-n py3）否则它将会被安装到当前环境中。</p></blockquote></li><li><p>激活py3环境，再使用conda install命令。</p><pre class=" language-language-bash"><code class="language-language-bash">conda activate py3conda install requests</code></pre></li></ul></li><li><p>通过pip命令</p><p>对于那些无法通过conda安装或者从Anaconda.org获得的包，我们通常可以用pip命令来安装包。</p><p>可以上pypi网站查询要安装的包，查好以后输入pip install命令就可以安装这个包了。</p><p>我们激活想要放置程序的python环境，然后通过pip安装一个叫“PyMysql”的包。</p><pre class=" language-language-bash"><code class="language-language-bash"># Linux, OS Xsource activate bunnies# Windowsactivate py3# 安装pip install pymysql</code></pre><p>pip只是一个包管理器，所以它不能为你管理环境。pip甚至不能升级python，因为它不像conda一样把python当做包来处理。但是它可以安装一些conda安装不了的包。</p><blockquote><p>小技巧：在任何时候你可以通过在命令后边跟上-help来获得该命令的完整文档。很多跟在–后边常用的命令选项，可以被略写为一个短线加命令首字母。所以–name选项和-n的作用是一样的。通过conda -h或conda –-help来看大量的缩写。</p></blockquote></li></ul><h4 id="移除包、环境、或者conda"><a class="header-anchor" href="#移除包、环境、或者conda">¶</a>移除包、环境、或者conda</h4><ul><li><p>移除包</p><p>假设你决定不再使用包pymysql。你可以在py3环境中移除它。</p><pre class=" language-language-bash"><code class="language-language-bash">conda remove -n py3 pymysql</code></pre></li><li><p>移除环境</p><p>我们不再需要snakes环境了，可以输入以下命令：</p><pre class=" language-language-bash"><code class="language-language-bash">conda remove -n myenv --all</code></pre></li><li><p>删除conda</p><ul><li><p>Linux/OS X：</p><p>移除Anaconda 或 Miniconda 安装文件夹</p><pre class=" language-language-bash"><code class="language-language-bash">rm -rf ~/miniconda# ORrm -rf ~/anaconda</code></pre></li><li><p>Windows：<br>去控制面板，点击“添加或删除程序”，选择“Python2.7/3.6（Anaconda）”或“Python2.7/3.6（Miniconda）”并点击删除程序。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pip </tag>
            
            <tag> virtualenv </tag>
            
            <tag> pipenv </tag>
            
            <tag> conda </tag>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRF-后端跨域</title>
      <link href="/2020/03/17/drf-hou-duan-kua-yu/"/>
      <url>/2020/03/17/drf-hou-duan-kua-yu/</url>
      
        <content type="html"><![CDATA[<p>前后端分离开发时，经常会遇到一个问题，那就是<code>跨域问题</code>,因为这时候前端和后端的代码是在不同机器上运行的，两个地址不在一个域名下，这个时候前端脚本在进行ajax访问的时候浏览器就会报跨域相关的错误。</p><p>原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。</p><p>为了解决这个问题，在前端和后台配置均可，此时，以后台django配置为例</p><h2 id="1-安装插件"><a class="header-anchor" href="#1-安装插件">¶</a>1. 安装插件</h2><pre class=" language-language-bash"><code class="language-language-bash">pip install django-cors-headers</code></pre><h2 id="2-注册应用"><a class="header-anchor" href="#2-注册应用">¶</a>2. 注册应用</h2><pre class=" language-language-python"><code class="language-language-python">INSTALLED_APPS = [    ...    'corsheaders',    ...]</code></pre><h2 id="3-中间件设置"><a class="header-anchor" href="#3-中间件设置">¶</a>3. 中间件设置</h2><pre class=" language-language-python"><code class="language-language-python">MIDDLEWARE = [    ...    'django.contrib.sessions.middleware.SessionMiddleware',    'corsheaders.middleware.CorsMiddleware',  # 注意，位置有限制    'django.middleware.common.CommonMiddleware',    ...]</code></pre><h2 id="4-配置跨域参数"><a class="header-anchor" href="#4-配置跨域参数">¶</a>4. 配置跨域参数</h2><pre class=" language-language-python"><code class="language-language-python">CORS_ORIGIN_ALLOW_ALL = True  # 允许所有host访问# 添加白名单CORS_ORIGIN_WHITELIST = (    '127.0.0.1:8080',    'localhost:8080',)# 以上配置二选一即可CORS_ALLOW_CREDENTIALS = True  # 允许携带cookie,不需要可以不设置</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRF </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRF-数据分页</title>
      <link href="/2020/03/16/drf-shu-ju-fen-ye/"/>
      <url>/2020/03/16/drf-shu-ju-fen-ye/</url>
      
        <content type="html"><![CDATA[<p>REST framework提供了分页的支持。有以下两种方式实现:</p><h2 id="全局配置"><a class="header-anchor" href="#全局配置">¶</a>全局配置</h2><ul><li><p>修改<code>settings.py</code>文件</p><pre class=" language-language-python"><code class="language-language-python">REST_FRAMEWORK = {    ...    'DEFAULT_PAGINATION_CLASS':  'rest_framework.pagination.PageNumberPagination',    'PAGE_SIZE': 100  # 每页数目    ...}</code></pre></li></ul><h2 id="类视图中定义"><a class="header-anchor" href="#类视图中定义">¶</a>类视图中定义</h2><p>自定义分页器,有两种分页器可选</p><h3 id="PageNumberPagination"><a class="header-anchor" href="#PageNumberPagination">¶</a>PageNumberPagination</h3><ul><li><p>前端访问形式</p><pre class=" language-language-python"><code class="language-language-python">GET  http://127.0.0.1:8000/books/?page=1&page_size=2</code></pre></li><li><p>属性</p><ul><li><p>page_size 每页数目</p></li><li><p>page_query_param 前端发送的页数关键字名，默认为&quot;page&quot;</p></li><li><p>page_size_query_param 前端发送的每页数目关键字名，默认为None</p></li><li><p>max_page_size 前端最多能设置的每页数量</p></li></ul></li><li><p>实例展示</p><pre class=" language-language-python"><code class="language-language-python">from rest_framework.pagination import PageNumberPaginationclass StandardPageNumberPagination(PageNumberPagination):    page_size_query_param = 'page_size'  # 前端发送的每页数目关键字名，默认为None    max_page_size = 10  # 前端最多能设置的每页数量    page_size = 3  # 每页数目    page_query_param = 'page'  # 前端发送的页数关键字名，默认为"page"class BookListView(ListAPIView):    queryset = BookInfo.objects.all().order_by('id')    serializer_class = BookInfoSerializer    pagination_class = StandardPageNumberPagination    def get(self, request, *args, **kwargs):        return self.list(request, *args, **kwargs)</code></pre></li></ul><h3 id="LimitOffsetPagination"><a class="header-anchor" href="#LimitOffsetPagination">¶</a>LimitOffsetPagination</h3><ul><li><p>前端访问形式</p><pre class=" language-language-python"><code class="language-language-python">GET  http://127.0.0.1:8000/books/?limit=2&offset=0</code></pre></li><li><p>属性</p><ul><li><code>default_limit</code>: 默认限制，默认值与PAGE_SIZE设置一致</li><li><code>limit_query_param</code>: <code>limit</code>参数名，默认’limit’</li><li><code>offset_query_param</code>: <code>offset</code>参数名，默认’offset’</li><li><code>max_limit</code>: 最大<code>limit</code>限制，默认None</li></ul></li><li><p>实例展示</p><pre class=" language-language-python"><code class="language-language-python">class LimitOffsetNumberPagination(LimitOffsetPagination):    default_limit = 2  # 默认限制，默认值与PAGE_SIZE设置一直    limit_query_param = 'limit'  # limit参数名，默认'limit'    offset_query_param = 'offset'  # offset参数名，默认'offset'    max_limit = 3  # 最大limit限制，默认Noneclass GoodsView(GenericAPIView, CreateModelMixin, ListModelMixin):    queryset = Goods.objects.all().order_by('id')    serializer_class = GoodsSerializer    pagination_class = LimitOffsetNumberPagination    def get(self, request, *args, **kwargs):        return self.list(request, *args, **kwargs)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRF </tag>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-图片上传</title>
      <link href="/2020/03/16/django-tu-pian-shang-chuan/"/>
      <url>/2020/03/16/django-tu-pian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="图片上传"><a class="header-anchor" href="#图片上传">¶</a>图片上传</h2><p>static 和 media 都是存放文件的地方，但是又有区别，以下是两个文件夹的区别和用法</p><h3 id="static"><a class="header-anchor" href="#static">¶</a>static</h3><h4 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h4><p>static 是静态文件，主要存的是 CSS, JavaScript, 网站 logo 等不变的文件。</p><h4 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h4><p>配置 <code>settings.py</code></p><pre class=" language-language-python"><code class="language-language-python">STATIC_URL = '/static/'  # 静态文件别名（相对路径） 和 绝对路径STATICFILES_DIRS = [    os.path.join(BASE_DIR, 'app01/static'),]# STATIC_ROOT 配置部署的时候才用</code></pre><h4 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h4><p>在项目中将模板层用到的静态文件都放入该文件夹中</p><h3 id="media"><a class="header-anchor" href="#media">¶</a>media</h3><h4 id="定义-v2"><a class="header-anchor" href="#定义-v2">¶</a>定义</h4><p>media 主要用来保存用户上传的文件，例如图片等</p><h4 id="配置-v2"><a class="header-anchor" href="#配置-v2">¶</a>配置</h4><p>配置 <code>settings.py</code></p><pre class=" language-language-python"><code class="language-language-python">MEDIA_URL = "/media/"   # 媒体文件别名(相对路径) 和 绝对路径MEDIA_ROOT = [    os.path.join(BASE_DIR, 'app01/media')]</code></pre><p>配置路由</p><ul><li><p>在子应用正常配置路由</p><pre class=" language-language-python"><code class="language-language-python">from django.urls import pathfrom app01.views import *app_name = 'goods'urlpatterns = [    path('goods/', GoodsCreateView.as_view(), name='create'),    path('', IndexView.as_view(), name='index'),]</code></pre></li><li><p>在项目的主路由中对图片上传的路径信息进行配置</p><pre class=" language-language-python"><code class="language-language-python">from django.conf.urls.static import staticfrom django.contrib import adminfrom django.urls import path, includefrom django01 import settingsurlpatterns = [    path('admin/', admin.site.urls),    path('', include('app01.urls')),] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)# 对外展示图片的地址信息</code></pre></li></ul><h3 id="模型类"><a class="header-anchor" href="#模型类">¶</a>模型类</h3><ul><li><p>定义包含图片字段的模型类</p><pre class=" language-language-python"><code class="language-language-python">class Goods(models.Model):    name = models.CharField(max_length=20, verbose_name="名称")    price = models.DecimalField(max_digits=7, decimal_places=2, verbose_name="单价")    nums = models.IntegerField(verbose_name="数量")    img = models.ImageField(upload_to='img', verbose_name="图片")    class Meta:        db_table = "tb_goods"        verbose_name = "商品"        verbose_name_plural = verbose_name    def __str__(self):        return self.name</code></pre></li></ul><h3 id="模板"><a class="header-anchor" href="#模板">¶</a>模板</h3><h4 id="添加页面"><a class="header-anchor" href="#添加页面">¶</a>添加页面</h4><pre class=" language-language-html"><code class="language-language-html"><form action="{% url 'goods:create' %}" method="post" enctype="multipart/form-data">    {% csrf_token %}    名称:<input type="text" name="name"> <br>    价格:<input type="text" name="price"> <br>    数量:<input type="text" name="nums"> <br>    图片:<input type="file" name="img"> <br>    <input type="submit" value="提交"></form></code></pre><h4 id="展示页面"><a class="header-anchor" href="#展示页面">¶</a>展示页面</h4><pre class=" language-language-html"><code class="language-language-html"><table>    {% for good in goods %}        <tr>            <td>{{ good.id }}</td>            <td>{{ good.name }}</td>            <td>{{ good.price }}</td>            <td>{{ good.nums }}</td>            <td>                <img src="/media/{{ good.img }}" alt="" style="width: 300px;height: 200px">            </td>        </tr>    {% endfor %}</table></code></pre><h3 id="视图"><a class="header-anchor" href="#视图">¶</a>视图</h3><h4 id="添加商品"><a class="header-anchor" href="#添加商品">¶</a>添加商品</h4><pre class=" language-language-python"><code class="language-language-python">from django.shortcuts import render, redirectfrom django.views import Viewfrom app01.models import Goods# Create your views here.class GoodsCreateView(View):    def get(self, request):        return render(request, 'goods.html')    def post(self, request):        name = request.POST.get('name')        price = request.POST.get('price')        nums = request.POST.get('nums')        img = request.FILES.get('img')        if not all([name, price, nums, img]):            return redirect('goods:create')        try:            Goods.objects.create(name=name, price=price, nums=nums, img=img)        except Exception as e:            print(e)            return redirect('goods:create')        return redirect('goods:index')</code></pre><h4 id="展示商品"><a class="header-anchor" href="#展示商品">¶</a>展示商品</h4><pre class=" language-language-python"><code class="language-language-python">class IndexView(View):    def get(self, request):        goods = Goods.objects.all()        return render(request, 'index.html', context={'goods': goods})</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRF-JWT认证、权限、限流</title>
      <link href="/2020/03/15/drf-jwt-ren-zheng-quan-xian-xian-liu/"/>
      <url>/2020/03/15/drf-jwt-ren-zheng-quan-xian-xian-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="用户模型类相关"><a class="header-anchor" href="#用户模型类相关">¶</a>用户模型类相关</h2><h3 id="模型类的定义"><a class="header-anchor" href="#模型类的定义">¶</a>模型类的定义</h3><p>在此，我们借用django自带的用户认证系统实现目的</p><ul><li><p>在<code>models.py</code>中定义用户类</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass User(AbstractUser):    phone = models.CharField(max_length=11, unique=True, verbose_name="手机号")    class Meta:        db_table = "tb_users"        verbose_name = "用户"        verbose_name_plural = "用户"    def __str__(self):        return self.username</code></pre></li></ul><h3 id="系统模型类的指定"><a class="header-anchor" href="#系统模型类的指定">¶</a>系统模型类的指定</h3><ul><li><p>在项目的配置文件<code>settings.py</code>中指定</p><pre class=" language-language-python"><code class="language-language-python"># AUTH_USER_MODEL = '应用名.模型类名'AUTH_USER_MODEL = 'users.user'</code></pre></li></ul><h3 id="序列化器的实现"><a class="header-anchor" href="#序列化器的实现">¶</a>序列化器的实现</h3><ul><li><p>在 <code>serializer.py</code>中定义用户类对应的序列化器</p><pre class=" language-language-python"><code class="language-language-python">from django.contrib.auth.hashers import make_passwordfrom rest_framework.serializers import ModelSerializerfrom .models import Userclass UserSerializer(ModelSerializer):    def create(self, validated_data):        # 重写创建用户方法，将密码进行加密        validated_data["password"] = make_password(validated_data["password"])        super().create(validated_data)        return validated_data    class Meta:        model = User        fields = ('id', 'username', 'password', 'phone')        read_only_fields = ('id',)</code></pre></li></ul><h2 id="JWT"><a class="header-anchor" href="#JWT">¶</a>JWT</h2><p>在用户注册或登录后，我们想记录用户的登录状态，或者为用户创建身份认证的凭证。我们不再使用Session认证机制，而使用JWT(Json Web Token)认证机制</p><h3 id="安装配置"><a class="header-anchor" href="#安装配置">¶</a>安装配置</h3><ul><li><p>安装插件</p><pre class=" language-language-bash"><code class="language-language-bash">pip install djangorestframework-jwt django-restframework</code></pre></li><li><p>重写JWT响应处理函数</p><p>在应用users中新建一个<code>utils.py</code>文件</p><pre class=" language-language-python"><code class="language-language-python">def jwt_response_payload_handler(token, user=None, request=None):    """    自定义jwt认证成功返回数据    """    return {        'token': token,        'id': user.id,        'username': user.username    }</code></pre></li><li><p>配置JWT认证机制</p><pre class=" language-language-python"><code class="language-language-python">REST_FRAMEWORK = {    # 指定drf认证机制    'DEFAULT_AUTHENTICATION_CLASSES': (        'rest_framework_jwt.authentication.JSONWebTokenAuthentication', # JWT认证        'rest_framework.authentication.SessionAuthentication', # session认证        'rest_framework.authentication.BasicAuthentication', # 基本认证    ),}JWT_AUTH = {    # 指明token的有效期    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1),    # 自定义jwt认证成功返回数据    'JWT_RESPONSE_PAYLOAD_HANDLER': 'apps.users.utils.jwt_response_payload_handler',}</code></pre></li></ul><h3 id="注册登录"><a class="header-anchor" href="#注册登录">¶</a>注册登录</h3><ul><li><p>定义视图</p><blockquote><p>注意：登录视图，使用JWT默认视图即可，只需实现注册视图</p></blockquote><pre class=" language-language-python"><code class="language-language-python">from rest_framework.generics import GenericAPIViewfrom rest_framework.mixins import CreateModelMixinfrom .serializer import UserSerializer, User# Create your views here.class RegisterView(CreateModelMixin, GenericAPIView):    queryset = User    serializer_class = UserSerializer    def post(self, request, *args, **kwargs):        return self.create(request, *args, **kwargs)</code></pre></li><li><p>配置路由</p><pre class=" language-language-python"><code class="language-language-python">from django.urls import pathfrom .views import RegisterViewfrom rest_framework_jwt.views import obtain_jwt_tokenurlpatterns = [    path('register/', RegisterView.as_view()),    path('login/', obtain_jwt_token),]</code></pre></li></ul><h3 id="权限Permissions"><a class="header-anchor" href="#权限Permissions">¶</a>权限Permissions</h3><p>权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。</p><p>在执行视图的dispatch()方法前，会先进行视图访问权限的判断<br>在通过get_object()获取具体对象时，会进行对象访问权限的判断</p><ol><li><p>全局配置</p><p>可以在项目的配置文件<code>settings.py</code>中设置默认的权限管理类</p><pre class=" language-language-python"><code class="language-language-python">REST_FRAMEWORK = {    'DEFAULT_PERMISSION_CLASSES': (        'rest_framework.permissions.IsAuthenticated',    )}</code></pre><p>如果未指明，则采用如下默认配置</p><pre class=" language-language-python"><code class="language-language-python">REST_FRAMEWORK = {    'DEFAULT_PERMISSION_CLASSES': (        'rest_framework.permissions.AllowAny',    )}</code></pre></li><li><p>局部配置</p><p>可以在具体的视图中通过permission_classes属性来设置，如</p><pre class=" language-language-python"><code class="language-language-python">from rest_framework.generics import GenericAPIViewfrom rest_framework.mixins import ListModelMixinfrom rest_framework.permissions import IsAuthenticatedfrom .serializer import UserSerializer, Userclass UserView(GenericAPIView, ListModelMixin):    queryset = User.objects.all()    serializer_class = UserSerializer    permission_classes = (IsAuthenticated,)    def get(self, request, *args, **kwargs):        return self.list(request, *args, **kwargs)</code></pre></li><li><p>提供的权限</p><ul><li><code>AllowAny</code>: 允许所有用户</li><li><code>IsAuthenticated</code>: 仅通过认证的用户</li><li><code>IsAdminUser</code>: 仅管理员用户</li><li><code>IsAuthenticatedOrReadOnly</code>: 认证的用户可以完全操作，否则只能get读取</li></ul></li></ol><h3 id="限流Throttling"><a class="header-anchor" href="#限流Throttling">¶</a>限流Throttling</h3><p>可以对接口访问的频次进行限制，以减轻服务器压力。特别是限制爬虫的抓取。</p><blockquote><p>可以在配置文件中，使用DEFAULT_THROTTLE_CLASSES 和 DEFAULT_THROTTLE_RATES进行全局配置</p></blockquote><ol><li><p>针对用户进行限制</p><ul><li><p>全局配置</p><pre class=" language-language-python"><code class="language-language-python">REST_FRAMEWORK = {    'DEFAULT_THROTTLE_CLASSES': (        # 限制所有匿名未认证用户，使用IP区分用户        'rest_framework.throttling.AnonRateThrottle',        # 限制认证用户，使用User id 来区分        'rest_framework.throttling.UserRateThrottle'    ),    'DEFAULT_THROTTLE_RATES': {        # 可以使用 second, minute, hour 或day来指明周期        'anon': '3/minute',        'user': '5/minute'    }}</code></pre></li><li><p>局部配置</p><p>视图中使用<code>throttle_classes</code>属性设置限流用户类型</p><pre class=" language-language-python"><code class="language-language-python">from rest_framework.generics import GenericAPIViewfrom rest_framework.mixins import ListModelMixinfrom rest_framework.throttling import UserRateThrottle, AnonRateThrottlefrom .serializer import UserSerializer, Userclass UserView(GenericAPIView, ListModelMixin):    queryset = User.objects.all()    serializer_class = UserSerializer    throttle_classes = (UserRateThrottle, AnonRateThrottle)    def get(self, request, *args, **kwargs):        return self.list(request, *args, **kwargs)</code></pre><p>在项目配置文件中针对用户类型设置具体频率</p><pre class=" language-language-python"><code class="language-language-python">REST_FRAMEWORK = {    'DEFAULT_THROTTLE_RATES': {        # 可以使用 second, minute, hour 或day来指明周期        'anon': '3/minute',        'user': '5/minute'    }}</code></pre></li></ul></li><li><p>针对视图限制</p><ul><li><p>视图中使用<code>throttle_scope</code>属性设置具体配置信息</p><pre class=" language-language-python"><code class="language-language-python">from rest_framework.generics import GenericAPIViewfrom rest_framework.mixins import ListModelMixinfrom rest_framework.permissions import IsAuthenticatedfrom .serializer import UserSerializer, Userclass UserView(GenericAPIView, ListModelMixin):    queryset = User.objects.all()    serializer_class = UserSerializer    throttle_scope = 'downloads'    def get(self, request, *args, **kwargs):        return self.list(request, *args, **kwargs)</code></pre></li><li><p>在项目配置文件中设置具体频率</p><pre class=" language-language-python"><code class="language-language-python">'DEFAULT_THROTTLE_CLASSES': (    # 限制用户对于每个视图的访问频次，使用ip或user id    'rest_framework.throttling.ScopedRateThrottle',),'DEFAULT_THROTTLE_RATES': {    'downloads': '3/minute'}</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRF </tag>
            
            <tag> JWT </tag>
            
            <tag> 权限 </tag>
            
            <tag> 认证 </tag>
            
            <tag> 限流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-用户认证</title>
      <link href="/2020/03/10/django-yong-hu-ren-zheng-xi-tong/"/>
      <url>/2020/03/10/django-yong-hu-ren-zheng-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="项目框架"><a class="header-anchor" href="#项目框架">¶</a>项目框架</h2><ol><li><p>项目结构</p><pre class=" language-language-bash"><code class="language-language-bash">.├── users│    ├── __init__.py│    ├── admin.py│    ├── apps.py│    ├── migrations│    │   └── __init__.py│    ├── models.py│    ├── tests.py│    ├── urls.py│    └── views.py├── db.sqlite3├── manage.py├── django_demo│    ├── __init__.py│    ├── settings.py│    ├── urls.py│    └── wsgi.py└── templates    ├── base.html    ├── index.html    ├── login.html    ├── register.html    └── user.html</code></pre></li></ol><h2 id="准备工作"><a class="header-anchor" href="#准备工作">¶</a>准备工作</h2><h3 id="创建项目"><a class="header-anchor" href="#创建项目">¶</a>创建项目</h3><p>通过终端命令,创建项目</p><pre class=" language-language-bash"><code class="language-language-bash">django_admin startproject django_demo</code></pre><h3 id="生成应用"><a class="header-anchor" href="#生成应用">¶</a>生成应用</h3><p>通过终端命令,生成users应用</p><pre class=" language-language-bash"><code class="language-language-bash"># 此时在项目文件夹之下执行命令python manage.py startapp users</code></pre><h3 id="修改配置信息"><a class="header-anchor" href="#修改配置信息">¶</a>修改配置信息</h3><p>在<code>settings.py</code>修改配置</p><pre class=" language-language-python"><code class="language-language-python"># 注册appINSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'users.apps.UsersConfig' # 注册users应用]# 配置模板路径TEMPLATES = [    {        'BACKEND': 'django.template.backends.django.DjangoTemplates',        'DIRS': [os.path.join(BASE_DIR, "templates")],        'APP_DIRS': True,        'OPTIONS': {            'context_processors': [                'django.template.context_processors.debug',                'django.template.context_processors.request',                'django.contrib.auth.context_processors.auth',                'django.contrib.messages.context_processors.messages',            ],        },    },]</code></pre><h3 id="创建模板"><a class="header-anchor" href="#创建模板">¶</a>创建模板</h3><p>在项目根路径下,创建<code>templates</code>,在目录下创建<code>base.html</code>文件,以便后面复用</p><pre class=" language-language-html"><code class="language-language-html">{% block nav %}    <p>        <a href="{% url 'users:index' %}">Index</a>        {% if user.is_authenticated %}            Hello, <a href="{% url 'users:user' %}">{{ user.username }} </a> .            <a href="{% url 'users:logout' %}">log out</a>        {% else %}            <a href="{% url 'users:register' %}">register</a>            <a href="{% url 'users:login' %}">log in</a>        {% endif %}    </p>{% endblock %}{% block err %}    {% if account_msg %}        <p>{{account_msg}}. Please try again.</p>    {% endif %}{% endblock %}{% block body %}{% endblock %}</code></pre><h3 id="指定用户模型类"><a class="header-anchor" href="#指定用户模型类">¶</a>指定用户模型类</h3><ol><li><p>在<code>users/models.py</code>中创建模型类</p><pre class=" language-language-python"><code class="language-language-python">from django.db import modelsfrom django.contrib.auth.models import AbstractUser# Create your models here.class UserProfile(AbstractUser):    phone = models.CharField(max_length=11, unique=True, verbose_name="手机号")    class Meta:        db_table = 'tb_users'  # 指定表名        verbose_name = '用户'  # 后台显示表名        verbose_name_plural = verbose_name    def __str__(self):        return self.username</code></pre></li><li><p>在<code>settings.py</code>文件中,指定本项目用户模型类<br>Django用户模型类是通过全局配置项 AUTH_USER_MODEL 决定的</p><pre class=" language-language-python"><code class="language-language-python"># 配置规则：AUTH_USER_MODEL = '应用名.模型类名'AUTH_USER_MODEL = 'users.UserProfile'</code></pre></li><li><p>通过终端命令,生成迁移文件和迁移表</p><pre class=" language-language-bash"><code class="language-language-bash">python manage.py makemigrationspython manage.py migrate</code></pre></li></ol><h2 id="逻辑实现"><a class="header-anchor" href="#逻辑实现">¶</a>逻辑实现</h2><h3 id="实现注册逻辑"><a class="header-anchor" href="#实现注册逻辑">¶</a>实现注册逻辑</h3><h4 id="定义视图"><a class="header-anchor" href="#定义视图">¶</a>定义视图</h4><pre class=" language-language-python"><code class="language-language-python">from django.contrib.auth.hashers import make_passwordfrom django.contrib.auth import loginfrom django.views import Viewfrom django.shortcuts import renderfrom django.http import JsonResponse, HttpResponseForbiddenfrom .models import UserProfile  class RegisterView(View):  def get(self, request):      return render(request, 'register.html')  def post(self, request):      username = request.POST.get("username")      password = request.POST.get("password")      password2 = request.POST.get("password2")      phone = request.POST.get("phone")      if not all([username, password, password2, phone]):          return JsonResponse("缺少必要参数")      if password != password2:          return HttpResponseForbidden("密码不一致")      # 此时 手动加密密码      # hash_password = make_password(password)      # try:      #   user = UserProfile(username=username, password=hash_password, phone=phone)      #   user.save()      # except Exception as e:      #     return HttpResponseForbidden("创建失败")      try:          # Django认证系统用户模型类提供的 create_user() 方法创建新的用户。          # create_user() 方法中封装了 set_password() 方法加密密码          user = UserProfile.objects.create_user(username=username, password=password, phone=phone)      except Exception as e:          return HttpResponseForbidden("创建失败")      # 状态保持      login(request, user)      return JsonResponse({"msg": "ok", "code": 200})</code></pre><h4 id="实现模板"><a class="header-anchor" href="#实现模板">¶</a>实现模板</h4><pre class=" language-language-html"><code class="language-language-html">{% extends "base.html" %}{% block body %}    <form action="{% url 'users:register' %}" method="post">        用户名:<input type="text" name="username">        密码:<input type="password" name="password">        确认密码:<input type="password" name="password2">        手机号: <input type="phone" name="phone">        <input type="submit" value="提交">    </form>{% endblock %}</code></pre><h3 id="实现登录逻辑"><a class="header-anchor" href="#实现登录逻辑">¶</a>实现登录逻辑</h3><h4 id="定义视图-v2"><a class="header-anchor" href="#定义视图-v2">¶</a>定义视图</h4><pre class=" language-language-python"><code class="language-language-python">class LoginView(View):    def get(self, request):        # 判断用户是否登录(属性) user.is_authenticated        if request.user.is_authenticated:            return redirect(reverse('users:index'))        return render(request, "login.html")    def post(self, request):        username = request.POST.get("username")        password = request.POST.get("password")        remembered = request.POST.get("remembered")        if not all([username, password]):            # return JsonResponse({"account_msg": "缺少必要参数", "code": 403})            return render(request, 'login.html', {'account_msg': '缺少必要参数', "code": 403})        # 校验用户信息，成功返回user对象，否则为None        user = authenticate(username=username, password=password)        if user is None:            return render(request, 'login.html', {'account_msg': '用户名或密码错误', "code": 403})        # 实现状态保持        login(request, user)        # 设置状态保持的周期        if remembered != 'on':            # 没有记住用户：浏览器会话结束就过期            request.session.set_expiry(0)        else:            # 记住用户：None表示两周后过期            request.session.set_expiry(None)        # 响应登录结果        return redirect(reverse('users:index'))</code></pre><h4 id="实现模板-v2"><a class="header-anchor" href="#实现模板-v2">¶</a>实现模板</h4><pre class=" language-language-html"><code class="language-language-html">{% extends "base.html" %}{% block body %}    <form method="post" action="{% url 'users:login' %}">        {% csrf_token %}        用户名:<input type="text" name="username">        密码:<input type="password" name="password">        <button name="submit">login</button>        <input type="hidden" name="next" value="{% url 'users:index' %}"/>    </form>{% endblock %}</code></pre><h3 id="注销"><a class="header-anchor" href="#注销">¶</a>注销</h3><h4 id="定义视图-v3"><a class="header-anchor" href="#定义视图-v3">¶</a>定义视图</h4><pre class=" language-language-python"><code class="language-language-python">class LogoutView(View):    def get(self, request):        """实现退出登录逻辑"""        # 清理session        logout(request)        # 退出登录，重定向到首页        response = redirect(reverse('users:index'))        # 退出登录时清除cookie中的username        response.delete_cookie('username')        return response</code></pre><h3 id="用户信息"><a class="header-anchor" href="#用户信息">¶</a>用户信息</h3><h4 id="定义视图-v4"><a class="header-anchor" href="#定义视图-v4">¶</a>定义视图</h4><pre class=" language-language-python"><code class="language-language-python">class UserView(View):    def get(self, requset):        # 如果用户没有登陆就访问本应登陆才能访问的页面时会直接跳转到登陆页面        if requset.user.is_authenticated:            return render(requset, 'user.html')        else:            return redirect(reverse('users:login'))    def post(self, request):        old_password = request.POST.get("old_password")        new_password = request.POST.get("new_password")        conf_password = request.POST.get("conf_password")        if not all([old_password, new_password, conf_password]):            return render(request, 'user.html', {'account_msg': '缺少必要参数', "code": 403})        if new_password != conf_password:            return render(request, 'user.html', {'account_msg': '密码不一致', "code": 403})        # 校验密码  check_password()        if not request.user.check_password(old_password):            return render(request, 'user.html', {'account_msg': '密码不正确', "code": 403})        user = request.user        # 修改密码        user.set_password(new_password)        # user.password = make_password(new_password)        # 保存修改        user.save()        # 状态保持        login(request, user)        return redirect(reverse('users:index'))</code></pre><h4 id="实现模板-v3"><a class="header-anchor" href="#实现模板-v3">¶</a>实现模板</h4><pre class=" language-language-html"><code class="language-language-html">{% extends 'base.html' %}{% block body %}    <form action="{% url 'users:user' %}" method="post">        旧密码: <input type="password" name="old_password">        新密码: <input type="password" name="new_password">        确认密码: <input type="password" name="conf_password">        <button name="submit">确认修改</button>        <input type="hidden" name="next" value="{% url 'users:index' %}"/>    </form>{% endblock %}</code></pre><h3 id="首页"><a class="header-anchor" href="#首页">¶</a>首页</h3><h4 id="定义视图-v5"><a class="header-anchor" href="#定义视图-v5">¶</a>定义视图</h4><pre class=" language-language-python"><code class="language-language-python">class IndexView(View):def get(self, request):    return render(request, 'index.html')</code></pre><h4 id="实现模板-v4"><a class="header-anchor" href="#实现模板-v4">¶</a>实现模板</h4><pre class=" language-language-html"><code class="language-language-html">{% extends 'base.html' %}{% block body %}    <h1>欢迎来到首页</h1>{% endblock %}</code></pre><h2 id="配置路由"><a class="header-anchor" href="#配置路由">¶</a>配置路由</h2><p><code>django_demo\urls.py</code>中配置总路由</p><pre class=" language-language-python"><code class="language-language-python">from django.contrib import adminfrom django.urls import path,includeurlpatterns = [    path('admin/', admin.site.urls),    path('users/', include("users.urls","users"))]</code></pre><p><code>users\urls.py</code>中配置子路由</p><pre class=" language-language-python"><code class="language-language-python">from django.urls import pathfrom .views import RegisterView, LoginView, IndexView, LogoutView, UserViewapp_name = "users"urlpatterns = [    path('register/', RegisterView.as_view(), name="register"),    path('login/', LoginView.as_view(), name="login"),    path('logout/', LogoutView.as_view(), name="logout"),    path("user/", UserView.as_view(), name='user'),    path('', IndexView.as_view(), name="index"),]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> auth </tag>
            
            <tag> user </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios(四):跨域请求</title>
      <link href="/2020/03/03/vue-axios-si-kua-yu-qing-qiu/"/>
      <url>/2020/03/03/vue-axios-si-kua-yu-qing-qiu/</url>
      
        <content type="html"><![CDATA[<p>在前后端开发过程中一直会伴随我们的问题就是跨域问题，因为这时候前端和后端的代码是在不同机器上运行的，两个地址不在一个域名下，这个时候前端脚本在进行axios访问的时候浏览器就会报跨域相关的错误。</p><p>原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。</p><h2 id="1-设置代理服务器-实现跨域请求转发"><a class="header-anchor" href="#1-设置代理服务器-实现跨域请求转发">¶</a>1. 设置代理服务器,实现跨域请求转发</h2><p>方案：采用proxyTable解决。</p><ol><li><p>proxyTable是什么？</p><p>vue-cli提供的解决vue开发环境下跨域问题的方法，proxyTable的底层使用了<a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">http-proxy-middleware</a>,它是http代理中间件，它依赖node.js，基本原理是用服务端代理解决浏览器跨域</p><p>实现的过程就是在我们前端的本地起一个服务，然后我们前端的所有ajax访问首选访问我们本地的服务，本地的服务不会对来的请求做加工处理，只是将请求转发到我们真实的后台服务上去。我们本地的服务其实你就是一个中转站。这种解决方案就是利用<strong>后端之间访问是不存在跨域的问题</strong>。</p></li><li><p>具体流程</p><ol><li><p>首先在<code>config/index.js</code>里面找到<code>proxyTable:{}</code>,然后在里面加入</p><pre class=" language-language-javascript"><code class="language-language-javascript">"/api":{    target: 'https://www.runoob.com',    changeOrigin: true,    pathRewrite:{        '^/api':''    }}</code></pre><blockquote><p>注意:</p></blockquote><ul><li><p><code>/api</code>: 是自定义的，写成什么都可以。</p></li><li><p><code>target</code>: 设置要调用的接口域名和端口号。</p></li><li><p><code>^/api</code>: 代替<code>target</code>里面的地址，后面组件中我们调接口时直接用<code>/api</code>代替</p></li></ul></li><li><p>在组件中实现跨域请求</p><ul><li><p>比如要访问<code>'https://www.runoob.com/ajax/json_demo.json'</code>，直接写<code>/api/ajax/json_demo.json</code>即可。</p><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'axios.get('/api/ajax/json_demo.json')    .then(resp=>{        console.log(resp.data)    })    .cath(err=>{        console.log(err)    })</code></pre></li><li><p>然而我们可以在<code>src/main.js</code>设置一个基础路径，这样你调用接口的时候可以不写<code>api</code>,直接写<code>/ajax/json_demo.json</code>即可。</p><ul><li><p>在<code>src/main.js</code>设置<code>axios.defaults.baseURL=&quot;/api&quot;</code>;</p><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'axios.defaults.baseURL="/api";</code></pre></li><li><p>在组件中直接调用接口即可。</p><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'axios.get('/ajax/json_demo.json')    .then(resp=>{        console.log(resp.data)    })    .cath(err=>{        console.log(err)    })</code></pre></li></ul></li></ul></li></ol></li></ol><h2 id="2-在后台django中配置跨域请求允许"><a class="header-anchor" href="#2-在后台django中配置跨域请求允许">¶</a>2. 在后台django中配置跨域请求允许</h2><p>但是今天我们这里不讲这种方式，有兴趣的可以在我的另一篇博客看到</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios(一):axios在vue中的使用教程</title>
      <link href="/2020/03/03/vue-axios-yi-axios-zai-vue-zhong-de-shi-yong-jiao-cheng/"/>
      <url>/2020/03/03/vue-axios-yi-axios-zai-vue-zhong-de-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>在 vue项目中使用axios分为局部使用和全局使用</p><h2 id="在vue中局部使用"><a class="header-anchor" href="#在vue中局部使用">¶</a>在vue中局部使用</h2><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'axios.get('/api/goods/add_info/?ID=12345&firstName=Fred&lastName=Flintstone').then(function (response) {    console.log(response);}).catch(function (error) {    console.log(error);});</code></pre><h2 id="在vue中全部使用"><a class="header-anchor" href="#在vue中全部使用">¶</a>在vue中全部使用</h2><p>axios 是一个基于 promise 的 HTTP 库，所以是不能使用vue.use()方法的。<br>那么难道我们要在每个文件都要来引用一次axios吗？多繁琐！！！<br>☞解决方法有很多种：</p><h3 id="1-结合-vue-axios使用"><a class="header-anchor" href="#1-结合-vue-axios使用">¶</a>1.结合 vue-axios使用</h3><p>看了vue-axios的源码，它是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了</p><ol><li><p>首先在主入口文件main.js中引用：</p><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'import VueAxios from 'vue-axios'Vue.use(VueAxios,axios);</code></pre></li><li><p>之后就可以使用了，在组件文件中的methods里去使用了：</p><pre class=" language-language-javascript"><code class="language-language-javascript">getNewsList(){    this.axios.get('api/getNewsList').then((response)=>{        this.newsList=response.data.data;    }).catch((response)=>{        console.log(response);    })}</code></pre></li></ol><h3 id="2-axios-改写为-Vue-的原型属性（不推荐这样用）"><a class="header-anchor" href="#2-axios-改写为-Vue-的原型属性（不推荐这样用）">¶</a>2.axios 改写为 Vue 的原型属性（不推荐这样用）</h3><ol><li><p>首先在主入口文件main.js中引用，之后挂在vue的原型链上：</p><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'Vue.prototype.$axios= axios</code></pre></li><li><p>在组件中使用</p><pre class=" language-language-javascript"><code class="language-language-javascript">this.$ajax.get('api/getNewsList').then((response)=>{    this.newsList=response.data.data;}).catch((response)=>{    console.log(response);})</code></pre></li></ol><h3 id="3-结合Vuex的action"><a class="header-anchor" href="#3-结合Vuex的action">¶</a>3. 结合Vuex的action</h3><ol><li><p>在vuex的仓库文件store.js中引用，使用action添加方法</p><pre class=" language-language-javascript"><code class="language-language-javascript">import Vue from 'Vue'import Vuex from 'vuex'import axios from 'axios'Vue.use(Vuex)const store = new Vuex.Store({// 定义状态state: {    user: {    name: 'xiaoming'    }},actions: {    // 封装一个 ajax 方法    login (context) {    axios({        method: 'post',        url: '/user',        data: context.state.user    })    }}})export default store</code></pre></li><li><p>在组件中发送请求的时候，需要使用 this.$store.dispatch</p><pre class=" language-language-javascript"><code class="language-language-javascript">methods: {    submitForm () {        this.$store.dispatch('login')    }}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> axios </tag>
            
            <tag> vue-axios </tag>
            
            <tag> 局部axios </tag>
            
            <tag> 全局axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios(三):GET和POST提交数据</title>
      <link href="/2020/03/03/vue-axios-san-get-he-post-ti-jiao-shu-ju/"/>
      <url>/2020/03/03/vue-axios-san-get-he-post-ti-jiao-shu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="GET-请求传递参数"><a class="header-anchor" href="#GET-请求传递参数">¶</a>GET 请求传递参数</h2><h3 id="1、直接在-URL-上添加参数"><a class="header-anchor" href="#1、直接在-URL-上添加参数">¶</a>1、直接在 URL 上添加参数</h3><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'axios.get('/api/goods/add_info/?ID=12345&firstName=Fred&lastName=Flintstone').then(function (response) {    console.log(response);}).catch(function (error) {    console.log(error);});</code></pre><h3 id="2、可以通过-params-设置参数"><a class="header-anchor" href="#2、可以通过-params-设置参数">¶</a>2、可以通过 params 设置参数</h3><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'axios.get('/api/goods/add_info/', {    params: {        ID: 12345,        firstName: 'Fred',        lastName: 'Flintstone',    }}).then(function (response) {    console.log(response);}).catch(function (error) {    console.log(error);});</code></pre><h2 id="POST-请求传递参数"><a class="header-anchor" href="#POST-请求传递参数">¶</a>POST 请求传递参数</h2><h3 id="1、Content-Type-application-json"><a class="header-anchor" href="#1、Content-Type-application-json">¶</a>1、Content-Type: application/json</h3><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'let data = {"code":"1234","name":"yyyy"};axios.post(`${this.$url}/test/testRequest`,data).then(res=>{    console.log('res=>',res);})</code></pre><h3 id="2、Content-Type-multipart-form-data"><a class="header-anchor" href="#2、Content-Type-multipart-form-data">¶</a>2、Content-Type: multipart/form-data</h3><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'let data = new FormData();data.append('code','1234');data.append('name','yyyy');axios.post(`${this.$url}/test/testRequest`,data).then(res=>{    console.log('res=>',res);})</code></pre><h3 id="3、Content-Type-application-x-www-form-urlencoded"><a class="header-anchor" href="#3、Content-Type-application-x-www-form-urlencoded">¶</a>3、Content-Type: application/x-www-form-urlencoded</h3><pre class=" language-language-javascript"><code class="language-language-javascript">import axios from 'axios'import qs from 'Qs'let data = {"code":"1234","name":"yyyy"};axios.post(`${this.$url}/test/testRequest`,qs.stringify({    data})).then(res=>{    console.log('res=>',res);})</code></pre><p>总结：<br>1、上面三种方式会对应后台的请求方式，这个也要注意，比如django POST参数获取</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> axios </tag>
            
            <tag> GET </tag>
            
            <tag> POST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios(二):API说明</title>
      <link href="/2020/03/03/vue-axios-er-api-shuo-ming/"/>
      <url>/2020/03/03/vue-axios-er-api-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h2 id="Axios-API"><a class="header-anchor" href="#Axios-API">¶</a>Axios API</h2><ol><li><p>可以通过向 axios 传递相关配置来创建请求</p><ul><li><p>axios配置全部参数</p><pre class=" language-language-javascript"><code class="language-language-javascript">axios(config)</code></pre><pre class=" language-language-javascript"><code class="language-language-javascript">// 发送 POST 请求axios({    method: 'post',    url: '/user/12345',    data: {    firstName: 'Fred',    lastName: 'Flintstone'    }});</code></pre></li><li><p>axios中指定url和参数配置</p><pre class=" language-language-javascript"><code class="language-language-javascript">axios(url[, config])</code></pre><pre class=" language-language-javascript"><code class="language-language-javascript">// 发送 GET 请求（默认的方法）axios('/user/12345');</code></pre><pre class=" language-language-javascript"><code class="language-language-javascript">// 发送 POST 请求axios('/user/12345', {    method: 'post',    data: {    firstName: 'Fred',    lastName: 'Flintstone'    }});</code></pre></li></ul></li><li><p>请求方法的别名</p><ul><li><p>为方便起见，为所有支持的请求方法提供了别名</p><pre class=" language-language-javascript"><code class="language-language-javascript">axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])</code></pre><blockquote><p>NOTE:在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p></blockquote></li><li><p>axios请求方法</p><pre class=" language-language-javascript"><code class="language-language-javascript">// 发送 POST 请求axios.post('/user/12345',{    firstName: 'Fred',    lastName: 'Flintstone'});</code></pre></li></ul></li><li><p>并发</p><ul><li><p>处理并发请求的助手函数</p><pre class=" language-language-javascript"><code class="language-language-javascript">axios.all(iterable)axios.spread(callback)</code></pre></li><li><p>执行多个并发请求</p><pre class=" language-language-javascript"><code class="language-language-javascript">function getUserAccount() {    return axios.get('/user/12345');}function getUserPermissions() {    return axios.get('/user/12345/permissions');}axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) {    // 两个请求现在都执行完成}));</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> axios </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主键约束和唯一性约束的区别</title>
      <link href="/2020/02/26/shu-ju-ku-mysql-zhu-jian-yue-shu-he-wei-yi-xing-yue-shu-de-qu-bie/"/>
      <url>/2020/02/26/shu-ju-ku-mysql-zhu-jian-yue-shu-he-wei-yi-xing-yue-shu-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>主键必然是唯一且不为空，但是唯一不一定是主键，而且主键只能有一个，但是唯一约束仅仅是为了保持某些列具有唯一性而已。所以可以有多列<br>一张表里只能有一个主键约束，可以有多个唯一约束<br>主键约束的字段不能为null，而唯一约束的字段可以为null值</p><a id="more"></a><h3 id="主键约束（PRIMARY-KEY）"><a class="header-anchor" href="#主键约束（PRIMARY-KEY）">¶</a>主键约束（PRIMARY KEY）</h3><ol><li>主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。</li><li>是不可能（或很难）更新．</li><li>主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）．</li><li>主健可作外健，唯一索引不可；</li></ol><h3 id="唯一性约束（UNIQUE）"><a class="header-anchor" href="#唯一性约束（UNIQUE）">¶</a>唯一性约束（UNIQUE）</h3><ol><li>唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段，一个表上可以放置多个唯一性约束．</li><li>只要唯一就可以更新．</li><li>即表中任意两行在 指定列上都不允许有相同的值，允许空（NULL）．</li><li>一个表上可以放置多个唯一性约束</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主键约束 </tag>
            
            <tag> 唯一约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql操作</title>
      <link href="/2019/12/12/shu-ju-ku-mysql-cao-zuo/"/>
      <url>/2019/12/12/shu-ju-ku-mysql-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>介绍如何在 Ubuntu系统上 安装mysql软件、以及如何创建用户信息。</p><a id="more"></a><h3 id="Mysql软件操作"><a class="header-anchor" href="#Mysql软件操作">¶</a>Mysql软件操作</h3><p>以下所有操作以Ubuntu为例</p><h4 id="mysql安装"><a class="header-anchor" href="#mysql安装">¶</a>mysql安装</h4><pre class=" language-language-bash"><code class="language-language-bash">sudo apt install mysql-server # 安装mysql</code></pre><h4 id="mysql删除"><a class="header-anchor" href="#mysql删除">¶</a>mysql删除</h4><pre class=" language-language-bash"><code class="language-language-bash">sudo apt remove --upgrade mysql-* -y # 卸载mysqldpkg -l|grep ^rc|awk '{print$2}'|sudo xargs dpkg -P #清除配置</code></pre><h4 id="mysql服务"><a class="header-anchor" href="#mysql服务">¶</a>mysql服务</h4><pre class=" language-language-bash"><code class="language-language-bash">service mysql start # 启动服务service mysql stop  # 停止服务service mysql restart  # 重启服务</code></pre><h3 id="mysql用户操作"><a class="header-anchor" href="#mysql用户操作">¶</a>mysql用户操作</h3><h4 id="一、创建用户"><a class="header-anchor" href="#一、创建用户">¶</a>一、创建用户</h4><pre class=" language-language-sql"><code class="language-language-sql">create user 'username'@'host' identified with mysql_native_password BY 'password';</code></pre><ul><li><code>username</code>：你将创建的用户名</li><li><code>host</code>：指定该用户在哪个主机上可以登陆，如果是本地用户可用<code>localhost</code>，如果想让该用户可以从任意远程主机登陆，可以使用通配符<code>%</code></li><li><code>password</code>：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li><li><code>mysql_native_password</code>：用户加密方式，该方式为mysql8.0之前的加密方式，如果不写，则是mysql 8.0之后的加密方式<code>caching_sha2_password</code></li></ul><h4 id="二、-修改用户信息"><a class="header-anchor" href="#二、-修改用户信息">¶</a>二、 修改用户信息</h4><pre class=" language-language-sql"><code class="language-language-sql">alter user 'username'@'host' identified with mysql_native_password BY 'password';</code></pre><ul><li>参数同上</li></ul><h4 id="三、删除用户"><a class="header-anchor" href="#三、删除用户">¶</a>三、删除用户</h4><pre class=" language-language-sql"><code class="language-language-sql">drop user 'username'@'host';</code></pre><ul><li>参数同上</li></ul><h4 id="四、授权"><a class="header-anchor" href="#四、授权">¶</a>四、授权</h4><pre class=" language-language-sql"><code class="language-language-sql">grant privileges on databasename.tablename to 'username'@'host';</code></pre><ul><li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</li><li>其余参数同上</li></ul><h4 id="五、删除权限"><a class="header-anchor" href="#五、删除权限">¶</a>五、删除权限</h4><pre class=" language-language-sql"><code class="language-language-sql">revoke privileges on databasename.tablename to 'username'@'host';</code></pre><ul><li>参数同上</li></ul><h4 id="六、演示"><a class="header-anchor" href="#六、演示">¶</a>六、演示</h4><pre class=" language-language-sql"><code class="language-language-sql"># 创建一个可以从任意远程主机登陆的用户testcreate user 'test'@'%' identified with mysql_native_password BY '123456';# 创建数据库mydatacreate database mydata charset=utf8;# 对用户test授权，只能操作数据库mydatagrant all on mydata.* to 'test'@'%';# 刷新配置，立即启用修改flush privileges;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户管理 </tag>
            
            <tag> mysql软件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json模块</title>
      <link href="/2019/11/25/python-mo-kuai-json-mo-kuai/"/>
      <url>/2019/11/25/python-mo-kuai-json-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h3 id="JSON介绍"><a class="header-anchor" href="#JSON介绍">¶</a>JSON介绍</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。</p><h4 id="JSON-语法规则"><a class="header-anchor" href="#JSON-语法规则">¶</a>JSON 语法规则</h4><p>JSON是一个标记符的序列。<br>JSON是一个序列化的对象或数组。</p><h4 id="JSON-与-JS-对象的关系"><a class="header-anchor" href="#JSON-与-JS-对象的关系">¶</a>JSON 与 JS 对象的关系</h4><p>很多人搞不清楚 JSON 和 JS 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：<br><strong>JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</strong><br>如</p><pre class=" language-language-javascript"><code class="language-language-javascript">var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的var json = '{"a": "Hello", "b": "World"}'; //这是一个 JSON 字符串，本质是一个字符串</code></pre><h4 id="JSON-和-JS-对象互转"><a class="header-anchor" href="#JSON-和-JS-对象互转">¶</a>JSON 和 JS 对象互转</h4><p>要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法：</p><pre class=" language-language-javascript"><code class="language-language-javascript">var obj = JSON.parse('{"a": "Hello", "b": "World"}'); //结果是 {a: 'Hello', b: 'World'}</code></pre><p>要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：</p><pre class=" language-language-javascript"><code class="language-language-javascript">var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{"a": "Hello", "b": "World"}'</code></pre><h4 id="JSON-和-PYTHON-对象互转"><a class="header-anchor" href="#JSON-和-PYTHON-对象互转">¶</a>JSON 和 PYTHON 对象互转</h4><p>要实现从JSON字符串转换为Python对象，使用 json.loads() 方法：</p><pre class=" language-language-python"><code class="language-language-python">import jsona_dict = json.loads('{"a": "Hello", "b": "World"}') //结果是 {'a': 'Hello', 'b': 'World'}b_list = json.loads('[1, 2, 3, 4]') //结果是 [1, 2, 3, 4]</code></pre><p>要实现从Python对象转换为JSON字符串，使用 json.dumps() 方法：</p><pre class=" language-language-python"><code class="language-language-python">import jsona_obj = json.dumps({a: 'Hello', b: 'World'}) //结果是 '{"a": "Hello", "b": "World"}'b_obj = json.dumps([1, 2, 3, {"a":7}]) //结果是 '[1, 2, 3, {"a": 7}]'</code></pre><p>要实现从Python对象转换为JSON字符串，并写入到json文件中，使用 json.dump() 方法：</p><pre class=" language-language-python"><code class="language-language-python">import jsona_obj = '[12, 34, 56]'with open("1.json", "w") as f:json.dump(a_obj,f)</code></pre><p>要实现从json文件中读取JSON字符串，并转换为Python对象，使用 json.load() 方法：</p><pre class=" language-language-python"><code class="language-language-python">import jsonwith open('1.json', "r") as f:a_str = json.load(f)print(a_str)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> Python </tag>
            
            <tag> 字典 </tag>
            
            <tag> 列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程</title>
      <link href="/2019/11/04/python-mian-xiang-dui-xiang-ji-chu/"/>
      <url>/2019/11/04/python-mian-xiang-dui-xiang-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="类与实例"><a class="header-anchor" href="#类与实例">¶</a>类与实例</h2><p>面向对象最重要的概念就是类（<code>Class</code>）和实例（<code>Instance</code>），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p><p>仍以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p><pre class=" language-language-python"><code class="language-language-python">class Student(object):    pass</code></pre><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>的实例，创建实例是通过<code>类名+()</code>实现的：</p><pre class=" language-language-python"><code class="language-language-python">In [5]: s = Student()In [6]: sOut[6]: <__main__.Student at 0x107615860>In [7]: StudentOut[7]: <class '__main__.Student'></code></pre><p>可以看到，变量<code>s</code>指向的就是一个<code>Student</code>的实例，后面的<code>0x107615860</code>是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类。</p><p>可以自由地给一个实例变量绑定属性，比如，给实例<code>s</code>绑定一个<code>name</code>属性：</p><pre class=" language-language-python"><code class="language-language-python">In [9]: s.name = 'Bart Simpson'In [10]: s.nameOut[10]: 'Bart Simpson'</code></pre><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><pre class=" language-language-python"><code class="language-language-python">class Student(object):    def __init__(self, name, score):        self.name = name        self.score = score</code></pre><blockquote><p>注意：特殊方法“<strong>init</strong>”前后分别有两个下划线！！！</p></blockquote><p>注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p><p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p><pre class=" language-language-python"><code class="language-language-python">In [14]: class Student(object):    ...:    ...:     def __init__(self, name, score):    ...:         self.name = name    ...:         self.score = score    ...:In [15]: s = Student('Bart Simpson', 59)In [16]: s.nameOut[16]: 'Bart Simpson'In [17]: s.scoreOut[17]: 59</code></pre><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h2 id="数据封装"><a class="header-anchor" href="#数据封装">¶</a>数据封装</h2><p>面向对象编程的一个重要特点就是数据封装。在上面的<code>Student</code>类中，每个实例就拥有各自的<code>name</code>和<code>score</code>这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p><pre class=" language-language-python"><code class="language-language-python">In [19]: def print_score(std):    ...:     print('%s: %s' % (std.name, std.score))    ...:In [20]: print_score(s)Bart Simpson: 59</code></pre><p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p><pre class=" language-language-python"><code class="language-language-python">In [23]: class Student(object):    ...:    ...:     def __init__(self, name, score):    ...:         self.name = name    ...:         self.score = score    ...:    ...:     def print_score(self):    ...:         print('%s: %s' % (self.name, self.score))    ...:</code></pre><p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p><pre class=" language-language-python"><code class="language-language-python">In [24]: s = Student('Bart Simpson', 59)In [25]: s.print_score()Bart Simpson: 59</code></pre><p>这样一来，我们从外部看<code>Student</code>类，就只需要知道，创建实例需要给出<code>name</code>和<code>score</code>，而如何打印，都是在<code>Student</code>类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p><p>封装的另一个好处是可以给<code>Student</code>类增加新的方法，比如<code>get_grade</code>：</p><pre class=" language-language-python"><code class="language-language-python">class Student(object):    def __init__(self, name, score):        self.name = name        self.score = score    def get_grade(self):        if self.score >= 90:            return 'A'        elif self.score >= 60:            return 'B'        else:            return 'C' </code></pre><p>同样的，<code>get_grade</code>方法可以直接在实例变量上调用，不需要知道内部实现细节</p><pre class=" language-language-python"><code class="language-language-python">lisa = Student('Lisa', 99)bart = Student('Bart', 59)print(lisa.name, lisa.get_grade())print(bart.name, bart.get_grade())</code></pre><h2 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h2><ul><li>在程序中，继承描述的是多个类之间的所属关系。</li><li>如果一个类A里面的属性和方法可以复用，则可以通过继承的方式，传递到类B里。那么类A就是基类，也叫做父类；类B就是派生类，也叫做子类。</li></ul><h3 id="1-单继承"><a class="header-anchor" href="#1-单继承">¶</a>1. 单继承</h3><blockquote><p>子类A只继承了一个父类B, 那么此时两者之间的关系就是单继承</p></blockquote><ul><li><p>单继承，子类直接继承父类的<code>__init__</code>方法</p><pre class=" language-language-python"><code class="language-language-python">class User(object):  # 创建用户类    def __init__(self, name):  # 给用户添加属性：name        self.name = nameclass VipUser(User):    # 子类继承父类的__init__方法，添加name属性    passvip = VipUser("xw")  # vip初始化时，自己本身没有实现__init__方法,而是直接调用继承自User的__init__方法，vip有name属性print(vip.name)</code></pre></li><li><p>单继承，子类自己实现<code>__init__</code>方法</p><pre class=" language-language-python"><code class="language-language-python">class User():  # 创建用户类    def __init__(self, name):  # 给用户添加属性：name        self.name = nameclass VipUser(User):    # 子类自己实现__init__方法，并没有直接使用继承父类的__init__方法    def __init__(self, name):  # 给vip用户添加属性：name        self.name = namevip = VipUser("xw")  # vip初始化时，自己本身没有实现__init__方法,而是直接调用继承自User的__init__方法，vip有name属性print(vip.name)</code></pre></li><li><p>单继承，子类在自己实现的<code>__init__</code>方法中，还调用了父类的<code>__init__</code>方法</p><pre class=" language-language-python"><code class="language-language-python"># 对象初始化，__init__方法只会执行一次class User():  # 创建用户类    def __init__(self, name):  # 给用户添加属性：name        self.name = nameclass VipUser(User):    def __init__(self, name, money):        # self.name = name        # User.__init__(self)   # 通过父类名直接调用父类的__init__方法实现name属性的添加        super().__init__(name)  # 通过super()调用父类的__init__方法添加name属性        self.money = money  # 自己添加money属性vip = VipUser("xw", 300)  # vip初始化时，__init__方法执行一次print(vip.name, vip.money)</code></pre></li></ul><h3 id="2-多继承"><a class="header-anchor" href="#2-多继承">¶</a>2. 多继承</h3><blockquote><p>多继承可以继承多个父类，也继承了所有父类的属性和方法</p></blockquote><ul><li><p>如果多个父类中有同名的 属性和方法，则默认使用第一个父类的属性和方法（根据类的魔法属性<code>__mro__</code>的顺序来查找）</p></li><li><p>多个父类中，不重名的属性和方法，不会有任何影响。</p><pre class=" language-language-python"><code class="language-language-python">class A():    def __init__(self):        self.name = "A"class B():    def __init__(self):        self.name = "B"class C(A, B):    passc = C()print(C.mro())  # [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]print(c.name)  # A</code></pre></li></ul><h3 id="3-多层继承"><a class="header-anchor" href="#3-多层继承">¶</a>3. 多层继承</h3><blockquote><p>多层继承主要说的是<code>super</code>的搜索顺序,而搜索顺序主要是根据类的魔法属性<code>__mro__</code>的顺序来查找</p></blockquote><ul><li><p><code>super()</code>调用方法顺序示例</p><pre class=" language-language-python"><code class="language-language-python">class A():    def run(self):        print(">>>A<<<")class B1(A):    def run(self):        print(">>>B1<<<")        super().run()        class B2(A):    def run(self):        print(">>>B2<<<")        super().run()        class C(B1, B2):    def run(self):        print(">>>C<<<")        super().run()        c= C()print(C.mro())c.run()</code></pre><blockquote><p>程序运行结果：</p></blockquote><pre class=" language-language-shell"><code class="language-language-shell">[<class '__main__.C'>, <class '__main__.B1'>, <class '__main__.B2'>, <class '__main__.A'>, <class 'object'>]>>>C<<<>>>B1<<<>>>B2<<<>>>A<<<</code></pre></li><li><p>参数传递示例</p><pre class=" language-language-python"><code class="language-language-python">class Father(object):    def __init__(self, name):        print('father')        self.name = nameclass Son1(Father):    def __init__(self, name, age, *args):        print('Son1')        self.age = age        super().__init__(name, *args)class Son2(Father):    def __init__(self, name, gender):        print('Son2')        self.gender = gender        super().__init__(name)class Grandson(Son1, Son2):    def __init__(self, name, age, gender):        print("Grandson")        super().__init__(name, age, gender)print(Grandson.mro())print("+" * 30)grand_son = Grandson('王明', 14, '男')print("+" * 30)print(grand_son.name, grand_son.age, grand_son.gender)</code></pre><blockquote><p>程序运行结果：</p></blockquote><pre class=" language-language-shell"><code class="language-language-shell">++++++++++++++++++++++++++++++GrandsonSon1Son2father++++++++++++++++++++++++++++++王明 14 男</code></pre></li></ul><h2 id="多态"><a class="header-anchor" href="#多态">¶</a>多态</h2><h3 id="1-多态"><a class="header-anchor" href="#1-多态">¶</a>1. 多态</h3><p>所谓的多态就是同一类事物有不同的形态,(一个抽象类有多个子类，因而多态的概念依赖于继承)</p><ul><li>序列类型有多种形态：字符串，列表，元组</li><li>动物有多种形态：猫，狗</li></ul><pre class=" language-language-python"><code class="language-language-python"># 多态：同一种事物的多种形态，动物分为猫类，狗类（在定义角度）class Animal():    def __init__(self, name, foods):        self.name = name        self.foods = foods    def eat(self):        print("%s的食物是%s" % (self.name, self.foods))    def run(self):        print("%s跑的很快" % self.name)    def call(self):        passclass Dog(Animal):    def call(self):        print("%s:汪汪大叫" % self.name)class Cat(Animal):    def call(self):        print("%s:喵喵大叫" % self.name)dog = Dog("哈士奇", "狗粮")dog.eat()dog.call()cat = Cat("九命妖猫", "仙露")cat.eat()cat.run()</code></pre><h3 id="2-多态性"><a class="header-anchor" href="#2-多态性">¶</a>2. 多态性</h3><blockquote><p>什么是多态性（注意：多态与多态性是两种概念）</p></blockquote><ul><li>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。</li><li>在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。</li><li>也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</li></ul><pre class=" language-language-python"><code class="language-language-python"># 多态性依赖于：继承##多态性：定义统一的接口，#多态性：一种调用方式，不同的执行效果（多态性）def func(obj): # obj这个参数没有类型限制，可以传入不同类型的值obj.eat()  #调用的逻辑都一样，执行的结果却不一样func(dog)func(cat)</code></pre><blockquote><p>为什么要用多态性（多态性的好处）</p></blockquote><p>其实大家从上面多态性的例子可以看出，我们并没有增加上面新的知识，也就是说Python本身就是支持多态性的，这么做的好处是什么呢？</p><ul><li>增加了程序的灵活性<br>以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal)</li><li>增加了程序额可扩展性<br>通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用</li></ul><blockquote><ul><li>多态：同一种事物的多种形态，动物分为猫类，狗类（在定义角度）</li><li>多态性：一种调用方式，不同的执行效果（多态性）</li></ul></blockquote><h2 id="类型判断"><a class="header-anchor" href="#类型判断">¶</a>类型判断</h2><h2 id="访问权限"><a class="header-anchor" href="#访问权限">¶</a>访问权限</h2><h2 id="实例属性与类属性"><a class="header-anchor" href="#实例属性与类属性">¶</a>实例属性与类属性</h2><h2 id="实例方法、静态方法与类方法"><a class="header-anchor" href="#实例方法、静态方法与类方法">¶</a>实例方法、静态方法与类方法</h2><h3 id="1-方法分类"><a class="header-anchor" href="#1-方法分类">¶</a>1. 方法分类</h3><p>先看语法，<code>python</code> 类语法中有三种方法，实例方法，静态方法，类方法。</p><blockquote><p><code>python</code>中<code>self</code>，<code>cls</code>的区别:</p></blockquote><ul><li>普通实例方法，第一个参数需要是<code>self</code>，它表示一个具体的实例本身。</li><li>如果用了<code>staticmethod</code>，那么就可以无视这个<code>self</code>，而将这个方法当成一个普通的函数使用。</li><li>而对于<code>classmethod</code>，它的第一个参数不是<code>self</code>，是<code>cls</code>，它表示这个类本身。</li></ul><pre class=" language-language-python"><code class="language-language-python"># coding:utf-8class Foo(object):    """类三种方法语法形式"""    def instance_method(self):        print("是类{}的实例方法，只能被实例对象调用".format(Foo))    @staticmethod    def static_method():        print("是静态方法")    @classmethod    def class_method(cls):        print("是类方法")foo = Foo()foo.instance_method()foo.static_method()foo.class_method()print('----------------')Foo.static_method()Foo.class_method()</code></pre><p>运行结果：</p><pre class=" language-language-shell"><code class="language-language-shell">是类<class '__main__.Foo'>的实例方法，只能被实例对象调用是静态方法是类方法----------------是静态方法是类方法</code></pre><blockquote><p>说明</p></blockquote><ul><li>调用<ul><li>实例方法只能被实例对象调用</li><li>静态方法(由<code>@staticmethod</code>装饰的方法)、类方法(由<code>@classmethod</code>装饰的方法)，可以被类或类的实例对象调用。</li></ul></li><li>参数<ul><li>实例方法，第一个参数必须要默认传实例对象，一般习惯用<code>self</code>。</li><li>静态方法，参数没有要求。</li><li>类方法，第一个参数必须要默认传类，一般习惯用<code>cls</code>。</li></ul></li></ul><h3 id="2-方法调用"><a class="header-anchor" href="#2-方法调用">¶</a>2. 方法调用</h3><blockquote><p>静态方法调用另一个静态方法，如果改用类方法调用静态方法，可以让<code>cls</code>代替类，让代码看起来精简一些。也防止类名修改了，不用在类定义中修改原来的类名。</p></blockquote><pre class=" language-language-python"><code class="language-language-python"># coding:utf-8class Foo(object):    X = 1    Y = 2    @staticmethod    def averag(*mixes):        return sum(mixes) / len(mixes)    @staticmethod    def static_method():  # 在静态方法中调用静态方法        print("在静态方法中调用静态方法")        return Foo.averag(Foo.X, Foo.Y)    @classmethod    def class_method(cls):  # 在类方法中使用静态方法        print("在类方法中使用静态方法")        return cls.averag(cls.X, cls.Y)foo = Foo()print(foo.static_method())print(foo.class_method())</code></pre><blockquote><p>运行结果：</p></blockquote><pre class=" language-language-shell"><code class="language-language-shell">在静态方法中调用静态方法1.5在类方法中使用静态方法1.5</code></pre><h3 id="3-继承类中的区别"><a class="header-anchor" href="#3-继承类中的区别">¶</a>3.继承类中的区别</h3><p>从下面代码可以看出，如果子类继承父类的方法，子类覆盖了父类的静态方法:</p><ul><li>子类的实例继承了父类的<code>static_method</code>静态方法，调用该方法，还是调用的父类的方法和类属性。</li><li>子类的实例继承了父类的<code>class_method</code>类方法，调用该方法，调用的是子类的方法和子类的类属性。</li></ul><pre class=" language-language-python"><code class="language-language-python">class Foo(object):    X = 1    Y = 14    @staticmethod    def averag(*mixes):  # "父类中的静态方法"        return sum(mixes) / len(mixes)    @staticmethod    def static_method():  # "父类中的静态方法"        print("父类中的静态方法")        return Foo.averag(Foo.X, Foo.Y)    @classmethod    def class_method(cls):  # 父类中的类方法        print("父类中的类方法")        return cls.averag(cls.X, cls.Y)class Son(Foo):    X = 3    Y = 5    @staticmethod    def averag(*mixes):  # "子类中重载了父类的静态方法"        print("子类中重载了父类的静态方法")        return sum(mixes) / len(mixes)p = Son()print("result of p.averag(1,5)")print(p.averag(1, 5))print("result of p.static_method()")print(p.static_method())print("result of p.class_method()")print(p.class_method())</code></pre><blockquote><p>运行结果：</p></blockquote><pre class=" language-language-python"><code class="language-language-python">result of p.averag(1,5)子类中重载了父类的静态方法3.0result of p.static_method()父类中的静态方法7.5result of p.class_method()父类中的类方法子类中重载了父类的静态方法4.0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中varbinary、binary、char、varchar异同</title>
      <link href="/2019/06/01/shu-ju-ku-mysql-zhong-varbinary-binary-char-varchar-yi-tong/"/>
      <url>/2019/06/01/shu-ju-ku-mysql-zhong-varbinary-binary-char-varchar-yi-tong/</url>
      
        <content type="html"><![CDATA[<p>binary 与 varbinary 类型和char与varchar类型是相似的，只是他们存储的是二进制数据，也就是说他们是包含字节流而不是字符流，他们有二进制字符的集合和顺序，他们的对比，排序是基于字节的数值进行的</p><p>binary与varbinary的最大长度和char与varchar是一样的，只不过他们是定义<strong>字节长度</strong>，而char和varchar对应的是<strong>字符长度</strong>。</p><a id="more"></a><h4 id="存储和取出时对尾部空格的处理"><a class="header-anchor" href="#存储和取出时对尾部空格的处理">¶</a>存储和取出时对尾部空格的处理</h4><ul><li><p>char(N)用来存储非二进制字符串，插入时，对于少于N个字符的会自动在尾部加空格，查询时，尾部的空格就会被丢弃掉</p></li><li><p>vachar(N) 用来存储非二进制字符串，插入时，对于少于N个字符的不填补空格，查询时，尾部的空格不会被丢弃掉</p></li><li><p>binary(N)存储二进制字符串，插入进，少于N个字节的会自动在尾部加0x00，取出时，所有的字节都保留，返回定义长度的字节长度，在比较的时候，所有的字节都是有效的，并且0x00&lt;space (space对应的是0x20)</p></li><li><p>varbinary在插入不会去填补0x00字节，查询的时候也不会丢弃任何字节，在比较的时候，所有的字节都是有效的，并且0x00&lt;space (space对应的是0x20)</p></li></ul><h4 id="大小比较时"><a class="header-anchor" href="#大小比较时">¶</a>大小比较时</h4><p>char与varchar的字符比较中，是忽略大小写与最后的空格的，如：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select 'a'='a ' , 'a'='A' , 'a'='A ';+----------+---------+----------+| 'a'='a ' | 'a'='A' | 'a'='A ' |+----------+---------+----------+|        1 |       1 |        1 |+----------+---------+----------+1 row in set (0.00 sec)</code></pre><p>而binary及varbinary的字节比较中，所有的信息都不会被忽略，如：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table t (c BINARY(3));Query OK, 0 rows affected (0.01 sec)mysql> insert into t set c = 'a';Query OK, 1 row affected (0.01 sec)mysql> select hex(c), c = 'a', c = 'a\0\0' from t;+--------+---------+-------------+| HEX(c) | c = 'a' | c = 'a\0\0' |+--------+---------+-------------+| 610000 |       0 |           1 |+--------+---------+-------------+1 row in set (0.08 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> varbinary </tag>
            
            <tag> binary </tag>
            
            <tag> char </tag>
            
            <tag> varchar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中的Decimal类型说明</title>
      <link href="/2019/06/01/shu-ju-ku-mysql-zhong-de-decimal-lei-xing-shuo-ming/"/>
      <url>/2019/06/01/shu-ju-ku-mysql-zhong-de-decimal-lei-xing-shuo-ming/</url>
      
        <content type="html"><![CDATA[<p>我们在Mysql中存字段的时候，比如，一些与金钱有关的数据。这个时候就会对精确到的要求非常高。那么这个时候，就会发现我们之前所学的八大基本类型不再能够满足需求，无论是整形还是浮点型，有人会说存整形有什么不可，但是你要知道不是每个人的金额都是整数的；这样不行的话，存浮点型的就可以了嘛，对于银行存钱来说，一个小数点的问题都会将一笔钱的金额变得很大或者很小…So，这个时候你可以尝试一下Decimal类型，你会发现能够很好地解决你的问题。</p><a id="more"></a><h3 id="decimal详细介绍："><a class="header-anchor" href="#decimal详细介绍：">¶</a>decimal详细介绍：</h3><p><strong>decimal(a,b)</strong></p><ul><li><p>参数说明：</p><ul><li><p>a:指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度为38.</p></li><li><p>b:指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从0~a之间的值，默认小数位数是0.</p></li></ul></li><li><p>举例说明，11615.23653234568这个数存你说的三个格式</p><ul><li>decimal：11615</li><li>decimal(3)：999</li><li>decdimal(3,2)：9.99</li><li>decimal(10,5)11615.23653<br><strong>超出精度范围的数会被强制进位并只显示数据类型定义的格式</strong></li></ul></li><li><p>备注：</p><p>decimal数据类型用于要求非常高的精确计算中，这些类型允许指定数值的精确度和计算方法作为选择参数。精确度在这里指为这个值保存的有效数字的总个数。而计数方法指的是小数点后数字的个数。例如：decimal(5,2)规定了存储的值将不会超过五位数字 ，而且小数点后面有两位数字。</p></li></ul><h4 id="实例1："><a class="header-anchor" href="#实例1：">¶</a>实例1：</h4><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table t1(c1 float(10,2), c3decimal(10,2));Query OK, 0 rows affected (0.02 sec)mysql> insert into t1 values(9876543.21, 9876543.12);Query OK, 1 row affected (0.00 sec)mysql> select * from t1;+------------+------------+| c1         | c3         |+------------+------------+| 9876543.00 | 9876543.12 |+------------+------------+1 row in set (0.00 sec)</code></pre><p><strong>      会发现，flocat类型的字段会自动将值四舍五入，而decimal类型的不会，如果用flocat类型的去存与金额有关的数据的时候就会出现问题，而decimal类型的就不会。</strong></p><h4 id="实例2：decimal-5-2"><a class="header-anchor" href="#实例2：decimal-5-2">¶</a>实例2：decimal(5,2)</h4><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table t1(id1 float(5,2) default null,id2 double(5,2) default null,id3 decimal(5,2) default null );Query OK, 0 rows affected (0.03 sec)mysql> insert into t1 values(1.2345,1.2345,1.2345);Query OK, 1 row affected, 1 warning (0.04 sec)mysql> show warnings;+-------+------+------------------------------------------+| Level | Code | Message                                  |+-------+------+------------------------------------------+| Note  | 1265 | Data truncated for column 'id3' at row 1 |+-------+------+------------------------------------------+1 row in set (0.00 sec)</code></pre><ul><li><p>1.2345 — 小数点后最多2位，所以保存可以，自动四舍五入数据截断,但会报waning</p></li><li><p>12.34 — OK</p></li><li><p>1234.5 — 因为小数部分未满2位，要补0.所以保存应该1234.50。所以整个位数超出了5，保存报错。</p></li><li><p>1.2 — 小数未满部分补0。按照1.20保存。</p></li></ul><h3 id="默认状态比较："><a class="header-anchor" href="#默认状态比较：">¶</a>默认状态比较：</h3><ul><li>浮点数<ul><li>如果不写精度和标度，会按照实际精度值保存</li><li>如果有精度和标度，则会自动将四舍五入后的结果插入，系统不会报错</li></ul></li><li>定点数<ul><li>如果不写精度和标度，则按照默认值decimal(10,0)来操作</li><li>如果数据超过了精度和标度值，系统会报错</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> float </tag>
            
            <tag> decimal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库笔记</title>
      <link href="/2019/05/27/shu-ju-ku-mysql-bi-ji/"/>
      <url>/2019/05/27/shu-ju-ku-mysql-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>学习数据库安装后，最重要的就是学习SQL语句。</p><a id="more"></a><h3 id="1-数据语句操作类型"><a class="header-anchor" href="#1-数据语句操作类型">¶</a>1. 数据语句操作类型</h3><p>SQL是操作数据库的核心，</p><p>结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。</p><p>SQL是最重要的关系数据库操作语言，并且它的影响已经超出数据库领域，得到其他领域的重视和采用，如人工智能领域的数据检索等。</p><p>SQL是关系模型的数据库应用语言，由IBM在20世纪70年代为其关系型数据库 System R 所开发。</p><p>SQL 是1986年10 月由美国国家标准局（ANSI）通过的数据库语言美国标准，接着，国际标准化组织（ISO）颁布了SQL正式国际标准。1989年4月，ISO提出了具有完整性特征的SQL89标准，1992年11月又公布了SQL92标准。</p><p>虽然各个数据库系统略有不同，但是他们基本均遵循SQL 92标准。或者在SQL 92上做了一些简单的扩展和变化。</p><p>学好了MySQL 的SQL 语法，其他的SQL语法学习起来均是万变不离其中。</p><p>SQL语句按照其功能范围不同可分为3个类别：</p><ol><li><strong>数据定义语言</strong>(DDL ，Data Defintion Language)语句：数据定义语句，用于定义不同的数据段、数据库、表、列、索引等。常用的语句关键字包括create、drop、alter等。</li><li><strong>数据操作语言</strong>(DML ， Data Manipulation Language)语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据的完整性。常用的语句关键字主要包括insert、delete、update和select等。</li><li><strong>数据控制语言</strong>(DCL， Data Control Language)语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括grant、revoke等。</li></ol><h3 id="2-管理数据库命令"><a class="header-anchor" href="#2-管理数据库命令">¶</a>2. 管理数据库命令</h3><h4 id="元数据"><a class="header-anchor" href="#元数据">¶</a>元数据</h4><p>以下命令语句可以在 MySQL 的命令提示符使用，获取服务器元数据</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">select version( )</td><td style="text-align:left">服务器版本信息</td></tr><tr><td style="text-align:center">select database( )</td><td style="text-align:left">当前数据库名 (或者返回空)</td></tr><tr><td style="text-align:center">select user( )</td><td style="text-align:left">当前用户名</td></tr><tr><td style="text-align:center">show status</td><td style="text-align:left">服务器状态</td></tr><tr><td style="text-align:center">show variables</td><td style="text-align:left">服务器配置变量</td></tr></tbody></table><h4 id="创建数据库"><a class="header-anchor" href="#创建数据库">¶</a>创建数据库</h4><ul><li>create database 数据库名:<br>创建数据库</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> create database data_test;Query OK, 1 row affected (0.01 sec)</code></pre><h4 id="删除数据库"><a class="header-anchor" href="#删除数据库">¶</a>删除数据库</h4><ul><li>drop database 数据库名:<br>删除数据库</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> drop database data_test;Query OK, 0 rows affected (0.01 sec)</code></pre><h4 id="展示所有数据库"><a class="header-anchor" href="#展示所有数据库">¶</a>展示所有数据库</h4><ul><li>show databases:<br>列出 MySQL 数据库管理系统的数据库列表。</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> show databases;+--------------------+| Database           |+--------------------+| data_test          || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.01 sec)</code></pre><h4 id="改变数据库"><a class="header-anchor" href="#改变数据库">¶</a>改变数据库</h4><ul><li>use 数据库名 :<br>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> use data_test;Database changed</code></pre><h4 id="展示当前数据库中所有的表"><a class="header-anchor" href="#展示当前数据库中所有的表">¶</a>展示当前数据库中所有的表</h4><ul><li>show tables:<br>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> show tables;+---------------------+| Tables_in_data_test |+---------------------+| customers           || orderitems          || orders              || productnotes        || products            || vendors             |+---------------------+6 rows in set (0.00 sec)</code></pre><h4 id="展示特定表中每列的信息"><a class="header-anchor" href="#展示特定表中每列的信息">¶</a>展示特定表中每列的信息</h4><ul><li>show columns from 数据表(desc 数据表):<br>显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> show columns from customers;+--------------+-----------+------+-----+---------+----------------+| Field        | Type      | Null | Key | Default | Extra          |+--------------+-----------+------+-----+---------+----------------+| cust_id      | int(11)   | NO   | PRI | NULL    | auto_increment || cust_name    | char(50)  | NO   |     | NULL    |                || cust_address | char(50)  | YES  |     | NULL    |                || cust_city    | char(50)  | YES  |     | NULL    |                || cust_state   | char(5)   | YES  |     | NULL    |                || cust_zip     | char(10)  | YES  |     | NULL    |                || cust_country | char(50)  | YES  |     | NULL    |                || cust_contact | char(50)  | YES  |     | NULL    |                || cust_email   | char(255) | YES  |     | NULL    |                |+--------------+-----------+------+-----+---------+----------------+9 rows in set (0.00 sec)</code></pre><h4 id="展示数据表的详细索引信息"><a class="header-anchor" href="#展示数据表的详细索引信息">¶</a>展示数据表的详细索引信息</h4><ul><li>show index from 数据表:<br>显示数据表的详细索引信息，包括PRIMARY KEY（主键）。</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> show index from customers;+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| Table     | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| customers |          0 | PRIMARY  |            1 | cust_id     | A         |           5 |  NULL    |   NULL |      | BTREE      |         |               | YES     | NULL       |+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+1 row in set (0.01 sec)</code></pre><h4 id="展示数据库的性能及统计信息"><a class="header-anchor" href="#展示数据库的性能及统计信息">¶</a>展示数据库的性能及统计信息</h4><ul><li>show table status [from db_name] [like ‘pattern’] \G:<br>该命令将输出Mysql数据库管理系统的性能及统计信息。</li></ul><blockquote><p>显示数据库 data_test 中所有表的信息</p></blockquote><pre class=" language-language-bash"><code class="language-language-bash">mysql> show table status from data_test;+--------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| Name         | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time         | Check_time | Collation       | Checksum | Create_options | Comment |+--------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| customers    | InnoDB |      10 | Dynamic    |    5 |           3276 |       16384 |               0 |            0 |         0 |          10006 | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL       | utf8_general_ci |     NULL |                |         || orderitems   | InnoDB |      10 | Dynamic    |   11 |           1489 |       16384 |               0 |        16384 |         0 |           NULL | 2019-05-26 10:15:02 | 2019-05-26 10:15:26 | NULL       | utf8_general_ci |     NULL |                |         || orders       | InnoDB |      10 | Dynamic    |    5 |           3276 |       16384 |               0 |        16384 |         0 |          20010 | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL       | utf8_general_ci |     NULL |                |         || productnotes | MyISAM |      10 | Dynamic    |   14 |            135 |        1892 | 281474976710655 |         6144 |         0 |            115 | 2019-05-26 10:15:02 | 2019-05-26 10:15:26 | NULL       | utf8_general_ci |     NULL |                |         || products     | InnoDB |      10 | Dynamic    |   14 |           1170 |       16384 |               0 |        16384 |         0 |           NULL | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL       | utf8_general_ci |     NULL |                |         || vendors      | InnoDB |      10 | Dynamic    |    6 |           2730 |       16384 |               0 |            0 |         0 |           1007 | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL       | utf8_general_ci |     NULL |                |         |+--------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+6 rows in set (0.02 sec)</code></pre><blockquote><p>表名以cus开头的表的信息</p></blockquote><pre class=" language-language-bash"><code class="language-language-bash">mysql> show table status from data_test like "cus%";+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| Name      | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time         | Check_time | Collation       | Checksum | Create_options | Comment |+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| customers | InnoDB |      10 | Dynamic    |    5 |           3276 |       16384 |               0 |            0 |         0 |          10006 | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL       | utf8_general_ci |     NULL |                |         |+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+1 row in set (0.00 sec)</code></pre><blockquote><p>表名以cus开头的表的信息;<br>加上 \G，查询结果按列打印;\G后面不能再加分号;<br>因为\G在功能上等同于;<br>如果加了分号，那么就是;;(2个分号)，SQL语法错误<code>ERROR:No query specified</code></p></blockquote><pre class=" language-language-bash"><code class="language-language-bash">mysql> show table status from data_test like "cus%"\G*************************** 1. row ***************************           Name: customers         Engine: InnoDB        Version: 10     Row_format: Dynamic           Rows: 5 Avg_row_length: 3276    Data_length: 16384Max_data_length: 0   Index_length: 0      Data_free: 0 Auto_increment: 10006    Create_time: 2019-05-26 10:15:02    Update_time: 2019-05-26 10:15:25     Check_time: NULL      Collation: utf8_general_ci       Checksum: NULL Create_options:        Comment:1 row in set (0.00 sec)</code></pre><h3 id="3-数据类型"><a class="header-anchor" href="#3-数据类型">¶</a>3. 数据类型</h3><h4 id="数值类型"><a class="header-anchor" href="#数值类型">¶</a>数值类型</h4><p>mysql支持所有标准sql数值数据类型。</p><p>这些类型包括严格数值数据类型（integer、smallint、decimal和numeric），以及近似数值数据类型（float、real和double precisi键字int是integer的同义词，关键字dec是decimal的同义词。</p><p>bit数据类型保存位字段值，并且支持myisam、memory、innodb和bdb表。</p><p>作为sql标准的扩展，mysql也支持整数类型tinyint、mediumint和bigint。下面的表显示了需要的每个整数类型的存储和范围。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:left">范围（有符号）</th><th style="text-align:left">范围（无符号）</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center"><strong>tinyint</strong></td><td style="text-align:center">1 字节</td><td style="text-align:left">(-128，127)</td><td style="text-align:left">(0，255)</td><td style="text-align:center">小整数值</td></tr><tr><td style="text-align:center">smallint</td><td style="text-align:center">2 字节</td><td style="text-align:left">(-32 768，32 767)</td><td style="text-align:left">(0，65 535)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">mediumint</td><td style="text-align:center">3 字节</td><td style="text-align:left">(-8 388 608，8 388 607)</td><td style="text-align:left">(0，16 777 215)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center"><strong>int</strong> 或 <strong>integer</strong></td><td style="text-align:center">4 字节</td><td style="text-align:left">(-2 147 483 648，2 147 483 647)</td><td style="text-align:left">(0，4 294 967 295)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">bigint</td><td style="text-align:center">8 字节</td><td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align:left">(0，18 446 744 073 709 551 615)</td><td style="text-align:center">极大整数值</td></tr><tr><td style="text-align:center"><strong>float</strong></td><td style="text-align:center">4 字节</td><td style="text-align:left">(-3.402 823 466 e+38，-1.175 494 351 e-38)，0，(1.175 494 351 e-38，3.402 823 466 351 e+38)</td><td style="text-align:left">0，(1.175 494 351 e-38，3.402 823 466 e+38)</td><td style="text-align:center">单精度<br/>浮点数值</td></tr><tr><td style="text-align:center"><strong>double</strong></td><td style="text-align:center">8 字节</td><td style="text-align:left">(-1.797 693 134 862 315 7 e+308，-2.225 073 858 507 201 4 e-308)，0，(2.225 073 858 507 201 4 e-308，1.797 693 134 862 315 7 e+308)</td><td style="text-align:left">0，(2.225 073 858 507 201 4 e-308，1.797 693 134 862 315 7 e+308)</td><td style="text-align:center">双精度<br/> 浮点数值</td></tr><tr><td style="text-align:center"><strong>decimal</strong></td><td style="text-align:center">decimal(m,d)</td><td style="text-align:left">依赖于 m 和 d 的值</td><td style="text-align:left">依赖于 m 和 d 的值</td><td style="text-align:center">小数值</td></tr></tbody></table><hr><h4 id="日期和时间类型"><a class="header-anchor" href="#日期和时间类型">¶</a>日期和时间类型</h4><p>表示时间值的日期和时间类型为 datetime、date、timestamp、time 和 year。</p><p>每个时间类型有一个有效值范围和一个 “零” 值，当指定不合法的 mysql 不能表示的值时使用 “零” 值。</p><p>timestamp 类型有专有的自动更新特性，将在后面描述。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小(字节)</th><th style="text-align:left">范围</th><th style="text-align:center">格式</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center"><strong>date</strong></td><td style="text-align:center">3</td><td style="text-align:left">1000-01-01/9999-12-31</td><td style="text-align:center">yyyy-mm-dd</td><td style="text-align:center">日期值</td></tr><tr><td style="text-align:center"><strong>time</strong></td><td style="text-align:center">3</td><td style="text-align:left">‘-838:59:59’/‘838:59:59’</td><td style="text-align:center">hh:mm:ss</td><td style="text-align:center">时间值或持续时间</td></tr><tr><td style="text-align:center">year</td><td style="text-align:center">1</td><td style="text-align:left">1901/2155</td><td style="text-align:center">yyyy</td><td style="text-align:center">年份值</td></tr><tr><td style="text-align:center"><strong>datetime</strong></td><td style="text-align:center">8</td><td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td style="text-align:center">yyyy-mm-dd hh:mm:ss</td><td style="text-align:center">混合日期和时间值</td></tr><tr><td style="text-align:center"><strong>timestamp</strong></td><td style="text-align:center">4</td><td style="text-align:left">1970-01-01 00:00:00/2038<br/>结束时间是第 <strong>2147483647</strong> 秒<br/>北京时间 <strong>2038-1-19 11:14:07</strong><br/>格林尼治时间<strong>2038-1-19 03:14:07</strong></td><td style="text-align:center">yyyymmdd hhmmss</td><td style="text-align:center">混合日期和时间值，时间戳</td></tr></tbody></table><hr><h4 id="字符串类型"><a class="header-anchor" href="#字符串类型">¶</a>字符串类型</h4><p>字符串类型指 char、varchar、binary、varbinary、blob、text、enum 和 set。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><strong>char</strong></td><td style="text-align:left">0-255 字节</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left"><strong>varchar</strong></td><td style="text-align:left">0-65535 字节</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left">tinyblob</td><td style="text-align:left">0-255 字节</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left">tinytext</td><td style="text-align:left">0-255 字节</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left"><strong>blob</strong></td><td style="text-align:left">0-65 535 字节</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td style="text-align:left"><strong>text</strong></td><td style="text-align:left">0-65 535 字节</td><td style="text-align:left">长文本数据</td></tr><tr><td style="text-align:left">mediumblob</td><td style="text-align:left">0-16 777 215 字节</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left">mediumtext</td><td style="text-align:left">0-16 777 215 字节</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left">longblob</td><td style="text-align:left">0-4 294 967 295 字节</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left">longtext</td><td style="text-align:left">0-4 294 967 295 字节</td><td style="text-align:left">极大文本数据</td></tr></tbody></table><p>char 和 varchar 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>binary 和 varbinary 类似于 char 和 varchar，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>blob 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 blob 类型：tinyblob、blob、mediumblob 和 longblob。它们区别在于可容纳存储范围不同。</p><p>有 4 种 text 类型：tinytext、text、mediumtext 和 longtext。对应的这 4 种 blob 类型，可存储的最大长度不同，可根据实际情况选择。</p><blockquote><p>注意：</p></blockquote><p>1、一个汉字占多少长度与编码有关：</p><p>UTF－8：一个汉字＝3个字节</p><p>GBK：一个汉字＝2个字节</p><p>2、varchar(n) 表示 n 个字符，无论汉字和英文，Mysql 都能存入 n 个字符，仅是实际字节长度有所区别</p><p>3、MySQL 检查长度，可用 SQL 语言来查看：</p><pre class=" language-language-bash"><code class="language-language-bash">select length(fieldname) from table_name</code></pre><h3 id="4-创建数据表"><a class="header-anchor" href="#4-创建数据表">¶</a>4. 创建数据表</h3><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><p><strong>语法</strong><br>以下为创建MySQL数据表的SQL通用语法：</p><pre class=" language-language-bash"><code class="language-language-bash">create table table_name (column_name column_type);</code></pre><p><strong>实例</strong><br>以下例子中我们将在 my_data 数据库中创建数据表students：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table if not exists students(id int unsigned auto_increment, name varchar(40) not null, adress varchar(100) , birthday date not null, primary key(id)) engine=innodb default charset=utf8mb4;Query OK, 0 rows affected (0.03 sec)mysql> show columns from students;+----------+------------------+------+-----+---------+----------------+| Field    | Type             | Null | Key | Default | Extra          |+----------+------------------+------+-----+---------+----------------+| id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name     | varchar(40)      | NO   |     | NULL    |                || adress   | varchar(100)     | YES  |     | NULL    |                || birthday | date             | NO   |     | NULL    |                |+----------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)</code></pre><p>实例解析：</p><ul><li>如果你不想字段为 null 可以设置字段的属性为 not null， 在操作数据库时如果输入该字段的数据为null ，就会报错。</li><li>auto_increment定义列为自增的属性，一般用于主键，数值会自动加1。</li><li>primary key关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</li><li>engine 设置存储引擎，charset 设置编码。</li></ul><h3 id="5-删除数据表"><a class="header-anchor" href="#5-删除数据表">¶</a>5. 删除数据表</h3><p>MySQL中删除数据表是非常容易操作的， 但是你再进行删除表操作时要非常小心，因为执行删除命令后所有数据都会消失。</p><p><strong>语法</strong><br>以下为删除MySQL数据表的通用语法：</p><pre class=" language-language-bash"><code class="language-language-bash">drop table table_name;</code></pre><p><strong>实例</strong><br>以下实例中我们将删除 students 表:</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> drop table students;Query OK, 0 rows affected (0.01 sec)mysql> show tables;Empty set (0.00 sec)</code></pre><h3 id="6-插入数据"><a class="header-anchor" href="#6-插入数据">¶</a>6. 插入数据</h3><p>MySQL 表中使用 insert into SQL语句来插入数据。</p><p><strong>语法</strong><br>以下为向MySQL数据表插入数据通用的 INSERT INTO SQL语法：</p><pre class=" language-language-bash"><code class="language-language-bash">insert into table_name ( field1, field2,...fieldN ) values ( value1, value2,...valueN );</code></pre><p>insert 插入多条数据</p><pre class=" language-language-bash"><code class="language-language-bash">insert into table_name  (field1, field2,...fieldn)  values  (valuea1,valuea2,...valuean),(valueb1,valueb2,...valuebn),(valuec1,valuec2,...valuecn)......;</code></pre><p>如果数据是字符型，必须使用单引号或者双引号，如：“value”。</p><p><strong>实例</strong><br>以下实例中我们将向 students 表插入数据:</p><pre class=" language-language-bash"><code class="language-language-bash"># 主键默认从1开始mysql> insert into students (name,birthday) values("丽丽","1996-05-06");Query OK, 1 row affected (0.00 sec)# 主键设为0，即从最后一个id值自动增长mysql> insert into students values(0,"李明",null,"1993-12-16");Query OK, 1 row affected (0.01 sec)mysql> insert into students values(10,"张磊",'北京市海淀区',"1995-04-12");Query OK, 1 row affected (0.00 sec)# 主键不设置，从最后一个id值自动增长mysql> insert into students set name="孙雨",adress='河北省石家庄市',birthday="1989-07-18";Query OK, 1 row affected (0.01 sec)</code></pre><blockquote><p>如果添加过主键自增（PRINARY KEY AUTO_INCREMENT）第一列在增加数据的时候，可以写为0或者null，这样添加数据可以自增</p></blockquote><h3 id="7-条件语句"><a class="header-anchor" href="#7-条件语句">¶</a>7. 条件语句</h3><ul><li>查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用where语句来设定查询条件。</li><li>where 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li><li>以下为操作符列表，可用于 where 子句中。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以使用 and 或者 or 指定一个或多个条件。</li><li>WHERE 子句也可以运用于 SQL 的 delete 或者 update 命令。</li></ul><blockquote><p>下表中实例假定 A 为 10, B 为 20</p></blockquote><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:left">等号，检测两个值是否相等，如果相等返回true</td><td style="text-align:left">(A = B) 返回false。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:left">不等于，检测两个值是否相等，如果不相等返回true</td><td style="text-align:left">(A != B) 返回 true。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td style="text-align:left">(A &gt; B) 返回false。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td style="text-align:left">(A &lt; B) 返回 true。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td style="text-align:left">(A &gt;= B) 返回false。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:left">小于等于号，检测左边的值是否小于于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td style="text-align:left">(A &lt;= B) 返回 true。</td></tr></tbody></table><p>如果我们想在 MySQL 数据表中读取指定的数据，where 子句是非常有用的。</p><p>使用主键来作为 where 子句的条件查询是非常快速的。</p><p>如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。</p><h3 id="8-查询数据"><a class="header-anchor" href="#8-查询数据">¶</a>8. 查询数据</h3><p>MySQL 数据库使用SQL select语句来查询数据。</p><p><strong>语法</strong><br>以下为在MySQL数据库中查询数据通用的 select 语法</p><pre class=" language-language-bash"><code class="language-language-bash">select column_name,column_namefrom table_name[where Clause][limit N][ offset M]</code></pre><ul><li>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用where语句来设定查询条件。</li><li>select 命令可以读取一条或者多条记录。</li><li>你可以使用星号（*）来代替其他字段，select语句会返回表的所有字段数据</li><li>你可以使用 limit 属性来设定返回的记录数。</li><li>你可以通过offset指定select语句开始查询的数据偏移量。默认情况下偏移量为0。</li></ul><p><strong>实例</strong><br>以下实例我们将通过 SQL select 命令来获取 MySQL 数据表 students 的数据：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select * from students;+----+------+----------------+------------+| id | name | adress         | birthday   |+----+------+----------------+------------+|  1 | 丽丽 | NULL           | 1996-05-06 ||  2 | 李明 | NULL           | 1993-12-16 || 10 | 张磊 | 北京市海淀区    | 1995-04-12 || 11 | 孙雨 | 河北省石家庄市  | 1989-07-18 |+----+------+----------------+------------+4 rows in set (0.00 sec)mysql> select id,name from students limit 2 offset 1;+----+------+| id | name |+----+------+|  2 | 李明 || 10 | 张磊 |+----+------+2 rows in set (0.00 sec)mysql> select * from students where id>=10;+----+------+----------------+------------+| id | name | adress         | birthday   |+----+------+----------------+------------+| 10 | 张磊 | 北京市海淀区   | 1995-04-12 || 11 | 孙雨 | 河北省石家庄市 | 1989-07-18 |+----+------+----------------+------------+2 rows in set (0.00 sec)mysql> select * from students where id>=10 limit 1 offset 1;+----+------+----------------+------------+| id | name | adress         | birthday   |+----+------+----------------+------------+| 11 | 孙雨 | 河北省石家庄市 | 1989-07-18 |+----+------+----------------+------------+1 row in set (0.00 sec)mysql> select * from students where name="李明";+----+------+--------+------------+| id | name | adress | birthday   |+----+------+--------+------------+|  2 | 李明 | NULL   | 1993-12-16 |+----+------+--------+------------+1 row in set (0.00 sec)</code></pre><h3 id="9-修改数据"><a class="header-anchor" href="#9-修改数据">¶</a>9. 修改数据</h3><p>如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL update 命令来操作。</p><p><strong>语法</strong><br>以下是 update 命令修改 MySQL 数据表数据的通用 SQL 语法：</p><pre class=" language-language-bash"><code class="language-language-bash">update table_name set field1=new-value1, field2=new-value2 [where clause]</code></pre><p>当我们需要将字段中的特定字符串批量修改为其他字符串时，可已使用以下操作：</p><pre class=" language-language-bash"><code class="language-language-bash">update table_name set field=replace(field, 'old-string', 'new-string') [where clause]</code></pre><ul><li>你可以同时更新一个或多个字段。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。<br>当你需要更新数据表中指定行的数据时 where 子句是非常有用的。</li></ul><p><strong>实例</strong><br>以下我们将在 SQL update 命令使用 where 子句来更新 students 表中指定的数据：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> update students set adress="北京市昌平区" where adress is null;Query OK, 2 rows affected (0.01 sec)Rows matched: 2  Changed: 2  Warnings: 0mysql> select * from students;+----+------+----------------+------------+| id | name | adress         | birthday   |+----+------+----------------+------------+|  1 | 丽丽 | 北京市昌平区   | 1996-05-06 ||  2 | 李明 | 北京市昌平区   | 1993-12-16 || 10 | 张磊 | 北京市海淀区   | 1995-04-12 || 11 | 孙雨 | 河北省石家庄市 | 1989-07-18 |+----+------+----------------+------------+4 rows in set (0.00 sec)mysql> update students set adress=replace(adress, "河北省石家庄","湖北省武汉") where id=11;Query OK, 1 row affected (0.01 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql> select * from students;+----+------+--------------+------------+| id | name | adress       | birthday   |+----+------+--------------+------------+|  1 | 丽丽 | 北京市昌平区 | 1996-05-06 ||  2 | 李明 | 北京市昌平区 | 1993-12-16 || 10 | 张磊 | 北京市海淀区 | 1995-04-12 || 11 | 孙雨 | 湖北省武汉市 | 1989-07-18 |+----+------+--------------+------------+4 rows in set (0.00 sec)mysql> update students set id=id-7 where id=10;Query OK, 1 row affected (0.01 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql> select * from students;+----+------+--------------+------------+| id | name | adress       | birthday   |+----+------+--------------+------------+|  1 | 丽丽 | 北京市昌平区 | 1996-05-06 ||  2 | 李明 | 北京市昌平区 | 1993-12-16 ||  3 | 张磊 | 北京市海淀区 | 1995-04-12 || 11 | 孙雨 | 湖北省武汉市 | 1989-07-18 |+----+------+--------------+------------+4 rows in set (0.00 sec)</code></pre><h3 id="10-删除数据"><a class="header-anchor" href="#10-删除数据">¶</a>10. 删除数据</h3><p>你可以使用 sql 的 delete from 命令来删除 mysql 数据表中的记录。</p><p><strong>语法</strong><br>以下是 sql delete 语句从 mysql 数据表中删除数据的通用语法：</p><pre class=" language-language-bash"><code class="language-language-bash">delete from table_name [where clause]</code></pre><ul><li>如果没有指定 where 子句，mysql 表中的所有记录将被删除。</li><li>你可以在 where 子句中指定任何条件</li><li>您可以在单个表中一次性删除记录。<br>当你想删除数据表中指定的记录时 where 子句是非常有用的。</li></ul><p><strong>实例</strong><br>这里我们将在 sql delete 命令中使用 where 子句来删除 mysql 数据表 students 所选的数据:</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> delete from students where id=11;Query OK, 1 row affected (0.01 sec)mysql> select * from students;+----+------+--------------+------------+| id | name | adress       | birthday   |+----+------+--------------+------------+|  1 | 丽丽 | 北京市昌平区 | 1996-05-06 ||  2 | 李明 | 北京市昌平区 | 1993-12-16 ||  3 | 张磊 | 北京市海淀区 | 1995-04-12 |+----+------+--------------+------------+3 rows in set (0.00 sec)</code></pre><blockquote><p>delete，drop，truncate 都有删除表的作用，区别在于：</p></blockquote><p>1、drop table table_name : 删除表全部数据和表结构，立刻释放磁盘空间，不管是 Innodb 和 MyISAM;</p><p>实例，删除学生表：</p><pre class=" language-language-bash"><code class="language-language-bash">drop table students;</code></pre><p>2、truncate table table_name : 删除表全部数据，保留表结构，立刻释放磁盘空间 ，不管是 Innodb 和 MyISAM;</p><p>实例，删除学生表：</p><pre class=" language-language-bash"><code class="language-language-bash">truncate table students;</code></pre><p>3、delete from table_name : 删除表全部数据，表结构不变，对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间;</p><p>实例，删除学生表：</p><pre class=" language-language-bash"><code class="language-language-bash">delete from students;</code></pre><p>4、delete from table_name where xxx : 带条件的删除，表结构不变，不管是 innodb 还是 MyISAM 都不会释放磁盘空间;</p><p>实例，删除学生表中姓名为 “张三” 的数据：</p><pre class=" language-language-bash"><code class="language-language-bash">delete from student where name = "张三";</code></pre><p>5、delete 操作以后，使用 optimize table table_name 会立刻释放磁盘空间，不管是 innodb 还是 myisam;</p><p>实例，删除学生表中姓名为 “张三” 的数据：</p><pre class=" language-language-bash"><code class="language-language-bash">delete from student where name = "张三";</code></pre><p>实例，释放学生表的表空间：</p><pre class=" language-language-bash"><code class="language-language-bash">optimize table students;</code></pre><p>6、delete from 表以后虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以使用这部分空间。</p><h3 id="11-包含条件"><a class="header-anchor" href="#11-包含条件">¶</a>11. 包含条件</h3><p>我们知道在 mysql 中使用 sql select 命令来读取数据， 同时我们可以在 select 语句中使用 where 子句来获取指定的记录。</p><p>where 子句中可以使用等号 = 来设定获取数据的条件，如 “adress = ‘北京市昌平区’”。</p><p>但是有时候我们需要获取 adress 字段含有 “北京市” 字符的所有记录，这时我们就需要在 where 子句中使用 sql like 子句。</p><p><strong>语法</strong><br>以下是 sql select 语句使用 like 子句从数据表中读取数据的通用语法：</p><pre class=" language-language-bash"><code class="language-language-bash">select field1, field2,...fieldn from table_name where field1 like condition1 [and [or]] filed2 = 'somevalue'</code></pre><ul><li>sql like 子句中使用百分号 %字符来表示任意字符，类似于unix或正则表达式中的星号 *。</li><li>如果没有使用百分号 %, like 子句与等号 = 的效果是一样的。</li><li>like 通常与 % 一同使用，类似于一个元字符的搜索。</li><li>可以使用 and 或者 or 指定一个或多个条件。</li><li>可以在 delete、select或 update 命令中使用 where…like 子句来指定条件。</li></ul><p><strong>实例</strong><br>以下我们将在 sql select 命令中使用 where…like 子句来从mysql数据表 students 中读取数据。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select * from students where adress like "北京市%";+----+------+--------------+------------+| id | name | adress       | birthday   |+----+------+--------------+------------+|  1 | 丽丽 | 北京市昌平区 | 1996-05-06 ||  2 | 李明 | 北京市昌平区 | 1993-12-16 ||  3 | 张磊 | 北京市海淀区 | 1995-04-12 |+----+------+--------------+------------+3 rows in set (0.00 sec)</code></pre><blockquote><p>在 where like 的条件查询中，SQL 提供了四种匹配方式。</p></blockquote><ul><li><code>%</code>：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</li><li><code>_</code>：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。</li><li><code>[]</code>：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</li><li><code>[^]</code>：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</li><li>查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。</li></ul><blockquote><p>like 匹配/模糊匹配，会与 % 和 _ 结合使用。</p></blockquote><pre class=" language-language-bash"><code class="language-language-bash">'%a'     //以a结尾的数据'a%'     //以a开头的数据'%a%'    //含有a的数据'_a_'    //三位且中间字母是a的'_a'     //两位且结尾字母是a的'a_'     //两位且开头字母是a的</code></pre><h3 id="12-关联查询"><a class="header-anchor" href="#12-关联查询">¶</a>12. 关联查询</h3><p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p><p><strong>语法</strong><br>mysql union 操作符语法格式：</p><pre class=" language-language-bash"><code class="language-language-bash">select expression1, expression2, ... expression_nfrom tables[where conditions]union [all | distinct]select expression1, expression2, ... expression_nfrom tables[where conditions];</code></pre><p><strong>参数</strong></p><ul><li><p>expression1, expression2, … expression_n: 要检索的列。</p></li><li><p>tables: 要检索的数据表。</p></li><li><p>where conditions: 可选， 检索条件。</p></li><li><p>distinct: 可选，删除结果集中重复的数据。默认情况下 union 操作符已经删除了重复数据，所以 distinct 修饰符对结果没啥影响。</p></li><li><p>all: 可选，返回所有结果集，包含重复数据。</p></li></ul><p><strong>实例</strong><br>下面的 SQL 语句从 “students” 和 “teachers” 表中选取所有不同的adress（只有不同的值）：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select * from students;+----+------+--------------+------------+| id | name | adress       | birthday   |+----+------+--------------+------------+|  1 | 丽丽 | 北京市昌平区 | 1996-05-06 ||  2 | 李明 | 北京市昌平区 | 1993-12-16 ||  3 | 张磊 | 北京市海淀区 | 1995-04-12 |+----+------+--------------+------------+3 rows in set (0.00 sec)mysql> select * from teachers;+----+--------+--------------+----------+| id | name   | adress       | birthday |+----+--------+--------------+----------+|  1 | 刘老师 | 北京市海淀区 | NULL     ||  2 | 孙老师 | 北京市朝阳区 | NULL     ||  3 | 常老师 | 北京市昌平区 | NULL     |+----+--------+--------------+----------+3 rows in set (0.00 sec)mysql> select adress from students union select adress from teachers ;+--------------+| adress       |+--------------+| 北京市昌平区 || 北京市海淀区 || 北京市朝阳区 |+--------------+3 rows in set (0.00 sec)mysql> select name from students where adress like "%昌平区" union select name from teachers where adress like "%昌平区" ;+--------+| name   |+--------+| 丽丽   || 李明   || 常老师 |+--------+3 rows in set (0.00 sec)</code></pre><blockquote><p>UNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）<br>UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p></blockquote><h3 id="13-排序"><a class="header-anchor" href="#13-排序">¶</a>13. 排序</h3><p>我们知道从 mysql 表中使用 sql select 语句来读取数据。</p><p>如果我们需要对读取的数据进行排序，我们就可以使用 mysql 的 order by 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。</p><p><strong>语法</strong><br>以下是 sql select 语句使用 order by 子句将查询数据排序后再返回数据：</p><pre class=" language-language-bash"><code class="language-language-bash">select field1, field2,...fieldn table_name1, table_name2... order by field1 [asc [desc][默认 asc]], [field2...] [asc [desc][默认 asc]]</code></pre><ul><li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li><li>你可以设定多个字段来排序。</li><li>你可以使用 asc 或 desc 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li><li>你可以添加 where…like 子句来设置条件。</li></ul><p><strong>实例</strong><br>尝试以下实例，结果将按升序及降序排列。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select * from students where adress like "北京市%" order by birthday;+----+------+--------------+------------+| id | name | adress       | birthday   |+----+------+--------------+------------+|  2 | 李明 | 北京市昌平区 | 1993-12-16 ||  3 | 张磊 | 北京市海淀区 | 1995-04-12 ||  1 | 丽丽 | 北京市昌平区 | 1996-05-06 |+----+------+--------------+------------+3 rows in set (0.00 sec)mysql> select * from students where adress like "北京市%" order by birthday desc;+----+------+--------------+------------+| id | name | adress       | birthday   |+----+------+--------------+------------+|  1 | 丽丽 | 北京市昌平区 | 1996-05-06 ||  3 | 张磊 | 北京市海淀区 | 1995-04-12 ||  2 | 李明 | 北京市昌平区 | 1993-12-16 |+----+------+--------------+------------+3 rows in set (0.00 sec)mysql> select * from students where adress like "北京市%" order by birthday asc;+----+------+--------------+------------+| id | name | adress       | birthday   |+----+------+--------------+------------+|  2 | 李明 | 北京市昌平区 | 1993-12-16 ||  3 | 张磊 | 北京市海淀区 | 1995-04-12 ||  1 | 丽丽 | 北京市昌平区 | 1996-05-06 |+----+------+--------------+------------+3 rows in set (0.00 sec)</code></pre><h3 id="14-分组"><a class="header-anchor" href="#14-分组">¶</a>14. 分组</h3><p>group by 语句根据一个或多个列对结果集进行分组。<br>在分组的列上我们可以使用 count, sum, avg等函数。</p><p><strong>语法</strong><br>以下是gruop by语句的语法示例：</p><pre class=" language-language-bash"><code class="language-language-bash">select column_name, function(column_name) from table_name where column_name operator value group by column_name;</code></pre><p><strong>实例</strong><br>接下来我们使用 group by 语句 将数据表按名字进行分组，并统计每个商品有多少条记录：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select * from goods;+----+--------+------+| id | name   | nums |+----+--------+------+|  1 | 西瓜   |   50 ||  2 | 甜瓜   |   15 ||  3 | 甜瓜   |   15 ||  4 | 苹果   |   25 ||  5 | 西瓜   |   25 ||  6 | 西瓜   |   63 |+----+--------+------+6 rows in set (0.00 sec)mysql> select name, count(name) from goods group by name;+--------+-------------+| name   | count(name) |+--------+-------------+| 甜瓜   |           2 || 苹果   |           1 || 西瓜   |           3 |+--------+-------------+3 rows in set (0.00 sec)</code></pre><p>with rollup 可以实现在分组统计数据基础上再进行相同的统计（sum,avg,count…）。</p><p>例如我们将以上的数据表按商品名称进行分组，再统计每类商品的总数量，或者求其均值：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select name, sum(nums) as count_num from goods group by name;+--------+-----------+| name   | count_num |+--------+-----------+| 甜瓜   |        30 || 苹果   |        25 || 西瓜   |       138 |+--------+-----------+3 rows in set (0.00 sec)mysql> select name, avg(nums) as avg_num from goods group by name with rollup;+--------+---------+| name   | avg_num |+--------+---------+| 甜瓜   | 15.0000 || 苹果   | 25.0000 || 西瓜   | 46.0000 || NULL   | 32.1667 |+--------+---------+4 rows in set (0.00 sec)</code></pre><p>我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：</p><pre class=" language-language-bash"><code class="language-language-bash">select coalesce(a,b,c);</code></pre><p>参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。</p><p>以下实例中如果名字为空我们使用总数代替：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select coalesce(name, '总计') as 名称, sum(nums) as 数量 from goods group by name with rollup;+--------+--------+| 名称   | 数量   |+--------+--------+| 甜瓜   |     30 || 苹果   |     25 || 西瓜   |    138 || 总计   |    193 |+--------+--------+4 rows in set (0.00 sec)</code></pre><h3 id="15-连接"><a class="header-anchor" href="#15-连接">¶</a>15. 连接</h3><p>在前面的章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。</p><p>本章节我们将向大家介绍如何使用 mysql 的 join 在两个或多个表中查询数据。</p><p>你可以在 select, update 和 delete 语句中使用 mysql 的 join 来联合多表查询。</p><p>join 按照功能大致分为如下三类：</p><ul><li>inner join（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</li><li>left join（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</li><li>right join（右连接）： 与 left join 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li></ul><p><strong>实例</strong><br>首先创建表，并添加测试数据</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table web_counts(id int unsigned auto_increment primary key, web_name varchar(20) not null, nums int unsigned default 0) default charset=utf8;Query OK, 0 rows affected (0.10 sec)mysql> create table web_info(id int unsigned auto_increment primary key, web_name varchar(20) not null, web_info varchar(50), create_time date not null) default charset=utf8;Query OK, 0 rows affected (0.00 sec)mysql> desc web_info;+-------------+------------------+------+-----+---------+----------------+| Field       | Type             | Null | Key | Default | Extra          |+-------------+------------------+------+-----+---------+----------------+| id          | int(10) unsigned | NO   | PRI | NULL    | auto_increment || web_name    | varchar(20)      | NO   |     | NULL    |                || web_info    | varchar(50)      | YES  |     | NULL    |                || create_time | date             | NO   |     | NULL    |                |+-------------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)mysql> desc web_counts;+----------+------------------+------+-----+---------+----------------+| Field    | Type             | Null | Key | Default | Extra          |+----------+------------------+------+-----+---------+----------------+| id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment || web_name | varchar(20)      | NO   |     | NULL    |                || nums     | int(10) unsigned | YES  |     | 0       |                |+----------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql> insert into web_counts values(0, " 淘宝",1000);Query OK, 1 row affected (0.03 sec)mysql> insert into web_counts values(0, "百度", 3000);Query OK, 1 row affected (0.00 sec)mysql> insert into web_counts values(0, "腾讯", 2000);Query OK, 1 row affected (0.00 sec)mysql> insert into web_counts values(0, "网易", 900);Query OK, 1 row affected (0.00 sec)mysql> select * from web_counts;+----+----------+------+| id | web_name | nums |+----+----------+------+|  1 | 淘宝     | 1000 ||  2 | 百度     | 3000 ||  3 | 腾讯     | 2000 ||  4 | 网易     |  900 |+----+----------+------+4 rows in set (0.00 sec)mysql> insert into web_info values(0, "百度", "搜索网站","1989-9-01");Query OK, 1 row affected (0.00 sec)mysql> insert into web_info values(0, "腾讯", "社交网站","1991-02-05");Query OK, 1 row affected (0.00 sec)mysql> insert into web_info values(0, "网易", "门户网站","1990-08-09");Query OK, 1 row affected (0.00 sec)mysql> insert into web_info values(0, "新浪", "社交网站","1993-05-12");Query OK, 1 row affected (0.00 sec)mysql> select * from web_info;+----+----------+--------------+-------------+| id | web_name | web_info     | create_time |+----+----------+--------------+-------------+|  1 | 百度     | 搜索网站     | 1989-09-01  ||  2 | 腾讯     | 社交网站     | 1991-02-05  ||  3 | 网易     | 门户网站     | 1990-08-09  ||  4 | 新浪     | 社交网站     | 1993-05-12  |+----+----------+--------------+-------------+4 rows in set (0.01 sec)</code></pre><p>接下来我们就使用mysql的inner join(也可以省略 inner 使用 join，效果一样)来连接以上两张表来读取web_counts表中所有web_name字段在web_info表对应的字段值：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select b.id, a.web_name, a.nums,b.web_info, b.create_time from web_counts a inner join web_info b on a.web_name=b.web_name;+----+----------+------+--------------+-------------+| id | web_name | nums | web_info     | create_time |+----+----------+------+--------------+-------------+|  1 | 百度     | 3000 | 搜索网站     | 1989-09-01  ||  2 | 腾讯     | 2000 | 社交网站     | 1991-02-05  ||  3 | 网易     |  900 | 门户网站     | 1990-08-09  |+----+----------+------+--------------+-------------+3 rows in set (0.00 sec)</code></pre><p>以上 SQL 语句等价于：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select b.id, a.web_name, a.nums,b.web_info, b.create_time from web_counts a, web_info b where a.web_name=b.web_name;+----+----------+------+--------------+-------------+| id | web_name | nums | web_info     | create_time |+----+----------+------+--------------+-------------+|  1 | 百度     | 3000 | 搜索网站     | 1989-09-01  ||  2 | 腾讯     | 2000 | 社交网站     | 1991-02-05  ||  3 | 网易     |  900 | 门户网站     | 1990-08-09  |+----+----------+------+--------------+-------------+3 rows in set (0.00 sec)</code></pre><p>mysql left join 与 join 有所不同。 mysql left join 会读取左边数据表的全部数据，即便右边表无对应数据。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select a.id, a.web_name, a.nums,b.web_info, b.create_time from web_counts a left join web_info b on a.web_name=b.web_name order by a.id;+----+----------+------+--------------+-------------+| id | web_name | nums | web_info     | create_time |+----+----------+------+--------------+-------------+|  1 | 淘宝     | 1000 | NULL         | NULL        ||  2 | 百度     | 3000 | 搜索网站     | 1989-09-01  ||  3 | 腾讯     | 2000 | 社交网站     | 1991-02-05  ||  4 | 网易     |  900 | 门户网站     | 1990-08-09  |+----+----------+------+--------------+-------------+4 rows in set (0.00 sec)</code></pre><p>mysql right join 会读取右边数据表的全部数据，即便左边边表无对应数据。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select b.id, b.web_name, a.nums,b.web_info, b.create_time from web_counts a right join web_info b on a.web_name=b.web_name order by b.id;+----+----------+------+--------------+-------------+| id | web_name | nums | web_info     | create_time |+----+----------+------+--------------+-------------+|  1 | 百度     | 3000 | 搜索网站     | 1989-09-01  ||  2 | 腾讯     | 2000 | 社交网站     | 1991-02-05  ||  3 | 网易     |  900 | 门户网站     | 1990-08-09  ||  4 | 新浪     | NULL | 社交网站     | 1993-05-12  |+----+----------+------+--------------+-------------+4 rows in set (0.01 sec)</code></pre><h3 id="16-正则表达式"><a class="header-anchor" href="#16-正则表达式">¶</a>16. 正则表达式</h3><p>mysql 正则表达式<br>在前面的章节我们已经了解到mysql可以通过 <code>like ...%</code> 来进行模糊匹配。</p><p>mysql 同样也支持其他正则表达式的匹配， mysql中使用 regexp 操作符来进行正则表达式匹配。</p><p>下表中的正则模式可应用于 <code>regexp</code> 操作符中。</p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>^</code></td><td style="text-align:left">匹配输入字符串的开始位置。如果设置了 regexp 对象的 multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:left">匹配输入字符串的结束位置。如果设置了regexp 对象的 multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td style="text-align:center"><code>.</code></td><td style="text-align:left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td style="text-align:center"><code>[...]</code></td><td style="text-align:left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td style="text-align:center"><code>[^...]</code></td><td style="text-align:left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td></tr><tr><td style="text-align:center"><code>p1|p2</code></td><td style="text-align:left">匹配 p1 或 p2。例如，<code>z|food</code> 能匹配 “z” 或 “food”。<code>(z | f)ood</code> 则匹配 “zood” 或 “food”。</td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td style="text-align:center"><code>{n}</code></td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td style="text-align:center"><code>{n,m}</code></td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td></tr></tbody></table><p><strong>实例</strong><br>了解以上的正则需求后，我们就可以根据自己的需求来编写带有正则表达式的sql语句。以下我们将列出几个小实例(表名：person_tbl )来加深我们的理解：</p><ul><li>查找name字段中以’st’为开头的所有数据：</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> select name from person_tbl where name regexp '^st';</code></pre><ul><li>查找name字段中以’ok’为结尾的所有数据：</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> select name from person_tbl where name regexp 'ok$';</code></pre><ul><li>查找name字段中包含’mar’字符串的所有数据：</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> select name from person_tbl where name regexp 'mar';</code></pre><ul><li>查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据：</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> select name from person_tbl where name regexp '^[aeiou]|ok$';</code></pre><h3 id="17-NULL-值处理"><a class="header-anchor" href="#17-NULL-值处理">¶</a>17. NULL 值处理</h3><p>为了处理这种情况，mysql提供了三大运算符:</p><ul><li>is null: 当列的值是 null,此运算符返回 true。</li><li>is not null: 当列的值不为 null, 运算符返回 true。</li><li>&lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 null 时返回 true。</li></ul><blockquote><p>关于 null 的条件比较运算是比较特殊的。你不能使用 = null 或 != null 在列中查找 null 值 。</p></blockquote><blockquote><p>在 mysql 中，null 值与任何其它值的比较（即使是 null）永远返回 false，即 null = null 返回false 。</p></blockquote><p>mysql 中处理 null 使用 is null 和 is not null 运算符。</p><p><strong>实例</strong><br>在数据库my_data中创建student表，并插入相应数据</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table student(ID int unsigned auto_increment primary key,name varchar(10) not null,age int unsigned) default charset=utf8;Query OK, 0 rows affected (0.25 sec)mysql> insert into student values(0, "李华",25);Query OK, 1 row affected (0.04 sec)mysql> insert into student values(0, "敏柔",null);Query OK, 1 row affected (0.04 sec)mysql> insert into student values(0, "赵强",null);Query OK, 1 row affected (0.04 sec)mysql> insert into student values(0, "罗晴",23);Query OK, 1 row affected (0.03 sec)mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   | NULL ||  3 | 赵强   | NULL ||  4 | 罗晴   |   23 |+----+--------+------+4 rows in set (0.00 sec)</code></pre><p>以下实例中你可以看到 = 和 != 运算符是不起作用的：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select id,name,age=null from student;+----+--------+----------+| id | name   | age=null |+----+--------+----------+|  1 | 李华   |     NULL ||  2 | 敏柔   |     NULL ||  3 | 赵强   |     NULL ||  4 | 罗晴   |     NULL |+----+--------+----------+4 rows in set (0.00 sec)mysql> select id,name,age!=null from student;+----+--------+-----------+| id | name   | age!=null |+----+--------+-----------+|  1 | 李华   |      NULL ||  2 | 敏柔   |      NULL ||  3 | 赵强   |      NULL ||  4 | 罗晴   |      NULL |+----+--------+-----------+4 rows in set (0.00 sec)</code></pre><p>查找数据表中 age 列是否为 null，必须使用 &lt;=&gt; 、is null 和 is not null，如下实例：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select id,name,age is null from student;+----+--------+-------------+| id | name   | age is null |+----+--------+-------------+|  1 | 李华   |           0 ||  2 | 敏柔   |           1 ||  3 | 赵强   |           1 ||  4 | 罗晴   |           0 |+----+--------+-------------+4 rows in set (0.00 sec)mysql> select id,name,age<=>null from student;+----+--------+------------+| id | name   | age<=>null |+----+--------+------------+|  1 | 李华   |          0 ||  2 | 敏柔   |          1 ||  3 | 赵强   |          1 ||  4 | 罗晴   |          0 |+----+--------+------------+4 rows in set (0.00 sec)</code></pre><h3 id="18-事务"><a class="header-anchor" href="#18-事务">¶</a>18.事务</h3><p>mysql 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><ul><li>在 mysql 中只有使用了 innodb 数据库引擎的数据库或表才支持事务。</li><li>事务处理可以用来维护数据库的完整性，保证成批的 sql 语句要么全部执行，要么全部不执行。</li><li>事务用来管理 insert,update,delete 语句</li></ul><p>一般来说，事务是必须满足4个条件（acid）：：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。</p><ul><li><p><strong>原子性</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><strong>一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>隔离性</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable）。</p></li><li><p><strong>持久性</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><blockquote><p>在 mysql 命令行的默认设置下，事务都是自动提交的，即执行 sql 语句后就会马上执行 commit 操作。因此要显式地开启一个事务务须使用命令 begin 或 start transaction，或者执行命令 set autocommit=0，用来禁止使用当前会话的自动提交。</p></blockquote><h4 id="事务控制语句："><a class="header-anchor" href="#事务控制语句：">¶</a>事务控制语句：</h4><ul><li><p>begin 或 start transaction 显式地开启一个事务；</p></li><li><p>commit 也可以使用 commit work，不过二者是等价的。commit 会提交事务，并使已对数据库进行的所有修改成为永久性的；</p></li><li><p>rollback 也可以使用 rollback work，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</p></li><li><p>savepoint identifier，savepoint 允许在事务中创建一个保存点，一个事务中可以有多个 savepoint；</p></li><li><p>release savepoint identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</p></li><li><p>rollback to identifier 把事务回滚到标记点；</p></li><li><p>set transaction 用来设置事务的隔离级别。innodb 存储引擎提供事务的隔离级别有read uncommitted、read committed、repeatable read 和 serializable。</p></li></ul><h4 id="mysql-事务处理主要有两种方法："><a class="header-anchor" href="#mysql-事务处理主要有两种方法：">¶</a>mysql 事务处理主要有两种方法：</h4><p>1、用 begin, rollback, commit来实现</p><ul><li>begin 开始一个事务</li><li>rollback 事务回滚</li><li>commit 事务确认</li></ul><p>2、直接用 set 来改变 mysql 的自动提交模式:</p><ul><li>set autocommit=0 禁止自动提交</li><li>set autocommit=1 开启自动提交</li></ul><p><strong>实例</strong><br>下面具体演示MySQL事务的使用</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   | NULL ||  3 | 赵强   | NULL ||  4 | 罗晴   |   23 |+----+--------+------+4 rows in set (0.00 sec)mysql> begin; # 开启事务Query OK, 0 rows affected (0.00 sec)mysql> insert into student values(0,"寒梅",28); # 插入数据Query OK, 1 row affected (0.00 sec)mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   | NULL ||  3 | 赵强   | NULL ||  4 | 罗晴   |   23 ||  5 | 寒梅   |   28 |+----+--------+------+5 rows in set (0.00 sec)mysql> rollback; # 回滚Query OK, 0 rows affected (0.04 sec)mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   | NULL ||  3 | 赵强   | NULL ||  4 | 罗晴   |   23 |+----+--------+------+4 rows in set (0.00 sec)mysql> insert into student values(0,"寒梅",28); # 插入数据Query OK, 1 row affected (0.15 sec)mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   | NULL ||  3 | 赵强   | NULL ||  4 | 罗晴   |   23 ||  6 | 寒梅   |   28 |+----+--------+------+5 rows in set (0.00 sec)mysql> insert into student values(5,"李磊",26);Query OK, 1 row affected (0.04 sec)mysql> insert into student values(0,"张雷",20);Query OK, 1 row affected (0.04 sec)mysql> set autocommit=0; # 禁止自动提交Query OK, 0 rows affected (0.00 sec)mysql> insert into student values(0,"韩美美",20);Query OK, 1 row affected (0.00 sec)mysql> select * from student;+----+-----------+------+| ID | name      | age  |+----+-----------+------+|  1 | 李华      |   25 ||  2 | 敏柔      | NULL ||  3 | 赵强      | NULL ||  4 | 罗晴      |   23 ||  5 | 李磊      |   26 ||  6 | 寒梅      |   28 ||  7 | 张雷      |   20 ||  8 | 莉莉      |   20 ||  9 | 韩美美    |   20 |+----+-----------+------+9 rows in set (0.00 sec)mysql> rollback; # 回滚Query OK, 0 rows affected (0.16 sec)mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   | NULL ||  3 | 赵强   | NULL ||  4 | 罗晴   |   23 ||  5 | 李磊   |   26 ||  6 | 寒梅   |   28 ||  7 | 张雷   |   20 ||  8 | 莉莉   |   20 |+----+--------+------+8 rows in set (0.00 sec)mysql> update student set age=23 where name="敏柔"; # 修改数据Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   |   23 ||  3 | 赵强   | NULL ||  4 | 罗晴   |   23 ||  5 | 李磊   |   26 ||  6 | 寒梅   |   28 ||  7 | 张雷   |   20 ||  8 | 莉莉   |   20 |+----+--------+------+8 rows in set (0.00 sec)mysql> savepoint point1; # 创建保存点Query OK, 0 rows affected (0.00 sec)mysql> update student set age=22 where name="赵强";Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   |   23 ||  3 | 赵强   |   22 ||  4 | 罗晴   |   23 ||  5 | 李磊   |   26 ||  6 | 寒梅   |   28 ||  7 | 张雷   |   20 ||  8 | 莉莉   |   20 |+----+--------+------+8 rows in set (0.00 sec)mysql> rollback to point1; # 回滚到保存点Query OK, 0 rows affected (0.00 sec)mysql> select * from student;+----+--------+------+| ID | name   | age  |+----+--------+------+|  1 | 李华   |   25 ||  2 | 敏柔   |   23 ||  3 | 赵强   | NULL ||  4 | 罗晴   |   23 ||  5 | 李磊   |   26 ||  6 | 寒梅   |   28 ||  7 | 张雷   |   20 ||  8 | 莉莉   |   20 |+----+--------+------+8 rows in set (0.00 sec)mysql> commit; # 事务提交Query OK, 0 rows affected (0.04 sec)</code></pre><h3 id="19-ALTER命令"><a class="header-anchor" href="#19-ALTER命令">¶</a>19. ALTER命令</h3><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL alter命令。</p><h4 id="删除表字段"><a class="header-anchor" href="#删除表字段">¶</a>删除表字段</h4><p>如下命令使用了 alter 命令及 drop 子句来删除以上创建表的 age 字段：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| ID    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(10)      | NO   |     | NULL    |                || age   | int(10) unsigned | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql> alter table table_name  drop field_name;Query OK, 0 rows affected (0.92 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| ID    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(10)      | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.00 sec)</code></pre><p>如果数据表中只剩余一个字段则无法使用drop来删除字段。</p><h4 id="增加表字段"><a class="header-anchor" href="#增加表字段">¶</a>增加表字段</h4><p>mysql 中使用 add 子句来向数据表中添加列，如下实例在表 student 中添加 age 字段，并定义数据类型:</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> alter table student add age int unsigned not null;Query OK, 0 rows affected (0.53 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| ID    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(10)      | NO   |     | NULL    |                || age   | int(10) unsigned | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)</code></pre><p>执行以上命令后，field_name 字段会自动添加到数据表字段的末尾。</p><p>如果你需要指定新增字段的位置，可以使用mysql提供的关键字 first (设定位第一列)， after 字段名（设定位于某个字段之后）。</p><p>尝试以下 alter table 语句, 在执行成功后，使用 show columns 查看表结构的变化：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> desc student;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| name  | varchar(10)      | NO   |     | NULL    |       || age   | int(10) unsigned | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.00 sec)mysql> alter table student add id int unsigned auto_increment primary key first;Query OK, 0 rows affected (0.56 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(10)      | NO   |     | NULL    |                || age   | int(10) unsigned | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql> alter table student add class int unsigned after id;Query OK, 0 rows affected (0.54 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || class | int(10) unsigned | YES  |     | NULL    |                || name  | varchar(10)      | NO   |     | NULL    |                || age   | int(10) unsigned | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)</code></pre><p>first 和 after 关键字可用于 add 与 modify 子句，所以如果你想重置数据表字段的位置就需要先使用 drop 删除字段然后使用 add 来添加字段并设置位置。</p><h4 id="修改表字段"><a class="header-anchor" href="#修改表字段">¶</a>修改表字段</h4><p>如果需要修改字段类型及名称, 你可以在alter命令中使用 modify 或 change 子句 。</p><p>例如，把字段 class 的类型从 int unsigned 改为 varchar(10)，可以执行以下命令:</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || class | int(10) unsigned | YES  |     | NULL    |                || name  | varchar(10)      | NO   |     | NULL    |                || age   | int(10) unsigned | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)mysql> alter table student modify class varchar(10);Query OK, 8 rows affected (0.69 sec)Records: 8  Duplicates: 0  Warnings: 0mysql> desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || class | varchar(10)      | YES  |     | NULL    |                || name  | varchar(10)      | NO   |     | NULL    |                || age   | int(10) unsigned | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)</code></pre><p>使用 change 子句, 语法有很大的不同。 在 change 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。</p><p>当你修改字段时，你可以指定是否包含值或者是否设置默认值。</p><p>如果你不设置默认值，mysql会自动设置该字段默认为 null。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> alter table student change class class_room varchar(20) default "203";Query OK, 0 rows affected (0.10 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc student;+------------+------------------+------+-----+---------+----------------+| Field      | Type             | Null | Key | Default | Extra          |+------------+------------------+------+-----+---------+----------------+| id         | int(10) unsigned | NO   | PRI | NULL    | auto_increment || class_room | varchar(20)      | YES  |     | 203     |                || name       | varchar(10)      | NO   |     | NULL    |                || age        | int(10) unsigned | NO   |     | NULL    |                |+------------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)</code></pre><p>你可以使用 alter 来修改字段的默认值，尝试以下实例：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> alter table student alter class_room set default "205";Query OK, 0 rows affected (0.04 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc student;+------------+------------------+------+-----+---------+----------------+| Field      | Type             | Null | Key | Default | Extra          |+------------+------------------+------+-----+---------+----------------+| id         | int(10) unsigned | NO   | PRI | NULL    | auto_increment || class_room | varchar(20)      | YES  |     | 205     |                || name       | varchar(10)      | NO   |     | NULL    |                || age        | int(10) unsigned | NO   |     | NULL    |                |+------------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)</code></pre><p>你也可以使用 alter 命令及 drop子句来删除字段的默认值，如下实例：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> alter table student alter class_room drop default;Query OK, 0 rows affected (0.04 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc student;+------------+------------------+------+-----+---------+----------------+| Field      | Type             | Null | Key | Default | Extra          |+------------+------------------+------+-----+---------+----------------+| id         | int(10) unsigned | NO   | PRI | NULL    | auto_increment || class_room | varchar(20)      | YES  |     | NULL    |                || name       | varchar(10)      | NO   |     | NULL    |                || age        | int(10) unsigned | NO   |     | NULL    |                |+------------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)</code></pre><h4 id="修改数据表"><a class="header-anchor" href="#修改数据表">¶</a>修改数据表</h4><p>修改数据表类型，可以使用 alter table 命令来完成。</p><p>尝试以下实例，我们将表 student 的类型修改为 MyISAM ，然后再修改为 InnoDB：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> alter table student engine=myisam;Query OK, 8 rows affected (0.28 sec)Records: 8  Duplicates: 0  Warnings: 0mysql> show table status like "student"\G*************************** 1. row ***************************           Name: student         Engine: MyISAM        Version: 10     Row_format: Dynamic           Rows: 8 Avg_row_length: 20    Data_length: 160Max_data_length: 281474976710655   Index_length: 2048      Data_free: 0 Auto_increment: 9    Create_time: 2019-06-09 17:47:23    Update_time: 2019-06-09 17:47:23     Check_time: NULL      Collation: utf8_general_ci       Checksum: NULL Create_options:        Comment:1 row in set (0.00 sec)mysql> alter table students engine=innodb;Query OK, 8 rows affected (0.76 sec)Records: 8  Duplicates: 0  Warnings: 0mysql> show table status where name="students"\G*************************** 1. row ***************************           Name: students         Engine: InnoDB        Version: 10     Row_format: Dynamic           Rows: 8 Avg_row_length: 2048    Data_length: 16384Max_data_length: 0   Index_length: 0      Data_free: 0 Auto_increment: 9    Create_time: 2019-06-09 17:54:53    Update_time: 2019-06-09 17:54:53     Check_time: NULL      Collation: utf8_general_ci       Checksum: NULL Create_options:        Comment:1 row in set (0.00 sec)</code></pre><p>如果需要修改数据表的名称，可以在 alter table 语句中使用 rename 子句来实现。</p><p>尝试以下实例将数据表 student 重命名为 students：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> alter table student rename to students;Query OK, 0 rows affected (0.00 sec)mysql> show tables;+-------------------+| Tables_in_my_data |+-------------------+| students          |+-------------------+1 row in set (0.00 sec)</code></pre><h3 id="20-临时表"><a class="header-anchor" href="#20-临时表">¶</a>20. 临时表</h3><p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</p><p>如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。</p><h4 id="创建临时表"><a class="header-anchor" href="#创建临时表">¶</a>创建临时表</h4><p>使用temporary关键字创建临时表</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create temporary table class_room(room_id int unsigned primary key, class varchar(20) ) default charset=utf8;Query OK, 0 rows affected (0.00 sec)mysql> insert into class_room values(205,"九年级一班");Query OK, 1 row affected (0.00 sec)mysql> select * from class_room;+---------+-----------------+| room_id | class           |+---------+-----------------+|     205 | 九年级一班      |+---------+-----------------+1 row in set (0.00 sec)mysql> desc class_room;+---------+------------------+------+-----+---------+-------+| Field   | Type             | Null | Key | Default | Extra |+---------+------------------+------+-----+---------+-------+| room_id | int(10) unsigned | NO   | PRI | NULL    |       || class   | varchar(20)      | YES  |     | NULL    |       |+---------+------------------+------+-----+---------+-------+2 rows in set (0.00 sec)mysql> show tables;+-------------------+| Tables_in_my_data |+-------------------+| students          |+-------------------+1 row in set (0.00 sec)</code></pre><p>当你使用 show tables命令显示数据表列表时，你将无法看到 class_room表。</p><p>如果你退出当前mysql会话，再使用 select命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。</p><h4 id="删除临时表"><a class="header-anchor" href="#删除临时表">¶</a>删除临时表</h4><p>默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 DROP TABLE 命令来手动删除临时表。</p><p>以下是手动删除临时表的实例：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> drop table class_room;Query OK, 0 rows affected (0.00 sec)mysql> select * from class_room;ERROR 1146 (42S02): Table 'my_data.class_room' doesn't exist</code></pre><h3 id="21-复制表"><a class="header-anchor" href="#21-复制表">¶</a>21. 复制表</h3><p>如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用create table … select 命令，是无法实现的。</p><p><strong>实例</strong><br>尝试以下实例来复制表 runoob_tbl 。</p><p>步骤一：</p><p>获取数据表的完整结构。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> show create table students\G;*************************** 1. row ***************************       Table: studentsCreate Table: CREATE TABLE `students` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(10) NOT NULL,  `class_room` varchar(20) DEFAULT '205',  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf81 row in set (0.00 sec)ERROR:No query specified</code></pre><p>步骤二：</p><p>修改SQL语句的数据表名，并执行SQL语句。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table `student` (`id` int(10) unsigned not null auto_increment,`name` varchar(10) not null,`class_room` varchar(20) default '205', primary key (`id`)) engine=innodb auto_increment=9 default charset=utf8;Query OK, 0 rows affected (0.59 sec)</code></pre><p>步骤三：</p><p>执行完第二步骤后，你将在数据库中创建新的克隆表 student。 如果你想拷贝数据表的数据你可以使用 insert into… select 语句来实现。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> insert into student(id,name,class_room) select * from students;Query OK, 8 rows affected (0.00 sec)Records: 8  Duplicates: 0  Warnings: 0mysql> select * from student;+----+--------+------------+| id | name   | class_room |+----+--------+------------+|  1 | 李华   | 205        ||  2 | 敏柔   | 205        ||  3 | 赵强   | 205        ||  4 | 罗晴   | 205        ||  5 | 李磊   | 205        ||  6 | 寒梅   | 205        ||  7 | 张雷   | 205        ||  8 | 莉莉   | 205        |+----+--------+------------+8 rows in set (0.00 sec)</code></pre><h3 id="22-处理重复数据"><a class="header-anchor" href="#22-处理重复数据">¶</a>22. 处理重复数据</h3><p>有些 MySQL 数据表中可能存在重复的记录，有些情况我们允许重复数据的存在，但有时候我们也需要删除这些重复的数据。</p><h4 id="防止表中出现重复数据"><a class="header-anchor" href="#防止表中出现重复数据">¶</a>防止表中出现重复数据</h4><p>你可以在 MySQL 数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。</p><p>如果你想设置表中字段 id，name 数据不能重复，你可以设置双主键模式来设置数据的唯一性， 如果你设置了双主键，那么那个键的默认值不能为 NULL，可设置为 NOT NULL。如下所示：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table teachers(id int unsigned auto_increment, name varchar(10), gender varchar(5), primary key(id,name));Query OK, 0 rows affected (0.26 sec)mysql> desc teachers;+--------+------------------+------+-----+---------+----------------+| Field  | Type             | Null | Key | Default | Extra          |+--------+------------------+------+-----+---------+----------------+| id     | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name   | varchar(10)      | NO   | PRI | NULL    |                || gender | varchar(5)       | YES  |     | NULL    |                |+--------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)</code></pre><p>如果我们设置了唯一索引，那么在插入重复数据时，SQL 语句将无法执行成功,并抛出错。</p><p>insert ignore into 与 insert into 的区别就是 insert ignore 会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> insert into teachers values(1, "李磊", "男");Query OK, 1 row affected (0.00 sec)mysql> insert into teachers values(1, "李磊", "男");ERROR 1062 (23000): Duplicate entry '1-李磊' for key 'PRIMARY'mysql> insert ignore into teachers values(1, "李磊", "男");Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><p>INSERT IGNORE INTO 当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而 REPLACE INTO 如果存在 primary 或 unique 相同的记录，则先删除掉。再插入新记录。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> replace into teachers values(1, "李磊", "女");Query OK, 2 rows affected (0.00 sec)mysql> select * from teachers;+----+--------+--------+| id | name   | gender |+----+--------+--------+|  1 | 李磊   | 女     |+----+--------+--------+1 row in set (0.00 sec)</code></pre><p>另一种设置数据的唯一性方法是添加一个 UNIQUE 索引，如下所示：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table person(first_name char(20) not null, last_name char(20) not null, gender char(10),unique (last_name, first_name)) charset=utf8;Query OK, 0 rows affected (0.25 sec)mysql> insert ignore into person values("李", "雷", "男");Query OK, 1 row affected (0.00 sec)mysql> insert ignore into person values("李", "雷", "男");Query OK, 0 rows affected, 1 warning (0.00 sec)mysql> insert ignore into person values("李", "丽", "女");Query OK, 1 row affected (0.00 sec)mysql> select * from person;+------------+-----------+--------+| first_name | last_name | gender |+------------+-----------+--------+| 李         | 丽        | 女     || 李         | 雷        | 男     |+------------+-----------+--------+2 rows in set (0.00 sec)</code></pre><h4 id="统计重复数据"><a class="header-anchor" href="#统计重复数据">¶</a>统计重复数据</h4><p>以下我们将统计表中 first_name 和 last_name的重复记录数：</p><ul><li>创建person_info表，并插入3条重复数据</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table person_info(id int unsigned primary key auto_increment,first_name char(20) not null, last_name char(20) not null, gender char(10)) charset=utf8;Query OK, 0 rows affected (0.29 sec)mysql> insert ignore into person_info values(0,"李", "丽", "女");Query OK, 1 row affected (0.00 sec)mysql> insert ignore into person_info values(0,"李", "丽", "女");Query OK, 1 row affected (0.00 sec)mysql> insert ignore into person_info values(0,"李", "丽", "女");Query OK, 1 row affected (0.00 sec)mysql> select * from person_info;+----+------------+-----------+--------+| id | first_name | last_name | gender |+----+------------+-----------+--------+|  1 | 李         | 丽        | 女     ||  2 | 李         | 丽        | 女     ||  3 | 李         | 丽        | 女     |+----+------------+-----------+--------+3 rows in set (0.00 sec)</code></pre><ul><li>查询重复数据</li></ul><pre class=" language-language-bash"><code class="language-language-bash">mysql> select count(*) as repetitions,last_name,first_name from person_info group by last_name, first_name having repetitions > 1;+-------------+-----------+------------+| repetitions | last_name | first_name |+-------------+-----------+------------+|           3 | 丽        | 李         |+-------------+-----------+------------+1 row in set (0.00 sec)</code></pre><p>以上查询将返回 person_info 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作：</p><ul><li>确定哪一列包含的值可能会重复。</li><li>在列选择列表使用count(*)列出的那些列。</li><li>在group by子句中列出的列。</li><li>having子句设置重复数大于1。</li></ul><h4 id="过滤重复数据"><a class="header-anchor" href="#过滤重复数据">¶</a>过滤重复数据</h4><p>如果你需要读取不重复的数据可以在 select 语句中使用 distinct 关键字来过滤重复数据。</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select distinct first_name,last_name from person_info;+------------+-----------+| first_name | last_name |+------------+-----------+| 李         | 丽        |+------------+-----------+1 row in set (0.00 sec)</code></pre><p>你也可以使用 group by 来读取数据表中不重复的数据：</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> select first_name, last_name  from person_info group by last_name, first_name;+------------+-----------+| first_name | last_name |+------------+-----------+| 李         | 丽        |+------------+-----------+1 row in set (0.01 sec)</code></pre><h4 id="删除重复数据"><a class="header-anchor" href="#删除重复数据">¶</a>删除重复数据</h4><p>如果你想删除数据表中的重复数据，你可以使用以下的SQL语句：</p><h5 id="方法一"><a class="header-anchor" href="#方法一">¶</a>方法一</h5><p>先创建临时表tab,新表tab中的数据时从person_info表中分组查询出来的</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> create table tmp select last_name, first_name, gender from person_info  group by last_name, first_name, gender;Query OK, 1 row affected (0.01 sec)Records: 1  Duplicates: 0  Warnings: 0</code></pre><p>在表的第一位添加主键</p><pre class=" language-language-bash"><code class="language-language-bash">alter table tmp add column `id` bigint(20) primary key not null auto_increment comment 'id' first;</code></pre><p>删除原表</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> drop table person_info;Query OK, 0 rows affected (0.01 sec)</code></pre><p>重命名为person_info</p><pre class=" language-language-bash"><code class="language-language-bash">mysql> alter table tmp rename to person_info;Query OK, 0 rows affected (0.01 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础-路由反向解析</title>
      <link href="/2019/05/25/django-lu-you-fan-xiang-jie-xi/"/>
      <url>/2019/05/25/django-lu-you-fan-xiang-jie-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Django2.0 新增了在 <a href="http://urls.py" target="_blank" rel="noopener">urls.py</a> 中 <code>app_name</code> 来指定 namespace。我们之前通过 <code>reverse</code> 函数来反向获取 url</p></blockquote><h2 id="reverse-语法"><a class="header-anchor" href="#reverse-语法">¶</a>reverse 语法</h2><pre class=" language-language-python"><code class="language-language-python">reverse("<namespace>:<url-name>", kwargs={"<kwarg>": "<val>"})</code></pre><h2 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h2><h3 id="路由定义"><a class="header-anchor" href="#路由定义">¶</a>路由定义</h3><p>在项目的总路由中，可以通过指定namespace来确定应用</p><pre class=" language-language-python"><code class="language-language-python">urlpatterns = [    path(r'users/', include(('users.urls', 'userss')))]</code></pre><p>更进一步,把 namespace 定义到被 include 的  子路由<code>users/urls.py</code> 中去使用 app_name 定义名称空间</p><pre class=" language-language-python"><code class="language-language-python">from django.urls import re_path, pathfrom users.views import RegisterView, LoginView, DetailView, IndexViewapp_name = 'users'urlpatterns = [  path('detail/<int:uid>/', DetailView.as_view(), name="detail"),  path("", IndexView, name="index")]</code></pre><h3 id="反向解析"><a class="header-anchor" href="#反向解析">¶</a>反向解析</h3><p>现在我们仍然可以用 reverse 函数和模板中的 url 获取 URL</p><pre class=" language-language-python"><code class="language-language-python">reverse("users:index")reverse("users:detail", kwargs={"uid": 2020}){% url "users:index" %}{% url "users:detail" uid=2020 %}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> namespace </tag>
            
            <tag> app_name </tag>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见函数的时间复杂度</title>
      <link href="/2019/05/25/suan-fa-shi-jian-fu-za-du-02-chang-jian-han-shu-de-shi-jian-fu-za-du/"/>
      <url>/2019/05/25/suan-fa-shi-jian-fu-za-du-02-chang-jian-han-shu-de-shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p>很多函数都有自己的很多方法，其中有些方法的功能类似，但是其复杂度有时却大不相同</p><p>本节我们将引入一个新模块 <code>timeit</code> ，其功能是来测试一小段 <code>Python</code> 代码的执行速度。</p><a id="more"></a><h3 id="1、timeit"><a class="header-anchor" href="#1、timeit">¶</a>1、timeit</h3><pre class=" language-language-python"><code class="language-language-python">class timeit.Timer(stmt='pass', setup='pass',timer=<timer function>)</code></pre><ul><li><p><code>Timer</code> 是测量小段代码执行速度的类</p></li><li><p><code>stmt</code> 是要测试的代码语句 (<code>statment</code>), 字符串类型,</p></li><li><p><code>setup</code> 是运行代码时需要的设置 , 字符串类型, 就是从 <code>__main__</code> 引入需要的是的方法名</p></li><li><p><code>timer</code> 参数是一个定时器函数, 与平台有关, 不用去管</p></li><li><p><code>timeit.Timer.timeit(numer=1000000)</code>，<code>numer</code>-&gt; 测算次数, 返回平均耗时, 一个 <code>float</code> 类型的秒数</p></li></ul><h4 id="部分测试示例"><a class="header-anchor" href="#部分测试示例">¶</a>部分测试示例</h4><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526105816-timeit%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B%20.png" alt="20190526105816-timeit测试示例"></p><h4 id="测试结果"><a class="header-anchor" href="#测试结果">¶</a>测试结果</h4><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526105825-timeit%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%20.png" alt="20190526105825-timeit测试结果"></p><h3 id="2、list-的内置函数时间复杂度"><a class="header-anchor" href="#2、list-的内置函数时间复杂度">¶</a>2、list 的内置函数时间复杂度</h3><table><thead><tr><th>方法</th><th>复杂度</th><th>简介</th></tr></thead><tbody><tr><td>index[x]</td><td>O(1)</td><td>索引</td></tr><tr><td>index assignment</td><td>O(1)</td><td>索引赋值</td></tr><tr><td>append</td><td>O(1)</td><td>尾部追加</td></tr><tr><td>pop()</td><td>O(1)</td><td>尾部弹出</td></tr><tr><td>pop(i)</td><td>O(n)</td><td>指定位置弹出 n 列表长度, 最坏时间复杂度</td></tr><tr><td>insert(i, item)</td><td>O(n)</td><td>指定位置添加</td></tr><tr><td>del operator</td><td>O(n)</td><td>删除, 代表一个一个元素去清空</td></tr><tr><td>iteration</td><td>O(n)</td><td>迭代</td></tr><tr><td>contains(in)</td><td>O(n)</td><td>看谁是否在列表中, 需要遍历</td></tr><tr><td>get slice[x:y]</td><td>O(k)</td><td>取切片, 从 x 取到 y, 一次定位到 x, 然后取到 y ,x 和 y 之间有多少就是 k</td></tr><tr><td>del slice</td><td>O(n)</td><td>删除切片 删除位置之后, 后面的元素都需要往前移动</td></tr><tr><td>set slice</td><td>O(k)</td><td>设置切片, li[0:3] = [1, 2, 3, 4]k 是补充的东西数量</td></tr><tr><td>reverse</td><td>O(n)</td><td>置返</td></tr><tr><td>concatenate</td><td>O(k)</td><td>代表使用的 +, 把两个列表加到一起, k 是第二个列表中的元素</td></tr><tr><td>sort</td><td>O(nlogn)</td><td>排序</td></tr><tr><td>multiply</td><td>O(nk)</td><td>相乘 li=[1, 2] -&gt; n li * 10 -&gt; k</td></tr></tbody></table><h3 id="3、dict-的内置函数时间复杂度"><a class="header-anchor" href="#3、dict-的内置函数时间复杂度">¶</a>3、dict 的内置函数时间复杂度</h3><table><thead><tr><th>方法</th><th>复杂度</th><th>简介</th></tr></thead><tbody><tr><td>copy</td><td>O(n)</td><td>复制</td></tr><tr><td>get item</td><td>O(1)</td><td>取</td></tr><tr><td>set item</td><td>O(1)</td><td>设置</td></tr><tr><td>delete item</td><td>O(1)</td><td>删除键</td></tr><tr><td>contains(in)</td><td>O(1)</td><td>包含</td></tr><tr><td>iteration</td><td>O(n)</td><td>迭代</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 时间复杂度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>O标记法与常见时间复杂度</title>
      <link href="/2019/05/25/suan-fa-shi-jian-fu-za-du-01-o-biao-ji-fa-yu-chang-jian-shi-jian-fu-za-du/"/>
      <url>/2019/05/25/suan-fa-shi-jian-fu-za-du-01-o-biao-ji-fa-yu-chang-jian-shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法 : 内功心法, 是解决问题的一种思想</p></blockquote><a id="more"></a><h3 id="1、时间复杂度-T-n"><a class="header-anchor" href="#1、时间复杂度-T-n">¶</a>1、时间复杂度 $T(n)$</h3><p>由于每台机器的性能有所差别，所有其执行相同代码的时间也长短不一，故而推出一种计量方式，统计代码执行基本运算（<code>函数调用需要看其源码的基本运算</code>）的数量（<code>n</code>) 来确定一个算法的优劣，其中基本运算的<strong>循环按乘法计算，顺序结构按加法计算，分支结构取最大值</strong>。</p><pre class=" language-language-python"><code class="language-language-python">for a in range(0, 1000):     for b in range(0, 1000):        for c in range(0, 1000):            if a+b+c == 1000 and a**2 + b**2 + c**2:                print('a,b,c,: {}, {}, {}'.format(a,b,c))</code></pre><p>上述代码的时间复杂度为<br>$T = 1000 * 1000 * 1000 * 2$<br>那么如果将上述代码中的 1000 改为 2000， 则<br>$T = 2000 * 2000 * 2000 * 2$<br>由于上述同样的代码由于不同的参数的 T 都不同，我们便将其统一成 <strong>N</strong>，这样上述代码的时间复杂度可以表示成：<br>$T = N * N * N * 2$<br>同样的我们抓住其主要 “<strong>矛盾</strong>” ，观其大，再将其简化成<br>$T= N^3$<br>这样同一段代码的时间复杂度便不会根据其参数而发生改变了。</p><h3 id="2、大-O-标记法-O"><a class="header-anchor" href="#2、大-O-标记法-O">¶</a>2、大 $O$ 标记法 $O()$</h3><p>其实和求极限的原理相似，抓住问题的主要矛盾，忽略那些细枝末节，也就像前面的 $T$的最后的样子。</p><h3 id="3、时间复杂度的几条基本规则"><a class="header-anchor" href="#3、时间复杂度的几条基本规则">¶</a>3、时间复杂度的几条基本规则</h3><ol><li><p>基本步骤: 即只有常数项, 算作 $O(1)$</p></li><li><p>基本结构顺序, 条件, 循环</p><ul><li><p>顺序结构: 按加法运算</p></li><li><p>循环结构: 乘法</p></li><li><p>分支结构: 取最大值</p></li></ul></li><li><p>判断一个算法效率, 往往只需要关注操作数量的最高次项, 其他次要的忽略</p></li><li><p>没特殊说明, 分析的时间复杂度都是<strong>最坏时间复杂度</strong></p></li></ol><h3 id="4、常见的时间复杂度"><a class="header-anchor" href="#4、常见的时间复杂度">¶</a>4、常见的时间复杂度</h3><table><thead><tr><th>$T$</th><th>$O$</th><th>名称</th></tr></thead><tbody><tr><td>$12$</td><td>$O(1)$</td><td>常数阶</td></tr><tr><td>$2n+3$</td><td>$O(n)$</td><td>线性阶</td></tr><tr><td>$3n^2+2n+1$</td><td>$O(n^2)$</td><td>平方阶</td></tr><tr><td>$5log2n+20$</td><td>$O(log(n))$</td><td>对数阶</td></tr><tr><td>$2n+3nlog2n+19$</td><td>$O(nlog(n))$</td><td>$nlog(n)$ 阶</td></tr><tr><td>$6n<sup>3+2n</sup>2+3n+4$</td><td>$O(n^3)$</td><td>立方阶</td></tr><tr><td>$2^n$</td><td>$O(2^n)$</td><td>指数阶</td></tr></tbody></table><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526105531-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9B%B2%E7%BA%BF%E5%9B%BE%20.png" alt="20190526105531-时间复杂度曲线图"></p><p>$$<br>O(1) &lt; O(log(n)) &lt; O(n) &lt; O(nlog(n)) &lt; O(n^2)&lt; O(n ^ 2log(n)) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 时间复杂度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10设置开机自启</title>
      <link href="/2019/05/25/xi-tong-win10-she-zhi-kai-ji-zi-qi/"/>
      <url>/2019/05/25/xi-tong-win10-she-zhi-kai-ji-zi-qi/</url>
      
        <content type="html"><![CDATA[<p>刚开始接触 win10 的朋友肯定不知道在哪里把自己常用的软件设置成开机启动，因为你根本找不到前面的 xp、win7、win8，等里面的启动文件夹。</p><h2 id="工具-原料"><a class="header-anchor" href="#工具-原料">¶</a>工具 / 原料</h2><ul><li>win10 系统电脑一台</li></ul><h2 id="方法-步骤"><a class="header-anchor" href="#方法-步骤">¶</a>方法 / 步骤</h2><ol><li><p>如果想要实现应用程序在所有的用户登录系统后都能自动启动，就把该应用程序的快捷方式放到 “系统启动文件夹” 里；<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526103017-win10%E5%BC%80%E5%A7%8B_01%20.png" alt="20190526103017-win10开始_01"></p></li><li><p>上面的方法有的朋友可能找不到路径，没有关系，你可以把上面的路径直接复制到地址栏里面打开即可。如下图<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526103044-win10%E5%BC%80%E5%A7%8B_02%20.png" alt="20190526103044-win10开始_02"></p></li><li><p>同样也可以用系统命令来打开 “启动文件夹”。在运行里面输入：<code>shell:startup</code><br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526103052-win10%E5%BC%80%E5%A7%8B_03%20.png" alt="20190526103052-win10开始_03"></p></li><li><p>或者输入：<code>%programdata%\Microsoft\Windows\Start Menu\Programs\Startup</code><br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526103102-win10%E5%BC%80%E5%A7%8B_04%20.png" alt="20190526103102-win10开始_04"></p></li><li><p>上面那种命令都可以打开系统启动文件夹的；同样，打开之后把要启动的软件放进去即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开机自启 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内置函数</title>
      <link href="/2019/05/25/python-han-shu-nei-zhi-han-shu/"/>
      <url>/2019/05/25/python-han-shu-nei-zhi-han-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="python内置函数"><a class="header-anchor" href="#python内置函数">¶</a>python内置函数</h3><blockquote><p>Python 内置函数就是 python 标准库里（语言自身携带的）函数（公共函数）。</p></blockquote><p>那么，接下来就来谈一谈 python 里的内置函数</p><h4 id="1、abs"><a class="header-anchor" href="#1、abs">¶</a>1、<code>abs()</code></h4><blockquote><p>此函数返回数字的绝对值。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">a = 5b = -10print(abs(a))  #输出3print(abs(b))  #输出5</code></pre><h4 id="2、all"><a class="header-anchor" href="#2、all">¶</a>2、<code>all()</code></h4><blockquote><p>此函数用于判断给定的可迭代参数 <code>iterable</code> 中的所有元素是否都不为 <code>0</code>、都不为 <code>False</code> 或者 <code>iterable</code> 都 为空,如果是返回 <code>True</code>, 否则返回 <code>False</code>。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">print(all(['a', 'b', 'c', 'd']))  # Trueprint(all(['a', 'b', '', 'd']))   # Falseprint(all([0, 1,2, 3]))          # Falseprint(all(('a', 'b', '', 'd')))   # Falseprint(all((0, 1,2, 3)))          # Falseprint(all([]))  # Trueprint(all(()))  # True</code></pre><h4 id="3、any"><a class="header-anchor" href="#3、any">¶</a>3、<code>any()</code></h4><blockquote><p>函数用于判断给定的可迭代参数 <code>iterable</code> 是否全部为空对象,如果都为空、都为 0、或者都为 <code>false</code>，则返回 <code>False</code>,如果不都为空、不都为 <code>0</code>、不都为 <code>false</code>，则返回 <code>True</code>。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">print(any(['a', 'b', 'c', 'd']))  # Trueprint(any(['a', 'b', '', 'd']))   # Trueprint(any([0, 1,2, 3]))          # Trueprint(any(('a', 'b', '', 'd')))   # Trueprint(any((0, 1,2, 3)))          # Trueprint(any([]))  # Falseprint(any(()))  # False</code></pre><h4 id="4、bin"><a class="header-anchor" href="#4、bin">¶</a>4、<code>bin()</code></h4><blockquote><p>返回一个整数 <code>int</code> 或者长整数 <code>long int</code> 的二进制表示。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">print(bin(10))  #0b1010print(bin(20))  #0b10100</code></pre><h4 id="5、bool"><a class="header-anchor" href="#5、bool">¶</a>5、<code>bool()</code></h4><blockquote><p>函数用于将给定参数转换为布尔类型，如果没有参数，返回 <code>False</code>。</p></blockquote><ul><li><p>传入布尔类型时，按原值返回</p></li><li><p>参数如果缺省，则返回 <code>False</code></p></li><li><p>传入字符串时，空字符串返回 <code>False</code>，否则返回 <code>True</code></p></li><li><p>传入数值时，0 值返回 <code>False</code>，否则返回 <code>True</code></p></li><li><p>传入元组、列表、字典等对象时，元素个数为空返回 <code>False</code>，否则返回 <code>True</code>.</p></li></ul><pre class=" language-language-python"><code class="language-language-python">print(bool())  #Falseprint(bool(True))  #Trueprint(bool(""))  #Falseprint(bool("123"))  #Trueprint(bool(0))  #Falseprint(bool(1))  #Trueprint(bool([])) #False  若元祖和字典为空时 也为False ，不为空 则为True</code></pre><h4 id="6、chr"><a class="header-anchor" href="#6、chr">¶</a>6、<code>chr()</code></h4><blockquote><p>用一个范围在 <code>range(256)</code>内的（就是 <code>0～255</code>）整数作参数，返回一个对应的字符。(<strong>只能输入数字</strong>)</p></blockquote><pre class=" language-language-python"><code class="language-language-python">print(chr(65))   #Aprint(chr(97))   #aprint(chr(100))  #d</code></pre><h4 id="7、cmp-x-y"><a class="header-anchor" href="#7、cmp-x-y">¶</a>7、<code>cmp(x,y)</code></h4><blockquote><p>函数用于比较 2 个对象，如果<code>x &lt;y</code>返回<code> -1</code>, 如果 <code>x == y</code> 返回 <code>0</code>, 如果 <code>x&gt; y </code>返回 1。（<code>python3</code> 已经删除了）</p></blockquote><h4 id="8、compile"><a class="header-anchor" href="#8、compile">¶</a>8、<code>compile()</code></h4><blockquote><p>函数将一个字符串编译为字节代码。语法：<code>compile(source, filename, mode[, flags[, dont_inherit]])</code></p></blockquote><pre class=" language-language-python"><code class="language-language-python">import repattern=re.compile('[a-zA-Z]')result=pattern.findall('as3SiOPdj#@23awe')print(result)</code></pre><h4 id="9、complex-real-imag"><a class="header-anchor" href="#9、complex-real-imag">¶</a>9、<code>complex(real,imag)</code></h4><blockquote><p>函数用于创建一个值为 <code>real + imag * j</code> 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">print(complex(1, 2))  #(1 + 2j)print(complex(1))  #(1 + 0j)print(complex("3")) #(3+0j)</code></pre><h4 id="10、dict-kwarg"><a class="header-anchor" href="#10、dict-kwarg">¶</a>10、<code>dict(**kwarg)</code></h4><blockquote><p>返回一个字典</p></blockquote><pre class=" language-language-python"><code class="language-language-python">>>>dict()                        # 创建空字典{}>>> dict(a='a', b='b', t='t')     # 传入关键字{'a': 'a', 'b': 'b', 't': 't'}>>> dict(zip(['one', 'two', 'three'], [1, 2, 3]))   # 映射函数方式来构造字典{'three': 3, 'two': 2, 'one': 1} >>> dict([('one', 1), ('two', 2), ('three', 3)])    # 可迭代对象方式来构造字典{'three': 3, 'two': 2, 'one': 1}>>></code></pre><h4 id="11、dir-object"><a class="header-anchor" href="#11、dir-object">¶</a>11、<code>dir([object])   </code></h4><blockquote><p>函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；</p><p>带参数时，返回参数的属性、方法列表。</p><p>如果参数包含方法<code>__dir__()</code>，该方法将被调用。</p><p>如果参数不包含<code>__dir__()</code>，该方法将最大限度地收集参数信息。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">>>>dir()   #  获得当前模块的属性列表['__builtins__', '__doc__', '__name__', '__package__', 'arr', 'myslice']>>> dir([ ])    # 查看列表的方法['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']>>></code></pre><h4 id="12、divmod-a-b"><a class="header-anchor" href="#12、divmod-a-b">¶</a>12、<code>divmod(a, b)</code></h4><blockquote><p>函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组<code> (a // b, a % b)</code>。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">>>>divmod(7, 2)(3, 1)>>> divmod(8, 2)(4, 0)>>> divmod(1+2j,1+0.5j)((1+0j), 1.5j)</code></pre><h4 id="13、enumerate-sequence-start-0"><a class="header-anchor" href="#13、enumerate-sequence-start-0">¶</a>13、<code>enumerate(sequence, [start=0]) </code></h4><blockquote><p>函数用于将一个可遍历的数据对象 (如列表、元组或字符串) 组合为一个索引序列，同时列出数据和数据下标，一般用在<code> for</code> 循环当中。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">>>>seasons = ['Spring', 'Summer', 'Fall', 'Winter']>>> list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]>>> list(enumerate(seasons, start=1))       # 下标从 1 开始[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]</code></pre><h4 id="14、eval-函数用来执行一个字符串表达式，并返回表达式的值。"><a class="header-anchor" href="#14、eval-函数用来执行一个字符串表达式，并返回表达式的值。">¶</a>14、eval()    函数用来执行一个字符串表达式，并返回表达式的值。</h4><h4 id="15、execfile-函数可以用来执行一个文件。"><a class="header-anchor" href="#15、execfile-函数可以用来执行一个文件。">¶</a>15、execfile()    函数可以用来执行一个文件。</h4><h4 id="16、float-函数用于将整数和字符串转换成浮点数。"><a class="header-anchor" href="#16、float-函数用于将整数和字符串转换成浮点数。">¶</a>16、float()    函数用于将整数和字符串转换成浮点数。</h4><h4 id="17、frozenset-返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。"><a class="header-anchor" href="#17、frozenset-返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。">¶</a>17、frozenset()    返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</h4><h4 id="18、getattr-函数用于返回一个对象属性值。"><a class="header-anchor" href="#18、getattr-函数用于返回一个对象属性值。">¶</a>18、getattr()    函数用于返回一个对象属性值。</h4><h4 id="19、hash-用于获取取一个对象（字符串或者数值等）的哈希值。"><a class="header-anchor" href="#19、hash-用于获取取一个对象（字符串或者数值等）的哈希值。">¶</a>19、hash()    用于获取取一个对象（字符串或者数值等）的哈希值。</h4><h4 id="20、help-函数用于查看函数或模块用途的详细说明。"><a class="header-anchor" href="#20、help-函数用于查看函数或模块用途的详细说明。">¶</a>20、help()    函数用于查看函数或模块用途的详细说明。</h4><h4 id="21、hex-函数用于将-10-进制整数转换成-16-进制整数。"><a class="header-anchor" href="#21、hex-函数用于将-10-进制整数转换成-16-进制整数。">¶</a>21、hex()    函数用于将 10 进制整数转换成 16 进制整数。</h4><h4 id="22、id-函数用于获取对象的内存地址。"><a class="header-anchor" href="#22、id-函数用于获取对象的内存地址。">¶</a>22、id()    函数用于获取对象的内存地址。</h4><h4 id="23、input-输入函数"><a class="header-anchor" href="#23、input-输入函数">¶</a>23、input()    输入函数</h4><h4 id="24、int-函数用于将一个字符串会数字转换为整型。"><a class="header-anchor" href="#24、int-函数用于将一个字符串会数字转换为整型。">¶</a>24、int()    函数用于将一个字符串会数字转换为整型。</h4><h4 id="25、isinstance-函数来判断一个对象是否是一个已知的类型，类似-type-。"><a class="header-anchor" href="#25、isinstance-函数来判断一个对象是否是一个已知的类型，类似-type-。">¶</a>25、isinstance()    函数来判断一个对象是否是一个已知的类型，类似 type()。</h4><p><strong>isinstance() 与 type() 区别：</strong></p><ul><li><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p></li><li><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p></li><li><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p></li></ul><h4 id="26、len-方法返回对象（字符、列表、元组等）长度或项目个数。"><a class="header-anchor" href="#26、len-方法返回对象（字符、列表、元组等）长度或项目个数。">¶</a>26、len()    方法返回对象（字符、列表、元组等）长度或项目个数。</h4><h4 id="27、list-方法用于将元组转换为列表。"><a class="header-anchor" href="#27、list-方法用于将元组转换为列表。">¶</a>27、list()    方法用于将元组转换为列表。</h4><h4 id="28、locals-函数会以字典类型返回当前位置的全部局部变量。"><a class="header-anchor" href="#28、locals-函数会以字典类型返回当前位置的全部局部变量。">¶</a>28、locals()    函数会以字典类型返回当前位置的全部局部变量。</h4><h4 id="29、long-函数将数字或字符串转换为一个长整型。"><a class="header-anchor" href="#29、long-函数将数字或字符串转换为一个长整型。">¶</a>29、long()    函数将数字或字符串转换为一个长整型。</h4><h4 id="30、max-方法返回给定参数的最大值，参数可以为序列。"><a class="header-anchor" href="#30、max-方法返回给定参数的最大值，参数可以为序列。">¶</a>30、max()    方法返回给定参数的最大值，参数可以为序列。</h4><h4 id="31、memoryview-函数返回给定参数的内存查看对象-Momory-view-。"><a class="header-anchor" href="#31、memoryview-函数返回给定参数的内存查看对象-Momory-view-。">¶</a>31、memoryview()    函数返回给定参数的内存查看对象 (Momory view)。</h4><h4 id="32、min-方法返回给定参数的最小值，参数可以为序列。"><a class="header-anchor" href="#32、min-方法返回给定参数的最小值，参数可以为序列。">¶</a>32、min()    方法返回给定参数的最小值，参数可以为序列。</h4><h4 id="33、oct-函数将一个整数转换成-8-进制字符串。"><a class="header-anchor" href="#33、oct-函数将一个整数转换成-8-进制字符串。">¶</a>33、oct()    函数将一个整数转换成 8 进制字符串。</h4><h4 id="34、open-函数用于打开一个文件，创建一个-file-对象，相关的方法才可以调用它进行读写。"><a class="header-anchor" href="#34、open-函数用于打开一个文件，创建一个-file-对象，相关的方法才可以调用它进行读写。">¶</a>34、open()    函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。</h4><h4 id="35、ord-函数与-chr-函数相反，输入字符返回数字"><a class="header-anchor" href="#35、ord-函数与-chr-函数相反，输入字符返回数字">¶</a>35、ord()    函数与 chr() 函数相反，输入字符返回数字</h4><h4 id="36、pow-方法返回-xy（x-的-y-次方）-的值。函数是计算-x-的-y-次方，如果-z-在存在，则再对结果进行取模，其结果等效于-pow-x-y-z"><a class="header-anchor" href="#36、pow-方法返回-xy（x-的-y-次方）-的值。函数是计算-x-的-y-次方，如果-z-在存在，则再对结果进行取模，其结果等效于-pow-x-y-z">¶</a>36、pow()    方法返回 xy（x 的 y 次方） 的值。函数是计算 x 的 y 次方，如果 z 在存在，则再对结果进行取模，其结果等效于 pow(x,y) %z</h4><h4 id="37、print-输出函数"><a class="header-anchor" href="#37、print-输出函数">¶</a>37、print()    输出函数</h4><h4 id="38、range-函数可创建一个整数列表，一般用在-for-循环中。"><a class="header-anchor" href="#38、range-函数可创建一个整数列表，一般用在-for-循环中。">¶</a>38、range()    函数可创建一个整数列表，一般用在 for 循环中。</h4><h4 id="39、reload-用于重新载入之前载入的模块。"><a class="header-anchor" href="#39、reload-用于重新载入之前载入的模块。">¶</a>39、reload()    用于重新载入之前载入的模块。</h4><h4 id="40、everse-函数用于反向列表中元素。"><a class="header-anchor" href="#40、everse-函数用于反向列表中元素。">¶</a>40、everse()    函数用于反向列表中元素。</h4><h4 id="41、round-方法返回浮点数-x-的四舍五入值。"><a class="header-anchor" href="#41、round-方法返回浮点数-x-的四舍五入值。">¶</a>41、round()    方法返回浮点数 x 的四舍五入值。</h4><h4 id="42、set-函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。"><a class="header-anchor" href="#42、set-函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。">¶</a>42、set()    函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</h4><h4 id="43、str-函数将对象转化字符串"><a class="header-anchor" href="#43、str-函数将对象转化字符串">¶</a>43、str()    函数将对象转化字符串</h4><h4 id="44、sum-方法对系列进行求和计算。"><a class="header-anchor" href="#44、sum-方法对系列进行求和计算。">¶</a>44、sum()    方法对系列进行求和计算。</h4><h4 id="45、tuple-元组-tuple-函数将列表转换为元组。"><a class="header-anchor" href="#45、tuple-元组-tuple-函数将列表转换为元组。">¶</a>45、tuple()   元组 tuple() 函数将列表转换为元组。</h4><h4 id="46、type-返回对象类型。"><a class="header-anchor" href="#46、type-返回对象类型。">¶</a>46、type()   返回对象类型。</h4><h4 id="47、unichr-该函数和-chr-函数功能基本一样，-只不过是返回-unicode-的字符。"><a class="header-anchor" href="#47、unichr-该函数和-chr-函数功能基本一样，-只不过是返回-unicode-的字符。">¶</a>47、unichr()    该函数和 chr() 函数功能基本一样， 只不过是返回 unicode 的字符。</h4><h4 id="48、vars-函数返回对象-object-的属性和属性值的字典对象。"><a class="header-anchor" href="#48、vars-函数返回对象-object-的属性和属性值的字典对象。">¶</a>48、vars()    函数返回对象 object 的属性和属性值的字典对象。</h4><h4 id="49、xrange-函数用法与-range-完全相同，所不同的是生成的不是一个数组，而是一个生成器。"><a class="header-anchor" href="#49、xrange-函数用法与-range-完全相同，所不同的是生成的不是一个数组，而是一个生成器。">¶</a>49、xrange()    函数用法与 range 完全相同，所不同的是生成的不是一个数组，而是一个生成器。</h4><h4 id="50、import-函数用于动态加载类和函数-。如果一个模块经常变化就可以使用-import-来动态载入。"><a class="header-anchor" href="#50、import-函数用于动态加载类和函数-。如果一个模块经常变化就可以使用-import-来动态载入。">¶</a>50、<strong>import</strong>()    函数用于动态加载类和函数 。如果一个模块经常变化就可以使用 <strong>import</strong>() 来动态载入。</h4>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 基础 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10 python2和python3共存问题</title>
      <link href="/2019/05/25/gong-ju-win10-pyhton2-he-3-gong-cun/"/>
      <url>/2019/05/25/gong-ju-win10-pyhton2-he-3-gong-cun/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>特别说明</strong>，本文是在 <strong>Windows64 位系统</strong>下进行的，32 位系统请下载相应版本的安装包，安装方法类似。</p></blockquote><a id="more"></a><h2 id="1、下载-python3-和-python2"><a class="header-anchor" href="#1、下载-python3-和-python2">¶</a>1、下载 python3 和 python2</h2><p>进入 python 官网，链接 <a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a></p><p>选择 Downloads—&gt;Windows，点击进入就可以看到寻找想要的 python 版本</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526103726-win10_download_py%20.png" alt="win10_download_py"></p><p>本文选择的是：</p><p>Python3.5.2, 点击后面链接可直接下载，<a href="https://www.python.org/ftp/python/3.5.2/python-3.5.2rc1-amd64.exe" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.5.2/python-3.5.2rc1-amd64.exe</a></p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526103746-win10_download_py3%20.png" alt="20190526103746-win10_download_py3"></p><p>Python2.7.9, 点击后面链接可直接下载，<a href="https://www.python.org/ftp/python/2.7.9/python-2.7.9.amd64.msi" target="_blank" rel="noopener">https://www.python.org/ftp/python/2.7.9/python-2.7.9.amd64.msi</a></p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526103737-win10_download_py2%20.png" alt="20190526103737-win10_download_py2"></p><h2 id="2、python3-安装"><a class="header-anchor" href="#2、python3-安装">¶</a>2、python3 安装</h2><blockquote><p><strong>说明:</strong> 本文先安装 python3，然后安装 python2</p></blockquote><p>首先选择安装目录，本文安装路径为 D:\Python\python35，然后点击下载好的 python3 软件包进行安装，具体流程如下：</p><ol><li><p>在下图红色标记的地方 Add Python3.5 to PATH 前勾选，可以直接将 python3 添加到系统环境变量，然后在 Customize installation 中自定义安装路径。<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104125-py3_%E5%AE%89%E8%A3%85_01%20.png" alt="20190526104125-py3_安装_01"></p></li><li><p>直接 next 即可<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104133-py3_%E5%AE%89%E8%A3%85_02%20.png" alt="20190526104133-py3_安装_02"></p></li><li><p>下图中 Advanced Options 中没有默认勾选的根据自己的需要进行勾选，黄色标记为 VS 2015 及其以后版本需要的，如果你以后打算在 VS 2015 中配置 python 环境请勾选此项，点击 Browse 选择安装目录，然后点击 Install 进行安装。<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104141-py3_%E5%AE%89%E8%A3%85_03%20.png" alt="20190526104141-py3_安装_03"></p></li><li><p>等待如下安装过程<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104253-py3_%E5%AE%89%E8%A3%85_04%20.png" alt="20190526104253-py3_安装_04"></p></li><li><p>安装成功<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104257-py3_%E5%AE%89%E8%A3%85_05%20.png" alt="20190526104257-py3_安装_05"></p></li><li><p>点击关闭，查看 python3 安装情况，按 “Win + R” 快捷键，在打开的 “运行” 对话框中，输入 “cmd” 按回车，进入如下界面，输入 python 查看 python3 安装情况，显示 python 3.5.2 的版本信息，则安装成功，可以输入语句 print(1 + 1)进行测试。<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104443-py3_%E5%AE%89%E8%A3%85_06%20.png" alt="20190526104443-py3_安装_06"></p></li></ol><h2 id="3、python2-安装"><a class="header-anchor" href="#3、python2-安装">¶</a>3、python2 安装</h2><ol><li><p>点击 python2 安装包，点击运行，next，选择安装目录，本文安装路径为 D:\Python\python27，然后 next<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104627-py2_%E5%AE%89%E8%A3%85_01%20.png" alt="20190526104627-py2_安装_01"></p></li><li><p>下图黄色圈出的部分，显示不能够添加路径到系统变量，不能够直接使用 python 命令没有关系，先点击 next 进行安装，后面专门解决。<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104634-py2_%E5%AE%89%E8%A3%85_02%20.png" alt="20190526104634-py2_安装_02"><br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104643-py2_%E5%AE%89%E8%A3%85_03%20.png" alt="20190526104643-py2_安装_03"></p></li><li><p>点击 finish 完成安装。<br>至此，python2 和 python3 安装完毕。</p></li></ol><blockquote><p>特别说明：此时运行 “cmd” 命令进入 DOS 命令提示框，输入 python 仍然显示 python3 版本。</p></blockquote><h2 id="4、配置环境变量"><a class="header-anchor" href="#4、配置环境变量">¶</a>4、配置环境变量</h2><p>打开，控制面板 \ 系统和安全 \ 系统，选择高级系统设置，环境变量，选择 Path，点击编辑，新建，分别添加 D:\Python\python27 和 D:\Python\python27\Scripts 到环境变量。</p><blockquote><p><strong>注意：</strong> python3 安装时可以选择自动添加到系统环境变量，如未选择，方法和 python2 添加过程相同。</p></blockquote><h2 id="5、重命名-python-exe"><a class="header-anchor" href="#5、重命名-python-exe">¶</a>5、重命名 python.exe</h2><ol><li><p>找到 python2 和 python3 的安装目录，修改 python2.7.9 和 python3.5.2 中 python.exe 和 pythonw.exe 的名称为 python2.exe、pythonw2.exe 和 python3.exe、pythonw3.exe。</p></li><li><p>然后在运行 cmd 命令，输入 python2 即可运行 python2.7.9 版本<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104936-py2_test%20.png" alt="20190526104936-py2_test"></p></li><li><p>输入 python3 即可运行 python3.5.2 版本<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526104944-py3_test%20.png" alt="20190526104944-py3_test"></p></li><li><p>至此，python2 和 python3 安装完毕。</p></li></ol><h2 id="6、pip2-和-pip3-设置"><a class="header-anchor" href="#6、pip2-和-pip3-设置">¶</a>6、pip2 和 pip3 设置</h2><ol><li><p>Python 安装包需要用到包管理工具 pip，但是当同时安装 python2 和 python3 的时候，pip 只是其中一个版本，以下将提供一个修改方式，即重新安装两个版本的 pip，使得两个 python 版本的 pip 能够共存。<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526105211-pip3%E5%AE%89%E8%A3%85%20.png" alt="20190526105211-pip3安装"></p></li><li><p>在 DOS 命令框输入命令，python2-m pip install --upgrade pip --force-reinstall，显示重新安装成功。<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526105206-pip2%E5%AE%89%E8%A3%85%20.png" alt="20190526105206-pip2安装"></p></li><li><p>现在可以通过 pip2 -V 和 pip3-V 查看两个版本的 pip 信息，以后只需运行 pip2install XXX 和 pip3 install XXX 即可安装各自的 python 包。<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190526105218-pip%E5%AE%89%E8%A3%85%E5%8C%85%20.png" alt="20190526105218-pip安装包"></p></li><li><p>至此，pip2 和 pip3 修改成功。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> python2 </tag>
            
            <tag> python3 </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则匹配</title>
      <link href="/2019/05/23/python-gao-ji-zheng-ze-pi-pei/"/>
      <url>/2019/05/23/python-gao-ji-zheng-ze-pi-pei/</url>
      
        <content type="html"><![CDATA[<h2 id="正则匹配"><a class="header-anchor" href="#正则匹配">¶</a>正则匹配</h2><ol><li>题目描述：</li></ol><p>现公司要开发一个业务管理系统，要求注册环节的密码需要提示用户其安全等级，密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分；此外，密码的组成可以由字母，数字，以及符号构成。</p><p>以下为密码分数判断选项，每项判断只能拿一个分项：</p><ul><li><p>密码长度:</p><ul><li>5 分: 小于等于4个字符</li><li>10 分: 5到7字符</li><li>25 分: 大于等于8个字符</li></ul></li><li><p>字母:</p><ul><li>0 分: 没有字母</li><li>10 分: 全都是小（大）写字母</li><li>20 分: 大小写混合字母</li></ul></li><li><p>数字:</p><ul><li>0 分: 没有数字</li><li>10 分: 1个数字</li><li>20 分: 大于1个数字</li></ul></li><li><p>符号:</p><ul><li>0 分: 没有符号</li><li>10 分: 1个符号</li><li>25 分: 大于1个符号</li></ul></li><li><p>奖励:</p><ul><li>2 分: 字母和数字</li><li>3 分: 字母、数字和符号</li><li>5 分: 大小写字母、数字和符号</li></ul></li></ul><p>最后的评分标准:</p><p>大于等于90: 非常安全<br>大于等于80: 安全<br>大于等于70: 非常强<br>大于等于 60: 强<br>大于等于 50: 一般<br>大于等于 25: 弱<br>大于等于0:  非常弱</p><p>当用户输入一个密码字符串后，判断密码等级，并输出</p><p>输入描述：</p><pre class=" language-language-shell"><code class="language-language-shell">b12A3%$123</code></pre><p>输出：</p><pre class=" language-language-shell"><code class="language-language-shell">非常安全</code></pre><p>代码实现如下：</p><pre class=" language-language-python"><code class="language-language-python">import redef s1(password):    if re.match(r".{,4}$", password):        return 5    if re.match(r".{5,7}$", password):        return 10    if re.match(r".{8,}$", password):        return 25def s2(password):    if re.match(r"[^a-zA-Z]*$", password):        return 0    if re.match(r"([a-z]*$)|([A-Z]*$)", password):        return 10    if re.match(r".*(?=.*[a-z])(?=.*[A-Z]).*$", password):        return 20def s3(password):    if re.match(r"[^\d]*$", password):        return 0    if re.match(r"[^\d]*[\d][^\d]*$", password):        return 10    if re.match(r".*[\d]+.*[\d]+.*$", password):        return 20def s4(password):    if re.match(r"[^!@#$%^&*?]*$", password):        return 0    if re.match(r"[^!@#$%^&*?]*[!@#$%^&*?][^!@#$%^&*?]*$", password):        return 10    if re.match(r".*[!@#$%^&*?]+.*[!@#$%^&*?]+.*$", password):        return 20def s5(password):    if re.match(r".*(?=.*\d.*$)(?=.*[!@#$%^&*?].*$)(?=.*[a-z].*$)(?=.*[A-Z].*$).*$", password):        return 5    if re.match(r"(?=.*\d.*$)(?=.*[!@#$%^&*?].*$)(?=.*[a-zA-Z].*$).*$", password):        return 3    if re.match(r".*(?=.*[\d].*$)(?=.*[a-zA-Z].*$).*$", password):        return 2password = input("请输入密码：")ret = sum((s1(password), s2(password), s3(password), s4(password), s5(password)))if ret >= 90:    print("非常安全")elif ret >= 80:    print("安全")elif ret >= 70:    print("非常强")elif ret >= 60:    print("强")elif ret >= 50:    print("一般")elif ret >= 25:    print("弱")else:    print("非常弱")</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python进程、线程、协程</title>
      <link href="/2019/05/17/python-gao-ji-jin-cheng-xian-cheng-xie-cheng/"/>
      <url>/2019/05/17/python-gao-ji-jin-cheng-xian-cheng-xie-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="python-线程与进程简介"><a class="header-anchor" href="#python-线程与进程简介">¶</a>python 线程与进程简介</h3><h4 id="1-进程与线程的历史"><a class="header-anchor" href="#1-进程与线程的历史">¶</a>1. 进程与线程的历史</h4><p>我们都知道计算机是由<strong>硬件</strong>和<strong>软件</strong>组成的。</p><ul><li>硬件中的 CPU 是计算机的核心，它承担计算机的所有任务。</li><li>操作系统是运行在硬件之上的软件，是计算机的管理者，它负责资源的管理和分配、任务的调度。</li><li>程序是运行在系统上的具有某种功能的软件，比如说浏览器，音乐播放器等。</li></ul><p>每次执行程序的时候，都会完成一定的功能，比如说浏览器帮我们打开网页，为了保证其独立性，就需要一个专门的管理和控制执行程序的数据结构——<strong>进程控制块</strong>。</p><p>进程就是一个程序在一个数据集上的一次动态执行过程。</p><ul><li><p>进程一般由程序、数据集、进程控制块三部分组成。</p><ul><li>我们编写的程序用来描述进程要完成哪些功能以及如何完成；</li><li>数据集则是程序在执行过程中所需要使用的资源；</li><li>进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。</li></ul></li><li><p>在早期的操作系统里，计算机只有一个核心，进程是执行程序的最小单位，任务调度采用时间片轮转的抢占式方式进行进程调度。</p></li><li><p>每个进程都有各自的一块独立的内存，保证进程彼此间的内存地址空间的隔离。</p></li></ul><p>随着计算机技术的发展，进程出现了很多弊端：</p><ul><li>一是进程的创建、撤销和切换的开销比较大</li><li>二是由于对称多处理机（对称多处理机（SymmetricalMulti-Processing）又叫 SMP，是指在一个计算机上汇集了一组处理器 (多 CPU)，各 CPU 之间共享内存子系统以及总线结构）的出现，可以满足多个运行单位，而多进程并行开销过大。</li></ul><p>这个时候就引入了线程的概念。</p><ul><li>线程也叫轻量级进程，它是一个基本的 CPU 执行单元，也是程序执行过程中的最小单元，由线程 ID、程序计数器、寄存器集合 和堆栈共同组成。</li><li>线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。</li><li>线程没有自己的系统资源，只拥有在运行时必不可少的资源。</li><li>但线程可以与同属与同一进程的其他线程共享进程所拥有的其他资源。</li></ul><h4 id="2-进程与线程之间的关系"><a class="header-anchor" href="#2-进程与线程之间的关系">¶</a>2.  进程与线程之间的关系</h4><ul><li>线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。</li><li>线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息 (如程序计数器、一组寄存器和栈)。</li></ul><h4 id="3-守护线程与守护进程的区别"><a class="header-anchor" href="#3-守护线程与守护进程的区别">¶</a>3. 守护线程与守护进程的区别</h4><blockquote><p>强调：运行完毕，并非是终止</p></blockquote><ul><li><p>线程与进程运行完毕的区别：</p><ul><li><p>主进程运行完毕指的是主进程代码运行完毕</p></li><li><p>主线程运行完毕指的是所在的进程内的所有非守护线程运行完毕后，主线程才算运行完毕</p></li></ul></li><li><p>守护进程：主进程代码运行完毕，守护进程也就结束 <strong>(守护的是主进程)</strong></p><ul><li><p>主进程要等非守护进程都运行完毕后再回收子进程的资源（否则会产生僵尸进程）才结束</p></li><li><p>主进程等子进程是因为主进程要给子进程收尸（代用wait方法向操作系统发起回收资源信号（pid号，状态信息））</p></li></ul></li><li><p>守护线程：非守护线程代码运行完毕，守护线程也就结束 <strong>(守护的是非守护线程)</strong></p><ul><li><p>主线程在其他非守护线程运行完毕后才算结束（守护线程在此时就会被回收）</p></li><li><p>强调：主线程也是非守护线程（进程包含了线程）</p></li></ul></li></ul><blockquote><p>总结:主线程的结束意味着进程结束，进程整体的资源都会被回收，而进程必须保证非守护线程都运行完毕后才能结束</p></blockquote><ul><li>守护进程：主进程代码运行完毕，守护进程也就结束</li><li>守护线程：非守护线程运行完毕，守护线程结束</li></ul><h3 id="python-线程"><a class="header-anchor" href="#python-线程">¶</a>python 线程</h3><p>Threading 用于提供线程相关的操作，线程是应用程序中工作的最小单元。</p><h4 id="1、threading-模块"><a class="header-anchor" href="#1、threading-模块">¶</a>1、threading 模块</h4><p>threading 模块建立在 _thread 模块之上。thread 模块以低级、原始的方式来处理和控制线程，而 threading 模块通过对 thread 进行二次封装，提供了更方便的 api 来处理线程。</p><pre class=" language-language-python"><code class="language-language-python">import threadingimport timedef worker(num):    """    thread worker function    :return:    """    time.sleep(3)    print("The num is  %d" % num)    returnif __name__ == '__main__':    for i in range(5):        t = threading.Thread(target=worker, args=(i,), name="t.%d" % i)        t.start()</code></pre><p>上述代码创建了5个&quot;前台&quot;线程，然后控制器就交给了CPU，CPU根据指定算法进行调度，分片执行指令。</p><blockquote><p>Thread参数介绍：</p></blockquote><ul><li><p>group：参数未使用，默认值为None。</p></li><li><p>target：表示调用对象，即子线程要执行的任务。</p></li><li><p>args：表示调用的位置参数元组。</p></li><li><p>kwargs：表示调用对象的字典。如kwargs = {‘name’:Jack, ‘age’:18}。</p></li><li><p>name：子进程名称。</p></li><li><p>daemon：设置为守护线程(True)或非守护线程(默认：False)</p></li></ul><blockquote><p>Thread属性方法说明</p></blockquote><table><thead><tr><th style="text-align:center">方法/属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">start()</td><td style="text-align:left">激活线程。使用该方法启动一个子线程，线程名就是我们定义的name，想启动多线程，就必须使用此方法</td></tr><tr><td style="text-align:center">run()</td><td style="text-align:left">线程被cpu调度后自动执行线程对象的run方法,直接使用该方法并不启动一个新线程，就是在主线程中调用了一个普通函数而已</td></tr><tr><td style="text-align:center">ident</td><td style="text-align:left">获取线程的标识符。线程标识符是一个非零整数，只有在调用了start()方法之后该属性才有效，否则它只返回None。</td></tr><tr><td style="text-align:center">name</td><td style="text-align:left">获取或设置线程的名称</td></tr><tr><td style="text-align:center">getName()</td><td style="text-align:left">获取线程的名称</td></tr><tr><td style="text-align:center">setName()</td><td style="text-align:left">设置线程的名称</td></tr><tr><td style="text-align:center">is_alive()</td><td style="text-align:left">判断线程是否为激活状态</td></tr><tr><td style="text-align:center">isAlive()</td><td style="text-align:left">判断线程是否为激活状态</td></tr><tr><td style="text-align:center">setDaemon()</td><td style="text-align:left">设置为守护线程或非守护线程；默认值为False，如果设置为True，代表该进程为后台守护线程；当非守护线程(不只是主线程)终止时，该线程也随之终止；并且设置为True后，该线程不能创建子线程，设置该属性设置必须在start()之前</td></tr><tr><td style="text-align:center">isDaemon()</td><td style="text-align:left">判断是否为守护线程</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:left">阻塞等待该线程执行完毕，该方法主要让主线程阻塞等待所有子线程执行完毕</td></tr></tbody></table><h4 id="2、线程锁threading-RLock和threading-Lock"><a class="header-anchor" href="#2、线程锁threading-RLock和threading-Lock">¶</a>2、线程锁threading.RLock和threading.Lock</h4><p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，CPU接着执行其他线程。为了保证数据的准确性，引入了锁的概念。所以，可能出现如下问题：</p><p>假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加1000000次，g_num的最终的结果应该为2000000。</p><p>但是由于是多线程同时操作，有可能出现下面情况：</p><p>在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0<br>然后t2对得到的值进行加1并赋给g_num，使得g_num=1<br>然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。<br>这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1<br><strong>如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确，锁的出现解决了这个问题。</strong></p><pre class=" language-language-python"><code class="language-language-python">import threadingg_num = 0lock = threading.Lock() #创建锁def work1(num):    global g_num    for i in range(num):        lock.acquire() # 加锁        g_num += 1        lock.release() # 解锁    print("----in work1, g_num is %d---" % g_num)def work2(num):    global g_num    for i in range(num):        lock.acquire()        g_num += 1        lock.release()    print("----in work2, g_num is %d---" % g_num)if __name__ == '__main__':    print("---线程创建之前g_num is %d---" % g_num)    t1 = threading.Thread(target=work1, args=(1000000,))    t2 = threading.Thread(target=work2, args=(1000000,))    t1.start()    t2.start()    t1.join()    t2.join()    print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)</code></pre><h4 id="3、threading-RLock和threading-Lock-的区别"><a class="header-anchor" href="#3、threading-RLock和threading-Lock-的区别">¶</a>3、threading.RLock和threading.Lock 的区别</h4><p>RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。</p><p>如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的锁。</p><ul><li>Lock多次加锁演示</li></ul><pre class=" language-language-python"><code class="language-language-python">import threadinglock = threading.Lock()    #Lock对象lock.acquire()lock.acquire()  #产生了死锁。lock.release()lock.release()</code></pre><ul><li>RLock多次加锁演示</li></ul><pre class=" language-language-python"><code class="language-language-python">import threadingrLock = threading.RLock()  #RLock对象rLock.acquire()rLock.acquire()    #在同一线程内，程序不会堵塞。rLock.release()rLock.release()</code></pre><h4 id="4、threading-Event"><a class="header-anchor" href="#4、threading-Event">¶</a>4、threading.Event</h4><p>通过threading.Event()可以创建一个事件管理标志，该标志（event）默认为False，event对象主要有四种方法可以调用：</p><ul><li>event.wait(timeout=None)：调用该方法的线程会被阻塞，如果设置了timeout参数，超时后，线程会停止阻塞继续执行；</li><li>event.set()：将event的标志设置为True，调用wait方法的所有线程将被唤醒；</li><li>event.clear()：将event的标志设置为False，调用wait方法的所有线程将被阻塞；</li><li>event.isSet()：判断event的标志是否为True。</li></ul><pre class=" language-language-python"><code class="language-language-python">import threadingdef do(event):    print('start')    event.wait()    print('execute')event_obj = threading.Event()for i in range(10):    t = threading.Thread(target=do, args=(event_obj,))    t.start()event_obj.clear()inp = input('input:')if inp == 'true':    event_obj.set()</code></pre><h4 id="5、threading-Condition"><a class="header-anchor" href="#5、threading-Condition">¶</a>5、threading.Condition</h4><p>Python提供的Condition对象提供了对复杂线程同步问题的支持。</p><ul><li>Condition被称为条件变量，除了提供与Lock类似的acquire和release方法外，还提供了wait和notify方法。</li></ul><h5 id="Condition的处理流程如下："><a class="header-anchor" href="#Condition的处理流程如下：">¶</a>Condition的处理流程如下：</h5><ul><li>首先acquire一个条件变量，然后判断一些条件。</li><li>如果条件不满足则wait；</li><li>如果条件满足，进行一些处理改变条件后，通过notify方法通知其他线程，其他处于wait状态的线程接到通知后会重新判断条件。</li><li>不断的重复这一过程，从而解决复杂的同步问题。</li></ul><h5 id="Condition的基本原理如下："><a class="header-anchor" href="#Condition的基本原理如下：">¶</a>Condition的基本原理如下：</h5><p>可以认为<strong>Condition对象</strong>维护了一个<strong>锁（Lock/RLock)<strong>和一个</strong>waiting池</strong>。线程通过acquire获得Condition对象，当调用wait方法时，线程会释放Condition内部的锁并进入blocked状态，同时在waiting池中记录这个线程。当调用notify方法时，Condition对象会从waiting池中挑选一个线程，通知其调用acquire方法尝试取到锁。</p><p>Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。</p><p>除了notify方法外，Condition对象还提供了notifyAll方法，可以通知waiting池中的所有线程尝试acquire内部锁。由于上述机制，<strong>处于waiting状态的线程只能通过notify方法唤醒，所以notifyAll的作用在于防止有的线程永远处于沉默状态。</strong></p><h5 id="Condition的案例演示如下："><a class="header-anchor" href="#Condition的案例演示如下：">¶</a>Condition的案例演示如下：</h5><p>演示条件变量同步的经典问题是生产者与消费者问题：假设有一群生产者(Producer)和一群消费者（Consumer）通过一个市场来交互产品。生产者的”策略“是如果市场上剩余的产品少于1000个，那么就生产100个产品放到市场上；而消费者的”策略“是如果市场上剩余产品的数量多余100个，那么就消费3个产品。</p><p>用Condition解决生产者与消费者问题的代码如下：</p><pre class=" language-language-python"><code class="language-language-python"># -*- coding: utf-8 -*-"""Created on Wed Nov 28 17:15:29 2018@author: 18665"""import threadingimport timeclass Producer(threading.Thread):    # 生产者函数    def run(self):        global count        while True:            if con.acquire():                # 当count 小于等于1000 的时候进行生产                if count > 1000:                    con.wait()                else:                    count = count+100                    msg = self.name+' produce 100, count=' + str(count)                    print(msg)                    # 完成生成后唤醒waiting状态的线程，                    # 从waiting池中挑选一个线程，通知其调用acquire方法尝试取到锁                    con.notify()                con.release()                time.sleep(1)class Consumer(threading.Thread):    # 消费者函数    def run(self):        global count        while True:            # 当count 大于等于100的时候进行消费            if con.acquire():                if count < 100:                    con.wait()                else:                    count = count-5                    msg = self.name+' consume 5, count='+str(count)                    print(msg)                    con.notify()                    # 完成生成后唤醒waiting状态的线程，                    # 从waiting池中挑选一个线程，通知其调用acquire方法尝试取到锁                con.release()                time.sleep(1)count = 500con = threading.Condition()def test():    for i in range(2):        p = Producer()        p.start()    for i in range(5):        c = Consumer()        c.start()if __name__ == '__main__':    test()</code></pre><h4 id="6、queue模块"><a class="header-anchor" href="#6、queue模块">¶</a>6、queue模块</h4><p>queue.Queue 就是消息队列，可以利用它实现线程间的安全通信。</p><pre class=" language-language-python"><code class="language-language-python">import queueq = queue.Queue(maxsize=0)  # 构造一个先进显出队列，maxsize指定队列长度，为0 时，表示队列长度无限制。q.join()    # 等到队列为kong的时候，在执行别的操作q.qsize()   # 返回队列的大小 （不可靠）q.empty()   # 当队列为空的时候，返回True 否则返回False （不可靠）q.full()    # 当队列满的时候，返回True，否则返回False （不可靠）q.put(item, block=True, timeout=None) #  将item放入Queue尾部，item必须存在，可以参数block默认为True,表示当队列满时，会等待队列给出可用位置，为False时为非阻塞，此时如果队列已满，会引发queue.Full 异常。 可选参数timeout，表示 会阻塞设置的时间，过后，如果队列无法给出放入item的位置，则引发 queue.Full 异常q.get(block=True, timeout=None) #   移除并返回队列头部的一个值，可选参数block默认为True，表示获取值的时候，如果队列为空，则阻塞，为False时，不阻塞，若此时队列为空，则引发 queue.Empty异常。 可选参数timeout，表示会阻塞设置的时候，过后，如果队列为空，则引发Empty异常。q.put_nowait(item) #   等效于 put(item,block=False)q.get_nowait() #    等效于 get(item,block=False)</code></pre><p>代码如下：</p><pre class=" language-language-python"><code class="language-language-python">import queueimport threadingimport timemessage = queue.Queue(3)def producer():    for i in range(10):        message.put(i)        print("PUT>>>%d" % i)def consumer():    for i in range(10):        msg = message.get()        print("GET>>>%d" % msg)        time.sleep(1)if __name__ == '__main__':    t1 = threading.Thread(target=producer)    t2 = threading.Thread(target=consumer)    t1.start()    t2.start()</code></pre><h3 id="Python-进程"><a class="header-anchor" href="#Python-进程">¶</a>Python 进程</h3><h4 id="1、multiprocess模块"><a class="header-anchor" href="#1、multiprocess模块">¶</a>1、multiprocess模块</h4><p>process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。</p><pre class=" language-language-shell"><code class="language-language-shell">语法：Process([group [, target [, name [, args [, kwargs]]]]])</code></pre><pre class=" language-language-python"><code class="language-language-python">import multiprocessingimport timedef worker(num):    """    process worker function    :return:    """    time.sleep(3)    print("The num is  %d" % num)    returnif __name__ == '__main__':    for i in range(5):        t = multiprocessing.Process(target=worker, args=(i,), name="t.%d" % i)        t.start()</code></pre><blockquote><p>Process参数介绍：</p></blockquote><ul><li><p>group：参数未使用，默认值为None。</p></li><li><p>target：表示调用对象，即子进程要执行的任务。</p></li><li><p>args：表示调用的位置参数元组。</p></li><li><p>kwargs：表示调用对象的字典。如kwargs = {‘name’:Jack, ‘age’:18}。</p></li><li><p>name：子进程名称。</p></li><li><p>daemon：设置为守护进程(True)或非守护进程(默认：False)</p></li></ul><blockquote><p>Process属性方法介绍</p></blockquote><table><thead><tr><th style="text-align:center">方法/属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">start()</td><td style="text-align:left">启动进程，调用进程中的run()方法。</td></tr><tr><td style="text-align:center">run()</td><td style="text-align:left">进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 。</td></tr><tr><td style="text-align:center">terminate()</td><td style="text-align:left">强制终止进程，不会进行任何清理操作。如果该进程终止前，创建了子进程，那么该子进程在其强制结束后变为僵尸进程；如果该进程还保存了一个锁那么也将不会被释放，进而导致死锁。使用时，要注意。</td></tr><tr><td style="text-align:center">is_alive()</td><td style="text-align:left">判断某进程是否存活，存活返回True，否则False。</td></tr><tr><td style="text-align:center">join([timeout])</td><td style="text-align:left">主线程等待子线程终止。timeout为可选择超时时间；需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程 。</td></tr><tr><td style="text-align:center">daemon</td><td style="text-align:left">默认值为False，如果设置为True，代表该进程为后台守护进程；当该进程的父进程终止时，该进程也随之终止；并且设置为True后，该进程不能创建子进程，设置该属性必须在start()之前</td></tr><tr><td style="text-align:center">name</td><td style="text-align:left">进程名称。</td></tr><tr><td style="text-align:center">pid</td><td style="text-align:left">进程pid</td></tr><tr><td style="text-align:center">exitcode</td><td style="text-align:left">进程运行时为None，如果为-N，表示被信号N结束了。</td></tr><tr><td style="text-align:center">authkey</td><td style="text-align:left">进程身份验证，默认是由os.urandom()随机生成32字符的字符串。这个键的用途是设计涉及网络连接的底层进程间的通信提供安全性，这类连接只有在具有相同身份验证才能成功。</td></tr></tbody></table><blockquote><p>注意:</p></blockquote><ul><li><strong>在进程python的设计里面只有主进程可以接收input()的输入，子进程没有输入模式，运行直接报错</strong></li><li><strong>更坑的是进程池，表面上不会出错，但是input()函数一旦进入无法退出，一直在接收输入的数据</strong></li></ul><h4 id="2、消息队列multiprocess-Queue"><a class="header-anchor" href="#2、消息队列multiprocess-Queue">¶</a>2、消息队列multiprocess.Queue</h4><p>可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序</p><blockquote><p>Queue属性方法说明</p></blockquote><table><thead><tr><th style="text-align:center">方法/属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">get( [ block [ ,timeout ] ] )</td><td style="text-align:left">返回q中的一个元素。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。</td></tr><tr><td style="text-align:center">get_nowait( )</td><td style="text-align:left">同q.get(False)方法。</td></tr><tr><td style="text-align:center">put(item [, block [,timeout ] ] )</td><td style="text-align:left">将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。</td></tr><tr><td style="text-align:center">q.qsize()</td><td style="text-align:left">返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。</td></tr><tr><td style="text-align:center">q.empty()</td><td style="text-align:left">如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。</td></tr><tr><td style="text-align:center">q.full()</td><td style="text-align:left">如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。。</td></tr><tr><td style="text-align:center">其他方法(了解)</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">q.close()</td><td style="text-align:left">关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。</td></tr><tr><td style="text-align:center">q.cancel_join_thread()</td><td style="text-align:left">不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。</td></tr><tr><td style="text-align:center">q.join_thread()</td><td style="text-align:left">连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。</td></tr></tbody></table><h4 id="3、进程池"><a class="header-anchor" href="#3、进程池">¶</a>3、进程池</h4><p>为什么要有进程池?进程池的概念。</p><p>在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？</p><p>在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。</p><h5 id="multiprocess-Pool模块"><a class="header-anchor" href="#multiprocess-Pool模块">¶</a>multiprocess.Pool模块</h5><pre class=" language-language-shell"><code class="language-language-shell">语法：Pool([numprocess  [,initializer [, initargs]]])</code></pre><blockquote><p>Pool参数介绍</p></blockquote><ul><li><p>numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值</p></li><li><p>initializer：是每个工作进程启动时要执行的可调用对象，默认为None</p></li><li><p>initargs：是要传给initializer（可迭代）的参数组</p></li></ul><blockquote><p>Pool主要方法介绍</p></blockquote><table><thead><tr><th style="text-align:center">方法/属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">apply(func [, args [, kwargs]])</td><td style="text-align:left">在一个池工作进程中执行func(*args,**kwargs),然后返回结果。'需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用apply()函数或者使用p.apply_async()</td></tr><tr><td style="text-align:center">apply_async(func [, args [, kwargs]])</td><td style="text-align:left">在一个池工作进程中执行func(*args,**kwargs),然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。</td></tr><tr><td style="text-align:center">close()</td><td style="text-align:left">关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成</td></tr><tr><td style="text-align:center">terminate()</td><td style="text-align:left">不管任务是否完成，立即停止工作进程。在对pool对象进程垃圾回收的时候，会立即调用terminate()</td></tr><tr><td style="text-align:center">jion()</td><td style="text-align:left">等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</td></tr><tr><td style="text-align:center">其他方法(了解）</td><td style="text-align:left">方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法</td></tr><tr><td style="text-align:center">obj.get()</td><td style="text-align:left">返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。</td></tr><tr><td style="text-align:center">obj.ready()</td><td style="text-align:left">如果调用完成，返回True</td></tr><tr><td style="text-align:center">obj.successful()</td><td style="text-align:left">如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常</td></tr><tr><td style="text-align:center">obj.wait([timeout])</td><td style="text-align:left">等待结果变为可用。</td></tr><tr><td style="text-align:center">obj.terminate()</td><td style="text-align:left">立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</td></tr></tbody></table><h5 id="进程池中的Queue"><a class="header-anchor" href="#进程池中的Queue">¶</a>进程池中的Queue</h5><p>如果要使用Pool创建进程，就需要使用<code>multiprocessing.Manager()</code>中的<code>Queue()</code>，而不是<code>multiprocessing.Queue()</code></p><h3 id="Python-协程"><a class="header-anchor" href="#Python-协程">¶</a>Python 协程</h3><p>协程，又称微线程，纤程。英文名Coroutine。协程是python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（理解为需要的资源）。 为啥说它是一个执行单元，因为它自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。</p><p>通俗的理解：<strong>在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定</strong></p><h4 id="1-协程和线程差异"><a class="header-anchor" href="#1-协程和线程差异">¶</a>1. 协程和线程差异</h4><p>在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。</p><h4 id="2-实现方式"><a class="header-anchor" href="#2-实现方式">¶</a>2. 实现方式</h4><ul><li><p>yield</p><pre class=" language-language-python"><code class="language-language-python">import timedef work1():    while True:        print("----work1---")        yield        time.sleep(0.5)def work2():    while True:        print("----work2---")        yield        time.sleep(0.5)def main():    w1 = work1()    w2 = work2()    while True:        next(w1)        next(w2)if __name__ == "__main__":    main()</code></pre></li><li><p>greenlet</p></li></ul><p>为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单</p><p><strong>安装方式</strong><br>使用如下命令安装greenlet模块:</p><pre class=" language-language-shell"><code class="language-language-shell">sudo pip3 install greenlet</code></pre><pre class=" language-language-python"><code class="language-language-python">#coding=utf-8from greenlet import greenletimport timedef test1():    while True:        print "---A--"        gr2.switch()        time.sleep(0.5)def test2():    while True:        print "---B--"        gr1.switch()        time.sleep(0.5)gr1 = greenlet(test1)gr2 = greenlet(test2)#切换到gr1中运行gr1.switch()</code></pre><ul><li>gevent</li></ul><p>greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent</p><p>其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。</p><p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p><p><strong>安装方式</strong><br>使用如下命令安装gevent模块:</p><pre class=" language-language-shell"><code class="language-language-shell">pip3 install gevent</code></pre><p>在gevent中不能直接使用time.sleep类似的方法，要么使用gevent.sleep，要么利用gevent.monkey打补丁</p><pre class=" language-language-python"><code class="language-language-python">from gevent import monkeyimport geventimport randomimport timedef coroutine_work(coroutine_name):    for i in range(10):        print(coroutine_name, i)        time.sleep(random.random())gevent.joinall([        gevent.spawn(coroutine_work, "work1"),        gevent.spawn(coroutine_work, "work2")])</code></pre><h3 id="获得进程和线程信息"><a class="header-anchor" href="#获得进程和线程信息">¶</a>获得进程和线程信息</h3><p>想要获取线程和进程相关信息，代码如下：</p><pre class=" language-language-python"><code class="language-language-python"># -*- coding: utf-8 -*-"""获得线程, 进程 ID,NAME总结:"""import threadingimport psutilimport osimport datetime# 1 获取线程ID,NAMEt = threading.currentThread()# 线程IDprint('Thread id : %d' % t.ident)# 线程NAMEprint('Thread name : %s' % t.getName())# 2 获取线程ID,NAMEpid = os.getpid()p = psutil.Process(pid)print('----------------')# 进程IDprint('Process id : %d' % pid)# 进程NAMEprint('Process name : %s' % p.name())# 获取进程bin路径print('Process bin  path : %s' % p.exe())# 获取pid对应的路径print('Process path : %s' % p.cwd())# 进程状态print('Process status : %s' % p.status())# 进程运行时间print('Process creation time : %s' % datetime.datetime.fromtimestamp(p.create_time()).strftime("%Y-%m-%d %H:%M:%S"))# CPU使用情况print(p.cpu_times())# 内存使用情况print('Memory usage : %s%%' % p.memory_percent())# 硬盘读取信息print(p.io_counters())# 打开进程socket的namedutples列表print(p.connections())# 此进程的线程数print('Process number of threads : %s' % p.num_threads())</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 协程 </tag>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>books</title>
      <link href="/2019/05/12/books/"/>
      <url>/2019/05/12/books/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a class="header-anchor" href="#基础">¶</a>基础</h2><h3 id="基础教程"><a class="header-anchor" href="#基础教程">¶</a>基础教程</h3><ul><li><p><a href="http://liushaofeng2018.gitee.io/python_fundamentals/" target="_blank" rel="noopener">python基础</a></p></li><li><p><a href="http://liushaofeng2018.gitee.io/python_advanced/" target="_blank" rel="noopener">python高级</a></p></li></ul><h3 id="工具"><a class="header-anchor" href="#工具">¶</a>工具</h3><ul><li><p><a href="http://liushaofeng2018.gitee.io/python-redis/" target="_blank" rel="noopener">redis</a></p></li><li><p><a href="http://liushaofeng2018.gitee.io/python-git/" target="_blank" rel="noopener">git</a></p></li></ul><h3 id="web"><a class="header-anchor" href="#web">¶</a>web</h3><h4 id="django"><a class="header-anchor" href="#django">¶</a>django</h4><ul><li><p><a href="http://liushaofeng2018.gitee.io/python-django/" target="_blank" rel="noopener">django</a></p></li><li><p><a href="http://liushaofeng2018.gitee.io/python-django-rest-framework/" target="_blank" rel="noopener">django-rest-framework</a></p></li><li><p><a href="http://liushaofeng2018.gitee.io/pyhton-mido-front-end/" target="_blank" rel="noopener">Django项目:美多商城-前端</a></p></li><li><p><a href="http://liushaofeng2018.gitee.io/pyhton-mido-backstage/" target="_blank" rel="noopener">Django项目:美多商城-后台</a></p></li></ul><h3 id="flask"><a class="header-anchor" href="#flask">¶</a>flask</h3><ul><li><p><a href="http://liushaofeng2018.gitee.io/pyhton-flask/" target="_blank" rel="noopener">flask</a></p></li><li><p><a href="http://liushaofeng2018.gitee.io/python-headline/" target="_blank" rel="noopener">flask项目：头条</a></p></li></ul><h3 id="前端"><a class="header-anchor" href="#前端">¶</a>前端</h3><ul><li><p><a href="http://liushaofeng2018.gitee.io/python-vue/" target="_blank" rel="noopener">vue</a></p></li><li><p><a href="http://liushaofeng2018.gitee.io/python-vue-component/" target="_blank" rel="noopener">vue组件</a></p></li></ul><h3 id="数据结构与算法"><a class="header-anchor" href="#数据结构与算法">¶</a>数据结构与算法</h3><ul><li><a href="http://liushaofeng2018.gitee.io/python-data-structure-cn/" target="_blank" rel="noopener">用python解决数据结构与算法问题</a></li></ul><h3 id="人工智能"><a class="header-anchor" href="#人工智能">¶</a>人工智能</h3><ul><li><p><a href="http://liushaofeng2018.gitee.io/python-recommendation-system/" target="_blank" rel="noopener">推荐系统</a></p></li><li><p><a href="http://liushaofeng2018.gitee.io/python-headline-recommendation-system/" target="_blank" rel="noopener">头条推荐系统</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-HTTP 报文内的 HTTP 信息</title>
      <link href="/2019/05/09/wang-luo-tong-xin-03-http-bao-wen-nei-de-http-xin-xi/"/>
      <url>/2019/05/09/wang-luo-tong-xin-03-http-bao-wen-nei-de-http-xin-xi/</url>
      
        <content type="html"><![CDATA[<p>HTTP 通信过程包括从客户端发往服务器端的请求以及从服务端返回客户端的响应。</p><h2 id="1、HTTP-报文"><a class="header-anchor" href="#1、HTTP-报文">¶</a>1、HTTP 报文</h2><p>就是一大串通信过程里经过 <code>HTTP</code> 处理后添加的报文。<br>其大致分为报文首部和报文主体两块。两者由最初出现的空行（<code>CR+LF</code>）来划分，通常并不一定要有报文主体。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526112612-HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%20.png" alt="20190526112612-HTTP报文结构"></p><h2 id="2、编码提升传输速率"><a class="header-anchor" href="#2、编码提升传输速率">¶</a>2、编码提升传输速率</h2><h3 id="报文主体和实体主体的差异"><a class="header-anchor" href="#报文主体和实体主体的差异">¶</a>报文主体和实体主体的差异</h3><ul><li>**报文：**HTTP 通信的基本单位，8 位组字节流组成，通过 HTTP 通信传输。</li><li>**实体：**请求或响应的有效载荷数据被传输，内容由实体首部和实体主体组成。</li></ul><p>HTTP 报文主体用于传输请求或响应的实体主体。<br>一般情况，报文主体等于实体主体，但是传输中进行编码操作的时候，实体主体内容发生变化。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526112620-HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%8402%20.png" alt="20190526112620-HTTP报文结构02"><br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526112630-HTTP%E6%8A%A5%E6%96%87%E5%AE%9E%E4%BE%8B%20.png" alt="20190526112630-HTTP报文实例"></p><h3 id="压缩传输的内容编码"><a class="header-anchor" href="#压缩传输的内容编码">¶</a>压缩传输的内容编码</h3><p><code>HTTP</code> 协议中的内容编码功能就像用压缩软件压缩东西一样，对实体内容进行编码压缩，内容编码后的实体由客户端接受并解码。这可以压缩传输内容，加快传输速度。<br>常见的内容编码有 <code>gzip</code>、<code>compress</code>、<code>deflate</code>、<code>identity</code>（不编码）。</p><h3 id="分割发送的分块传输编码"><a class="header-anchor" href="#分割发送的分块传输编码">¶</a>分割发送的分块传输编码</h3><p><code>HTTP</code> 通信过程中，请求的编码实体资源尚未传输完成之前，浏览器无法显示请求页面，传输大容量数据时候，通过数据分割成多块，能让浏览器逐步显示页面。这就是分块传输编码（<code>Chunked</code> <code>Transfer</code> <code>Coding</code>）。它将实体主体分成多个部分，每一块用十六进制来标记，最后一块使用<code>0（CR+LF)</code>来标记。传输给客户端，由客户端进行解码恢复。</p><h2 id="3、发送多种数据的多部分对象集合"><a class="header-anchor" href="#3、发送多种数据的多部分对象集合">¶</a>3、发送多种数据的多部分对象集合</h2><p><code>MIME</code>（<code>Multipurpose</code> <code>Internet</code> <code>Mail</code> <code>Extensions</code>, 多用途因特网邮件扩展），它允许邮件处理文本，图片，视频等多个不同类型的数据，这使我们可以在邮件里写入文字并添加多分附件成为了现实。例如：图片等二进制数据以 <code>ASCII</code> 码字符串编码方式表名，就是利用 <code>MIME</code> 来标记数据类型，在 <code>MIME</code> 扩展中会使用一种称为多部分对象集合（<code>Multipart</code>）的方法，来容纳多份不同类型的数据。<br>相应的，<code>HTTP</code> 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体，通常在图片或文本文件等上传时使用。<br>多部分对象集合包括：</p><ul><li><p><code>multipart</code>/<code>form-data</code> 在 <code>Web</code> 表单文件上传使用</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526112655-%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88%20.png" alt="20190526112655-多部分对象集合"></p></li><li><p><code>multipart</code>/<code>byteranges</code> 状态码 206（<code>Partial</code> <code>Content</code>，部分内容）响应报文包含了多个范围的内容时使用。</p></li></ul><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526112701-%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%8802%20.png" alt="20190526112701-多部分对象集合02"></p><p><code>HTTP</code> 报文使用这个多部分对象集合的时候，需要在首部添加 <code>Content-type</code> 字段。<br>使用 <code>boundary</code> 字符串来划分多部分<br>在 <code>boundary</code> 字符串指定的各个实体的起始行之前插入<code>--</code>标记（<code>--AaB03x</code>、<code>--THis_STRING_SEPARATES</code>)<br>在多部分对象集合对应的字符串的最后插入<code>--</code>标记（<code>--AaB03x--</code>）</p><p>多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在部分中潜逃使用多部分对象集合。</p><h2 id="4、获取部分内容的范围请求"><a class="header-anchor" href="#4、获取部分内容的范围请求">¶</a>4、获取部分内容的范围请求</h2><p>过去，用户下载东西中断了必须要从头下载，为了解决这问题，要实现该功能需要指定下载的实体范围，指定范围发送的请求叫做范围请求（<code>Range</code> <code>Request</code>)<br>对一份 10000 字节大小的资源，如果使用范围请求，可以只请求 5001~10000 字节内的资源。这样就算中断了，也可以向服务端指明自己需要的资源字节范围，这些需要在首部字段中表名。<br>形式如下：</p><p><code>Range</code> : <code>bytes</code> = 5001 - 10000<br>5001 到 10000 的<br><code>Range</code> : <code>bytes</code> = 5001 -<br>5001 到之后全部的<br><code>Range</code> : <code>bytes</code> = -3000, 5000 - 7000<br>从头到 3000， 5000 到 7000 的</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526112648-HTTP%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%20.png" alt="20190526112648-HTTP范围请求"></p><p>针对范围请求，响应会返回状态码为 <code>206 Partial Content</code> 的响应报文，另外，对于多重范围的范围请求，响应会在首部字段 <code>Content-Type</code> 标明 <code>multipart</code>/<code>byteranges</code> 后返回响应报文，如果服务器无法响应请求，返回状态码 <code>200 OK </code>和完整的实体内容。</p><h5 id="5、内容协商返回最合适的内容"><a class="header-anchor" href="#5、内容协商返回最合适的内容">¶</a>5、内容协商返回最合适的内容</h5><p>同一个 Web 网站可能有存着多分相同内容的页面，如中文版和英文版，内容虽然相同，单语言不同。当浏览器默认语言为哪种，访问相同的 <code>URI</code> 的 <code>Web</code> 页面时，会对应返回哪种语言的 Web 页面，这样的机制就叫做内容协商（<code>Content</code> <code>Negotiation</code>）。<br>这协商的请求会包含在首部字段</p><ul><li><code>Accept</code></li><li><code>Accept-Charset</code></li><li><code>Accept-Encoding</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li></ul><p>类型：<br>服务器驱动协商（<code>Server-driven</code> <code>Negotiation</code>)<br>服务器通过请求的首部字段为参考自动处理，但以浏览器直接发送的信息不一定能筛选出最优的内容。<br>客户端驱动协商（<code>Agent-driven</code> <code>Negotiation</code>)<br>用户从浏览器显示的可选项列表中选择， 还可以利用 JS 脚本在 Web 页面自动进行上述选择。<br>透明协商（<code>Transparent</code> <code>Negotiation</code>)<br>上两种方法的结合体。</p><h2 id="自我回顾"><a class="header-anchor" href="#自我回顾">¶</a>自我回顾</h2><p>1、<code>HTTP</code> 报文是什么？大致分为哪两部分？<br>2、提升编码传输速率的方法有哪些？<br>3、如何发送多部分对象集合？<br>4、如何进行断点传输？<br>5、内容协商机制是什么？</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络通信 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-简单介绍 HTTP 协议结构</title>
      <link href="/2019/05/09/wang-luo-tong-xin-02-jian-dan-jie-shao-http-xie-yi-jie-gou/"/>
      <url>/2019/05/09/wang-luo-tong-xin-02-jian-dan-jie-shao-http-xie-yi-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>首先，应用 <code>HTTP</code> 协议时，必定有客户端和服务器端。<br>其中，发起请求的是客户端，响应请求并返回的是服务端。</p><h2 id="1、请求报文"><a class="header-anchor" href="#1、请求报文">¶</a>1、请求报文</h2><p>请求报文是由请求方法、请求 <code>URI</code>、协议版本、可选的请求首部字段和内容实体构成的。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111207-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%20.png" alt="20190526111207-请求报文"></p><h2 id="2、响应报文"><a class="header-anchor" href="#2、响应报文">¶</a>2、响应报文</h2><p>服务器以响应的形式返回处理结果。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111215-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%20.png" alt="20190526111215-响应报文"></p><p><code>200 OK</code> 是状态码（<code>status</code> <code>code</code>）和 原因短语。<br>下一行是创建相应的日期，是首部字段 (<code>header</code> <code>field</code>) 的一个属性。<br>下一行是返回内容的总长度。<br>下一行是返回内容的类型。<br>空行后的是资源实体的主体内容。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111221-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%8702%20.png" alt="20190526111221-响应报文02"></p><h2 id="3、HTTP-是无状态（stateless）协议。"><a class="header-anchor" href="#3、HTTP-是无状态（stateless）协议。">¶</a>3、HTTP 是无状态（stateless）协议。</h2><p>HTTP 自身不对请求和相应之间的通信状态进行保存，即不对发送过的请求或响应进行持久化处理。<br>  这是为了更快地处理大量事务，确保协议的可伸缩性。<br>  这一技术的<strong>问题</strong>就是当访问一家网站的多个页面时，无法保存其登陆状态，所以根据这一问题，引入了 <code>Cookie</code> 技术来管理状态。</p><h2 id="4、HTTP-方法"><a class="header-anchor" href="#4、HTTP-方法">¶</a>4、HTTP 方法</h2><p>下面就简单介绍一下常用的几种方法，<code>GET</code>、<code>POST</code> 和 <code>HEAD</code> 除此之外的还有 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code> 和 <code>CONNECT</code>，这些不太常用，所以不在这里赘述了。</p><h3 id="GET"><a class="header-anchor" href="#GET">¶</a><code>GET</code></h3><p>获取资源。请求已被 <code>URI</code> 识别的资源，就是经过服务器解析后返回的响应内容，文本就保持原样返回，如果是可执行程序，就返回结果。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111129-GET%E6%96%B9%E5%BC%8F%20.png" alt="20190526111129-GET方式"></p><h3 id="POST"><a class="header-anchor" href="#POST">¶</a><code>POST</code></h3><p>传输实体主体。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111137-POST%E6%96%B9%E5%BC%8F%20.png" alt="20190526111137-POST方式"></p><h3 id="HEAD"><a class="header-anchor" href="#HEAD">¶</a><code>HEAD</code></h3><p>获得报文首部。和 <code>GET</code> 一样，但是不返回主体部分，只用于确认 <code>URI</code> 的有效性和资源更新的日期等。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111155-%E6%8A%A5%E6%96%87%E5%A4%B4%20.png" alt="20190526111155-报文头"></p><blockquote><p><strong>注意：<strong>方法名区分大小写，注意要用</strong>大写字母</strong>。</p></blockquote><h2 id="5、持久化连接"><a class="header-anchor" href="#5、持久化连接">¶</a>5、持久化连接</h2><p>当请求的资源有很多时，会发生多次的 <code>TCP</code> 连接和断开过程，增加了通信量的开销。于是产生了持久链接（<code>HTTP</code> <code>Persistent</code> <code>connections</code>）。<br>  <strong>特点：</strong> 只要任意一端没有明确提出断开连接，则保持 <code>TCP</code> 连接状态。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111143-TCP%E9%93%BE%E6%8E%A5%20.png" alt="20190526111143-TCP链接"></p><h2 id="6、管线化"><a class="header-anchor" href="#6、管线化">¶</a>6、管线化</h2><p>持久化连接需要等待上一个发送请求得到响应之后才能发送下一个请求，但是管线化技术可以直接发送，这样就能同时并发发送多个请求。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111200-%E7%AE%A1%E7%BA%BF%E5%8C%96%20.png" alt="20190526111200-管线化"></p><h2 id="7、Cookie"><a class="header-anchor" href="#7、Cookie">¶</a>7、Cookie</h2><p>状态管理。为了解决 <code>HTTP</code> 的无状态，<code>Cookie</code> 技术通过在请求和响应报文中写入 <code>Cookie</code> 信息来控制客户端的状态。具体实现是 <code>Cookie</code> 根据响应报文内 <code>Set-Cookie</code> 的首部字段信息，通知客户端保存 <code>Cookie</code>，当下一次再像<strong>该</strong>服务器发送请求，客户端会自动在请求报文中添加 <code>Cookie</code> 值后发送。服务端发现客户端发送的 <code>Cookie</code> 后，回去检查对比记录，得到状态信息。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526111108-Cookie%20.png" alt="20190526111108-Cookie"></p><h2 id="自我回顾"><a class="header-anchor" href="#自我回顾">¶</a>自我回顾</h2><p>1、请求报文、响应报文的基本组成？<br>2、什么是无状态协议，怎么解决的？<br>3、<code>HTTP</code> 的基本方法？分别有什么功能？<br>4、为了加快资源访问速度出现了什么方法？</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络通信 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法总结与实现</title>
      <link href="/2019/05/09/suan-fa-pai-xu/"/>
      <url>/2019/05/09/suan-fa-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，整理并用Python实现了七大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。之所以用Python实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。</p><a id="more"></a><p>本篇博客所有排序实现均默认从小到大。</p><h2 id="一、冒泡排序-BubbleSort"><a class="header-anchor" href="#一、冒泡排序-BubbleSort">¶</a>一、冒泡排序 <code>BubbleSort</code></h2><h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序逆序就把他们交换过来。</p><h3 id="步骤"><a class="header-anchor" href="#步骤">¶</a>步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>不过针对上述实现过程还有两种优化方案。</p><ul><li>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</li><li>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</li></ul><h3 id="源代码"><a class="header-anchor" href="#源代码">¶</a>源代码</h3><pre class=" language-language-python"><code class="language-language-python">def bubble_sort(ary):    n = len(ary)                   #获得数组的长度    for i in range(n):        for j in range(1,n-i):            if  ary[j-1] > ary[j] :       #如果前者比后者大                ary[j-1],ary[j] = ary[j],ary[j-1]       #则交换两者    return ary#优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。#用一个标记记录这个状态即可。def bubble_sort2(ary):    n = len(ary)    for i in range(n):        flag = 1                    #标记        for j in range(1,n-i):            if  ary[j-1] > ary[j] :                ary[j-1],ary[j] = ary[j],ary[j-1]                flag = 0        if flag :                   #全排好序了，直接跳出            break    return ary#优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。# 因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。def bubble_sort3(ary):    n = len(ary)    k = n                           #k为循环的范围，初始值n    for i in range(n):        flag = 1        for j in range(1,k):        #只遍历到最后交换的位置即可            if  ary[j-1] > ary[j] :                ary[j-1],ary[j] = ary[j],ary[j-1]                k = j               #记录最后交换的位置                flag = 0        if flag :            break    return ary</code></pre><h2 id="二、选择排序-SelectionSort"><a class="header-anchor" href="#二、选择排序-SelectionSort">¶</a>二、选择排序 <code>SelectionSort</code></h2><h3 id="介绍-v2"><a class="header-anchor" href="#介绍-v2">¶</a>介绍</h3><p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p><h3 id="步骤-v2"><a class="header-anchor" href="#步骤-v2">¶</a>步骤</h3><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>以此类推，直到所有元素均排序完毕。</li></ol><h3 id="源代码-v2"><a class="header-anchor" href="#源代码-v2">¶</a>源代码</h3><pre class=" language-language-python"><code class="language-language-python">def select_sort(ary):    n = len(ary)    for i in range(0,n):        min = i                             #最小元素下标标记        for j in range(i+1,n):            if ary[j] < ary[min] :                min = j                     #找到最小值的下标        ary[min],ary[i] = ary[i],ary[min]   #交换两者    return ary</code></pre><h2 id="三、插入排序-InsertionSort"><a class="header-anchor" href="#三、插入排序-InsertionSort">¶</a>三、插入排序 <code>InsertionSort</code></h2><h3 id="介绍-v3"><a class="header-anchor" href="#介绍-v3">¶</a>介绍</h3><p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h3 id="步骤-v3"><a class="header-anchor" href="#步骤-v3">¶</a>步骤</h3><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><h3 id="排序演示"><a class="header-anchor" href="#排序演示">¶</a>排序演示</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190509200851-Insertion-sort-example-300px%20.gif" alt="20190509200851-Insertion-sort-example-300px"></p><h3 id="源代码-v3"><a class="header-anchor" href="#源代码-v3">¶</a>源代码</h3><pre class=" language-language-python"><code class="language-language-python">def insert_sort(ary):    n = len(ary)    for i in range(1,n):        if ary[i] < ary[i-1]:            temp = ary[i]            index = i           #待插入的下标            for j in range(i-1,-1,-1):  #从i-1 循环到 0 (包括0)                if ary[j] > temp :                    ary[j+1] = ary[j]                    index = j   #记录待插入下标                else :                    break            ary[index] = temp    return ary</code></pre><h2 id="四、希尔排序-ShellSort"><a class="header-anchor" href="#四、希尔排序-ShellSort">¶</a>四、希尔排序 <code>ShellSort</code></h2><h3 id="介绍："><a class="header-anchor" href="#介绍：">¶</a>介绍：</h3><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p><h3 id="步骤："><a class="header-anchor" href="#步骤：">¶</a>步骤：</h3><p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p><ol><li>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：<pre><code>13 14 94 33 8225 59 94 65 2345 27 73 25 3910</code></pre></li><li>然后我们对每列进行排序：<pre><code>10 14 73 25 2313 27 94 33 3925 59 94 65 8245</code></pre></li><li>将上述四行数字，依序接在一起时我们得到：<code>[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]</code>。这时10已经移至正确位置了，然后再以3为步长进行排序：<pre><code>10 14 7325 23 1327 94 3339 25 5994 65 8245</code></pre>排序之后变为：<pre><code>10 14 1325 23 3327 25 5939 65 7345 94 8294</code></pre></li><li>最后以1步长进行排序（此时就是简单的插入排序了）。</li></ol><h3 id="源代码-v4"><a class="header-anchor" href="#源代码-v4">¶</a>源代码</h3><pre class=" language-language-python"><code class="language-language-python">def shell_sort(ary):    n = len(ary)    gap = round(n/2)       #初始步长 , 用round四舍五入取整    while gap > 0 :        for i in range(gap,n):        #每一列进行插入排序 , 从gap 到 n-1            temp = ary[i]            j = i            while ( j >= gap and ary[j-gap] > temp ):    #插入排序                ary[j] = ary[j-gap]                j = j - gap            ary[j] = temp        gap = round(gap/2)                     #重新设置步长    return ary</code></pre><h2 id="五、归并排序-MergeSort"><a class="header-anchor" href="#五、归并排序-MergeSort">¶</a>五、归并排序 <code>MergeSort</code></h2><h3 id="介绍-v4"><a class="header-anchor" href="#介绍-v4">¶</a>介绍</h3><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p><p>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p><p>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p><h3 id="排序演示-v2"><a class="header-anchor" href="#排序演示-v2">¶</a>排序演示</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190509201729-Merge-sort-example-300px%20.gif" alt="20190509201729-Merge-sort-example-300px"></p><h3 id="源代码-v5"><a class="header-anchor" href="#源代码-v5">¶</a>源代码</h3><pre class=" language-language-python"><code class="language-language-python">def merge_sort(ary):    if len(ary) <= 1 : return ary    num = int(len(ary)/2)       #二分分解    left = merge_sort(ary[:num])    right = merge_sort(ary[num:])    return merge(left,right)    #合并数组def merge(left,right):    '''合并操作，    将两个有序数组left[]和right[]合并成一个大的有序数组'''    l,r = 0,0           #left与right数组的下标指针    result = []    while l<len(left) and r<len(right) :        if left[l] < right[r]:            result.append(left[l])            l += 1        else:            result.append(right[r])            r += 1    result += left[l:]    result += right[r:]    return result</code></pre><h2 id="六、快速排序-QuickSort"><a class="header-anchor" href="#六、快速排序-QuickSort">¶</a>六、快速排序 <code>QuickSort</code></h2><h3 id="介绍-v5"><a class="header-anchor" href="#介绍-v5">¶</a>介绍</h3><p>快速排序通常明显比同为<code>Ο(n log n)</code>的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p><h3 id="步骤-v4"><a class="header-anchor" href="#步骤-v4">¶</a>步骤</h3><ol><li>从数列中挑出一个元素作为基准数。</li><li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li><li>再对左右区间递归执行第二步，直至各区间只有一个数。</li></ol><h3 id="排序演示-v3"><a class="header-anchor" href="#排序演示-v3">¶</a>排序演示</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190509202100-Quicksort-example%20.gif" alt="20190509202100-Quicksort-example"></p><h3 id="源代码-v6"><a class="header-anchor" href="#源代码-v6">¶</a>源代码</h3><pre class=" language-language-python"><code class="language-language-python">def quick_sort(ary):    return qsort(ary,0,len(ary)-1)def qsort(ary,left,right):    #快排函数，ary为待排序数组，left为待排序的左边界，right为右边界    if left >= right : return ary    key = ary[left]     #取最左边的为基准数    lp = left           #左指针    rp = right          #右指针    while lp < rp :        while ary[rp] >= key and lp < rp :            rp -= 1        while ary[lp] <= key and lp < rp :            lp += 1        ary[lp],ary[rp] = ary[rp],ary[lp]    ary[left],ary[lp] = ary[lp],ary[left]    qsort(ary,left,lp-1)    qsort(ary,rp+1,right)    return ary</code></pre><h2 id="七、堆排序-HeapSort"><a class="header-anchor" href="#七、堆排序-HeapSort">¶</a>七、堆排序 <code>HeapSort</code></h2><h3 id="介绍：-v2"><a class="header-anchor" href="#介绍：-v2">¶</a>介绍：</h3><p>堆排序在 <code>top K</code> 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。</p><blockquote><p>二叉堆具有以下性质：</p></blockquote><p>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。<br>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p><h3 id="步骤-v5"><a class="header-anchor" href="#步骤-v5">¶</a>步骤</h3><ol><li><p>构造最大堆（<code>Build_Max_Heap</code>）：若数组下标范围为<code>0~n</code>，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从<code>n/2-1</code>开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p></li><li><p>堆排序（<code>HeapSort</code>）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将<code>heap[0]</code>与<code>heap[n-1]</code>交换，再对<code>heap[0...n-2]</code>做最大堆调整。第二次将<code>heap[0]</code>与<code>heap[n-2]</code>交换，再对<code>heap[0...n-3]</code>做最大堆调整。重复该操作直至<code>heap[0]</code>和<code>heap[1]</code>交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p></li><li><p>最大堆调整（<code>Max_Heapify</code>）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p></li></ol><h3 id="排序演示-v4"><a class="header-anchor" href="#排序演示-v4">¶</a>排序演示</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190509203202-Heapsort-example%20.gif" alt="20190509203202-Heapsort-example"></p><h3 id="源代码-v7"><a class="header-anchor" href="#源代码-v7">¶</a>源代码</h3><pre class=" language-language-python"><code class="language-language-python">def heap_sort(ary) :    n = len(ary)    first = int(n/2-1)       #最后一个非叶子节点    for start in range(first,-1,-1) :     #构造大根堆        max_heapify(ary,start,n-1)    for end in range(n-1,0,-1):           #堆排，将大根堆转换成有序数组        ary[end],ary[0] = ary[0],ary[end]        max_heapify(ary,0,end-1)    return ary#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点#start为当前需要调整最大堆的位置，end为调整边界def max_heapify(ary,start,end):    root = start    while True :        child = root*2 +1               #调整节点的子节点        if child > end : break        if child+1 <= end and ary[child] < ary[child+1] :            child = child+1             #取较大的子节点        if ary[root] < ary[child] :     #较大的子节点成为父节点            ary[root],ary[child] = ary[child],ary[root]     #交换            root = child        else :            break</code></pre><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>下面为七种经典排序算法指标对比情况：<br><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190509203208-81b78497jw1emncvtdf1qj20u10afn0r%20.jpg" alt="20190509203208-81b78497jw1emncvtdf1qj20u10afn0r"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01—了解web及网络基础</title>
      <link href="/2019/05/09/wang-luo-tong-xin-01-liao-jie-web-ji-wang-luo-ji-chu/"/>
      <url>/2019/05/09/wang-luo-tong-xin-01-liao-jie-web-ji-wang-luo-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>HTTP 的出现主要是为了解决文本传输的难题</p><a id="more"></a><h2 id="TCP-IP-协议族："><a class="header-anchor" href="#TCP-IP-协议族：">¶</a>TCP/IP 协议族：</h2><p>是互联网相关的各类协议族的总称</p><p>重要的一点是<strong>分层</strong>: 应用层、传输层、网络层、数据链路层</p><p>层次化的优点：<br>1、修改某个地方只用改相应的层<br>2、设计变简单，各层管理自己的职责</p><h3 id="分层管理"><a class="header-anchor" href="#分层管理">¶</a>分层管理</h3><p><strong>应用层</strong>：决定向用户提供应用服务时通信的活动，<br><code>FTP(File Transfer Protocol)</code> 文件传输协议、<code>DNS</code>(<code>Domain Name System</code>) 域名系统、<code>HTTP</code>(<code>HyperText Transfer Protocol</code>)<br><strong>传输层</strong>：提供处于网络连接中两台计算机之间的数据传输。<br><code>TCP</code>(<code>Transmission Control Protocol</code>) 传输控制协议、<code>UDP</code>(<code>User Data Protocol</code>) 用户数据报协议<br><strong>网络层（网络互联层）</strong>：处理在网络上流动的数据包（数据包是网络传输的最小数据单位）。该层规定了通过怎样的路径（传输路线）到达对方计算机，并传递数据。作用就是在与对方计算机之间通过多台计算机或网络设备进行传输时，选择一条传输路线。<br><strong>链路层（数据链路层、网络接口层）</strong>：用来处理网络的硬件部分。包括控制操作系统、硬件设备驱动、<code>NIC</code>（<code>Network Interface Card</code>，网络适配器）、光纤等物理课件部分（连接器等一切传输媒介）。</p><h3 id="通信传输流"><a class="header-anchor" href="#通信传输流">¶</a>通信传输流</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526110342-HTTP-%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%20.png" alt="20190526110342-HTTP-传输过程"></p><p>应用发请求通过 <code>TCP</code> 处理报文进行分隔发送给网络层网络层增加 <code>MAC</code> 地址给链路, 之后反向操作, 请求数据的时候每一层处理完成后会给这个数据加上这个层的首部信息, 相反, 处理请求的时候, 每处理一层就删除一个首部, 这叫做数据信息的封装 (<code>encapsulate</code>)。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526110348-HTTP-%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B02%20.png" alt="20190526110348-HTTP-传输过程02"></p><h2 id="IP、TCP-和-DNS"><a class="header-anchor" href="#IP、TCP-和-DNS">¶</a>IP、TCP 和 DNS</h2><h3 id="IP-协议："><a class="header-anchor" href="#IP-协议：">¶</a>IP 协议：</h3><p><code>IP</code>（<code>Internet Protocol</code>）网络协议处于网络层。几乎所有使用网络的系统都会用到 <code>IP</code> 协议。<code>IP</code> 不是 <code>IP</code> 地址，<code>IP</code> 只是一种协议名称。</p><ul><li><p>作用：把各种数据包传给对方，保证能传送到达需要多种条件，其中最重要的是 <code>IP</code> 地址和 <code>MAC</code>（<code>Media Access Control Address</code>) 地址。</p></li><li><p><code>IP</code> 地址：指明节点被分配到的地址</p></li><li><p><code>MAC</code> 地址： 网卡所属的固定地址</p></li><li><p><code>IP</code> 地址可以和 <code>MAC</code> 地址进行配对，<code>IP</code> 可变，但 <code>MAC</code> 基本不会更改。</p></li></ul><p>不同局域网之间的通信需要经过多次中转，在中转时会利用下一站中转设备的 <code>MAC</code> 地址来搜索下一个中转目标，这时会采用 <code>ARP</code> 协议（<code>Addres s Resolution Protocol</code>)，这是用于解析地址的协议，可以根据对方 <code>IP</code> 地址就能反查处对应的 <code>MAC</code> 地址。<br>  信息传输的时候，并不是从一开始就设计好精确的路线，而是边走边瞧，到下一个中转点会自动判断下一个中转点，这叫做路由选择（<code>routing</code>）</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526110449-IP%E5%A4%84%E7%90%86%20.png" alt="20190526110449-IP处理"></p><h3 id="TCP-协议"><a class="header-anchor" href="#TCP-协议">¶</a>TCP 协议</h3><p>按层次位于传输层, 提供可靠的字节流服务 (<code>Byte Stream Service</code>), 意思是为了方便传输, 将大块数据分割成以报文段(<code>segment</code>) 为单位的数据包进行管理可靠的传输服务是指，能够把数据准确可靠的传给对方。</p><blockquote><p>如何确保数据到达目标</p></blockquote><h4 id="三次握手（three—way-handshaking）策略"><a class="header-anchor" href="#三次握手（three—way-handshaking）策略">¶</a>三次握手（<code>three—way handshaking</code>）策略</h4><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526110500-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%20.png" alt="20190526110500-三次握手"></p><ul><li>发送端先发送一个带有 <code>SYN</code>（<code>synchronize</code> 同步）标识的数据包给对方</li><li>对方接收到后回传一个带有  <code>SYN</code>/<code>ACK</code>（<code>acknowledgement</code>)标识的数据包已传达确认信息</li><li>最后发送端再传回一个带有 <code>ACK</code> 标识的数据包代表 “握手” 结束。</li><li>若期间在某个过程莫名中断, <code>TCP</code> 协议会在此以相同顺序发送相同数据包。</li></ul><h3 id="DNS-服务"><a class="header-anchor" href="#DNS-服务">¶</a>DNS 服务</h3><p><code>DNS</code> 服务是和 <code>HTTP</code> 一样位于应用层, 提供<code>域名</code>到 <code>IP</code> 地址之间的解析服务。<br> 计算机可以有 <code>IP</code> 地址, 又可以有主机名和域名。比如可以使用 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 访问百度，也可以使用 <code>119.75.217.109</code> 访问百度。<code>DNS</code> 协议就是可以查询其对应关系的协议。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526110337-DNS%E8%A7%A3%E6%9E%90%20.png" alt="20190526110337-DNS解析"></p><h3 id="各种协议与-HTTP-协议的关系"><a class="header-anchor" href="#各种协议与-HTTP-协议的关系">¶</a>各种协议与 HTTP 协议的关系</h3><p>客户端发出对某 <code>www.</code> 网站的请求, 通过 <code>DNS</code> 协议获取对应的 <code>IP</code> 地址, 在通过 <code>HTTP</code> 协议生成请求报文, 通过 <code>TCP</code> 进行分隔划分成数据包, 通过三次握手把每个报文段可靠的传给对方, 再通过 <code>IP</code> 协议分配 <code>IP</code> 地址和 <code>MAC</code> 地址, 一遍中转一遍传送, 对方通过 <code>IP</code> 协议接收一段段报文, 通过 <code>TCP</code> 协议再一段段重组, 在通过 <code>HTTP</code> 协议对这些内容进行处理请求信息, 把请求结果再像上边的过程走回客户端。一次完整的传输就结束了。</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526110506-%E5%8D%8F%E8%AE%AE%E5%85%B3%E7%B3%BB%20.png" alt="20190526110506-协议关系"></p><h2 id="URI-和-URL"><a class="header-anchor" href="#URI-和-URL">¶</a>URI 和 URL</h2><ul><li><code>URL</code>（<code>Uniform</code> <code>Resource</code> <code>Locator</code>) 统一资源定位符，就是 <code>Web</code> 浏览器访问 <code>web</code> 页面时候的网页地址，<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li><li><code>URI</code>（<code>Uniform</code> <code>Resource</code> <code>Identifier</code>) 统一资源标识符</li><li><em><code>Uniform</code></em> 规定统一格式可方便处理多种不同类型资源。</li><li><em><code>Resouce</code></em> 资源定义是 “可标识的任何东西”。</li><li><em><code>Identifier</code></em> 可标识的对象。也称作标识符。</li></ul><p>综上，<code>URI</code> 就是由某协议方案表示的资源的定位标识符，其中，访问资源所使用的协议类型， <code>HTTP</code> 协议时，协议方案就是 <code>http</code>，除此还有 <code>ftp</code>、<code>mailto</code>、<code>telent</code>、<code>file</code> 等。<br>  <code>URI</code> 用字符串标识某一互联网资源，<code>URL</code> 表示资源的地点，可见 <code>URL</code> 是 <code>URI</code> 的子集。</p><h3 id="URI-格式"><a class="header-anchor" href="#URI-格式">¶</a>URI 格式</h3><p>绝对 <code>URI</code> 格式：</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190526110455-URI%E6%A0%BC%E5%BC%8F%20.png" alt="20190526110455-URI格式"></p><p>可选项：登录信息、服务器端口号、查询字符串、片段标识符</p><h2 id="自我回顾"><a class="header-anchor" href="#自我回顾">¶</a>自我回顾</h2><p>1、<code>HTTP</code>、<code>TCP</code>/<code>IP</code>、<code>DNS</code>、<code>URL</code>、<code>URI</code> 分别是什么?<br>2、<code>TCP</code>/<code>IP</code> 协议为什么进行分层管理，又分为哪些层?<br>3、客户端到服务端的请求过程是什么?<br>4、三次握手怎么进行的?<br>5、各个协议的关系是什么？</p><p><strong><em>注： 本文图片均来自《图解 HTTP》一书</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络通信 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>time与timeit 模块</title>
      <link href="/2019/05/03/python-mo-kuai-time-timeit-mo-kuai/"/>
      <url>/2019/05/03/python-mo-kuai-time-timeit-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h1>一、time 模块</h1><h3 id="1-时间表现形式"><a class="header-anchor" href="#1-时间表现形式">¶</a>1. 时间表现形式</h3><ul><li>timestamp：时间戳，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量</li><li>struct_time： 时间元组，共有九个元素组</li><li>format time： 格式化时间，已格式化的结构使时间更具可读性。包括自定义格式和固定格式</li></ul><h3 id="2-时间格式转换图"><a class="header-anchor" href="#2-时间格式转换图">¶</a>2. 时间格式转换图</h3><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190503200750-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%9B%BE%20.jpg" alt="20190503200750-时间格式转换图"></p><h3 id="3-常用方法"><a class="header-anchor" href="#3-常用方法">¶</a>3. 常用方法</h3><ol><li><p>获取当前时间戳</p><pre class=" language-language-python"><code class="language-language-python">In [26]: time.time()Out[26]: 1556888776.3707364In [25]: time.mktime(time.localtime()) # 元组->时间戳Out[25]: 1556888742.0</code></pre></li><li><p>当前时间的 struct_time 形式</p><pre class=" language-language-python"><code class="language-language-python">In [1]: import time                                                                                      In [2]: time.localtime()                 Out[2]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=20, tm_min=48, tm_sec=32, tm_wday=4, tm_yday=123, tm_isdst=0) In [29]: time.localtime(time.time()) # 时间戳->元组     Out[29]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=21, tm_min=12, tm_sec=6, tm_wday=4, tm_yday=123, tm_isdst=0)  In [22]: time.gmtime()     Out[22]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=13, tm_min=3, tm_sec=21, tm_wday=4, tm_yday=123, tm_isdst=0)   In [30]: time.gmtime(time.time()) # 时间戳->元组     Out[30]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=13, tm_min=12, tm_sec=21, tm_wday=4, tm_yday=123, tm_isdst=0)In [34]: time.strptime(a, "%a %b %d %H:%M:%S %Y") # 字符串->元组Out[34]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=21, tm_min=9, tm_sec=25, tm_wday=4, tm_yday=123, tm_isdst=-1)</code></pre></li><li><p>当前时间的字符串形式</p><pre class=" language-language-python"><code class="language-language-python">In [3]: time.ctime()Out[3]: 'Fri May  3 20:49:30 2019'In [27]: time.ctime(time.time()) # 时间戳->字符串Out[27]: 'Fri May  3 21:08:20 2019'In [4]: time.asctime()Out[4]: 'Fri May  3 20:49:45 2019'In [28]: time.asctime(time.localtime()) # 元组->默认字符串Out[28]: 'Fri May  3 21:09:25 2019'In [7]: time.strftime('%Y-%m-%d %H:%M"%S', time.localtime()) # 元组->格式化字符串Out[7]: '2019-05-03 20:52"47'In [31]: time.strftime("%a %b %d %H:%M:%S %Y", time.localtime())Out[31]: 'Fri May 03 21:15:50 2019'</code></pre></li></ol><h3 id="4-耗时统计"><a class="header-anchor" href="#4-耗时统计">¶</a>4. 耗时统计</h3><ul><li>time.perf_counter()<ul><li>调用一次 perf_counter()，从计算机系统里随机选一个时间点A，计算其距离当前时间点B1有多少秒</li><li>当第二次调用该函数时，默认从第一次调用的时间点A算起，距离当前时间点B2有多少秒</li><li>两个函数取差，即实现从时间点B1到B2的计时功能</li></ul></li><li>time.process_time()<ul><li>返回当前进程执行 CPU 的时间总和，不包含睡眠时间</li><li>由于返回值的基准点是未定义的</li><li>只有连续调用的结果之间的差才是有效的</li></ul></li><li>time.time()<ul><li>连续两次生成的时间戳之差即为耗时<pre class=" language-language-python"><code class="language-language-python">import timedef test():    time.sleep(2)start1 = time.perf_counter()start2 = time.time()start3 = time.process_time()test()finish1 = time.perf_counter()finish2 = time.time()finish3 = time.process_time()t1 = finish1 - start1t2 = finish2 - start2t3 = finish3 - start3print(t1)print(t2)print(t3)</code></pre>结果为：<pre class=" language-language-shell"><code class="language-language-shell">1.9998265000000002 # perf_counter2.000767946243286  # time0.0                # process_time</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器</title>
      <link href="/2019/05/02/python-han-shu-zhuang-shi-qi/"/>
      <url>/2019/05/02/python-han-shu-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="返回函数"><a class="header-anchor" href="#返回函数">¶</a>返回函数</h3><blockquote><p><code>python</code>的常识，函数和其他任何东西一样，都是对象。这意味着可以将<code>函数</code>当做<code>实参</code>传递给函数，或者在函数中将<code>函数</code>作为<code>返回值</code>返回。</p></blockquote><pre class=" language-language-python"><code class="language-language-python">def lazy_sum(*args):    def sum():        ax = 0        for n in args:            ax = ax + n        return ax    return sumf = lazy_sum(1, 3, 5, 7, 9)f()</code></pre><h3 id="闭包"><a class="header-anchor" href="#闭包">¶</a>闭包</h3><ul><li><p>闭包是“返回函数”的一个典型应用</p></li><li><p>闭包的定义：</p><blockquote><p>在一个外函数(<code>outer</code>)中定义了一个内函数(<code>inner</code>)</p><p>内函数里运用了外函数的临时变量</p><p>并且外函数的返回值是内函数的引用</p></blockquote></li><li><p>闭包的使用，可以隐藏内部函数的工作细节，只给外部使用者提供一个可以执行的内部函数的引用。</p></li></ul><pre class=" language-language-python"><code class="language-language-python">#闭包函数的实例  # outer是外部函数 a和b都是外函数的临时变量  def outer( a ):    b = 10    def inner():  # inner是内函数        print(a+b)  #在内函数中 用到了外函数的临时变量    return inner  # 外函数的返回值是内函数的引用  # 在这里我们调用外函数传入参数5  #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo  # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数  demo = outer(5)  # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量  # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数  demo() # 15</code></pre><blockquote><p><code>inner</code>函数修改<code>outer</code>函数变量</p></blockquote><pre class=" language-language-python"><code class="language-language-python">def createCounter():  i = 0  def counter():     nonlocal i # 指定外部函数的局部变量     i = i + 1     return i  return countercounterA = createCounter()print(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5counterB = createCounter()if [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]:   print('测试通过!')else:   print('测试失败!')</code></pre><h3 id="装饰器"><a class="header-anchor" href="#装饰器">¶</a>装饰器</h3><h4 id="装饰器介绍"><a class="header-anchor" href="#装饰器介绍">¶</a>装饰器介绍</h4><p>要了解python中<code>@</code>装饰器的作用，首先要记住这么几点：</p><ol><li><p>装饰器符号<code>@</code>属于语法糖</p><ul><li>什么意思呢？</li><li>就是说，我不按照<code>@</code>装饰器的语法要求来写，而是按照一般<code>python</code>的语法要求来写完全可以。</li><li>那么用<code>@</code>装饰器的格式来写的目的就是为了书写简单方便</li></ul><blockquote><p>注意：装饰器是用于拓展已有函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，实际上就是利用闭包语法实现的。</p></blockquote></li><li><p>装饰器的作用是什么呢？ 简单的理解就是：装饰原有的函数。什么意思呢？</p><ul><li><p>比如有一个函数<code>func(a, b)</code>，它的功能是求<code>a</code>,<code>b</code>的差值</p></li><li><p>现在有一个新需求，就是想对函数功能再装饰下，求完差值后再取绝对值，但是不能能修改原有函数，这时候就需要装饰器装饰函数</p><pre class=" language-language-python"><code class="language-language-python">"""函数闭包实现求差值之后，再求绝对值"""def func(a, b):    return a- bdef abs_num(func):    def inner(a, b):        ret = func(a, b)        return abs(ret)    return inner@abs_numfunc(2, 3)</code></pre></li><li><p>当<code>abs_num</code>装饰函数<code>func</code>时，类似于将函数<code>func</code>作为参数传给<code>abs_num</code>,并将返回值即内层函数(<code>inner</code>)名重新赋值给变量<code>func</code></p></li><li><p>当调用函数<code>func</code>时，实质是调用内层函数<code>inner</code>，在内层函数中执行<code>func</code>函数，即最原始的函数<code>func</code></p></li></ul></li></ol><h4 id="被装饰函数有参数"><a class="header-anchor" href="#被装饰函数有参数">¶</a>被装饰函数有参数</h4><pre class=" language-language-python"><code class="language-language-python">def outer(func):    def inner(x, y):        func(x, y)  # 新版的 func  才是 原来的 add    return inner@outerdef add(x, y):    print(x + y)add(1, 2)  # 新版的 add  是 内层 inner# add(1, 2)   ====>  inner(1, 2)  ====>  func(1, 2)  ===> 3</code></pre><blockquote><p>被装饰函数 有参数，<code>inner</code>和 <code>func </code>需要同样的参数</p></blockquote><h4 id="被装饰函数有返回值"><a class="header-anchor" href="#被装饰函数有返回值">¶</a>被装饰函数有返回值</h4><pre class=" language-language-python"><code class="language-language-python">def outer(func):    def inner(x, y):        r = func(x, y)  # 装饰器装饰之后， func才是真正的add求和函数                r += 10  # 将两数之和再加 10                return r    return inner@outerdef add(x, y):    return x + y# 在装饰器中 对函数的执行结果 加10 处理r = add(10, 200)  # add实际是innerprint(r)</code></pre><blockquote><p>被装饰函数有返回值， <code>inner</code>需要将 <code>func</code> 的结果 返回</p></blockquote><h4 id="被装饰的函数有不定长参数"><a class="header-anchor" href="#被装饰的函数有不定长参数">¶</a>被装饰的函数有不定长参数</h4><pre class=" language-language-python"><code class="language-language-python">def set_func(func):    def call_func(*args, **kwargs):                # func(args, kwargs),此时得到的是元组和字典        # func(*args, **kwargs),此时则是把元素拆包为单个数值和键值对        return func(*args, **kwargs)    return call_func@set_funcdef s(a, b, *args, **kwargs):    print(a, b, args, kwargs)s(12, 50, 34, c=20, d=56)</code></pre><ul><li>形参<ul><li>*args：接收多余的参数，得到元组(args)</li><li>**kwargs:接收多余的关键字参数，得到字典(kwargs)</li></ul></li><li>实参<ul><li>*args：对元组(args)进行拆包，得到单个数值</li><li>**kwargs：对字典(kwargs)拆包，得到单个的键值对</li></ul></li></ul><h4 id="多个装饰器装饰函数"><a class="header-anchor" href="#多个装饰器装饰函数">¶</a>多个装饰器装饰函数</h4><ul><li><p>多个装饰器装饰同一个函数，装饰顺序和执行顺序正好相反</p></li><li><p>装饰器函数的执行顺序和装饰器的顺序有关</p></li></ul><pre class=" language-language-python"><code class="language-language-python">def set_func1(func):    print("这是测试1...")    def call_func1():        print("这是装饰器1...")        return func()    return call_func1def set_func2(func):    print("这是测试2...")    def call_func2():        print("这是装饰器2...")        return func()    return call_func2@set_func1@set_func2def s():    print("hello...")s()</code></pre><ul><li><p>代码从上到下，依次执行，同时装饰器是用来装饰函数的</p><ul><li><p>执行到装饰器set_func1时，无法装饰，先跳过</p></li><li><p>执行装饰器set_func2时，装饰原始函数s，</p><ul><li>先执行set_func2,输出&quot;这是测试2…&quot;，</li><li>然后得到s = call_func2(s)，此时的s是原始函数s</li></ul></li><li><p>然后装饰器set_func1装饰新得到的函数s = call_func2(s)</p><ul><li>先执行set_func1,输出&quot;这是测试1…&quot;</li><li>然后得到s = call_func1(s)，此时的s是新得到的函数s = call_func2(s)</li></ul></li><li><p>最后得到函数s = call_func1(call_func(s))</p></li><li><p>最后执行函数s</p><ul><li>先执行call_func1,输出&quot;这是装饰器1…&quot;</li><li>再执行call_func2,输出&quot;这是装饰器2…&quot;</li><li>最后执行原始函数s，输出&quot;hello…&quot;</li></ul></li></ul></li></ul><h4 id="装饰器带参"><a class="header-anchor" href="#装饰器带参">¶</a>装饰器带参</h4><pre class=" language-language-python"><code class="language-language-python">def set_pars(pars):    def set_func(func):        def call_func():            print("這是測試級別%d" % pars)            return func()        return call_func    return set_func@set_pars(10) # 装饰分两步def s():    print("hello...")s()</code></pre><ul><li>装饰器带参时，装饰函数过程分两步：<ul><li>将参数传给函数set_pars，进行执行</li><li>将函数返回结果作为函数s的装饰器进行装饰</li></ul></li></ul><h4 id="类装饰器"><a class="header-anchor" href="#类装饰器">¶</a>类装饰器</h4><pre class=" language-language-python"><code class="language-language-python">class Test(object):    def __init__(self, func):        self.func = func    def __call__(self, *args, **kwargs):          '''        魔法方法__call__可以将对象设置为可调用对象（callable）,允许一个类的实例像函数一样被调用         '''        print("这是类装饰器...")        return self.func(*args, **kwargs)@Test  # s = Test(s)def s(*args, **kwargs):    print("hello python...")s()</code></pre><ul><li>自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号()应用到某个对象身上都可称之为可调用对象</li><li>判断对象是否为可调用对象可以用函数 callable</li><li>如果在类中实现了 <strong>call</strong> 方法，那么实例对象也将成为一个可调用对象</li></ul><h4 id="练习题"><a class="header-anchor" href="#练习题">¶</a>练习题</h4><ol><li><p>函数input_str中，会获取用户输入字符串，并返回其结果，利用装饰器将其字符串先加上<code>&lt;b&gt;&lt;/b&gt;</code>标签，再添加<code>&lt;i&gt;&lt;/i&gt;</code>标签，如：<code>&lt;i&gt;&lt;b&gt;hello&lt;/b&gt;&lt;/&gt;</code>。注意：<strong>利用双层装饰器实现</strong>。</p><pre class=" language-language-python"><code class="language-language-python">def set_func_b(func):    def call_func():        return "<b>" + func() + "</b>"    return call_funcdef set_func_i(func):    def call_func():        return "<i>" + func() + "</i>"    return call_func@set_func_i@set_func_bdef input_str():    str = input("输入：")    return strprint(input_str())</code></pre></li><li><p>请实现一个装饰器,限制该函数被调用的频率,如10秒一次</p><pre class=" language-language-python"><code class="language-language-python">import timedef set_time(t):    def set_num(func):        dic = {"last_time": 0, "time_interval": t}        def call_func():            now_time = time.time()            finall_time = dic["last_time"] + dic["time_interval"]            if finall_time <= now_time:                dic["last_time"] = now_time                ret = func()                return ret            else:                print("还有%.2fs才能调用该函数" % (finall_time - now_time))        return call_func    return set_num@set_time(5)def s():    print("hello...")</code></pre></li><li><p>请实现一个装饰器,限制该函数每个间隔被调用的频率,如1分钟5次</p><pre class=" language-language-python"><code class="language-language-python">import timedef set_time(t, n):    def set_num(func):        dic = {"last_time": 0, "time_interval": t, "num": 0}        def call_func():            now_time = time.time()            finall_time = dic["last_time"] + dic["time_interval"] # 代表可以重新调用的时间            finall_num = dic["num"] # 代表调用的次数            if finall_num < n: # 当次数不满足时，可以继续调用                if finall_num == 0:                    dic["last_time"] = now_time                dic["num"] += 1                return func()            elif now_time >= finall_time: # 已经超出时间，可以重新调用                dic["num"] = 0                dic["last_time"] = 0                return func()            else:                print("还有%.2fs才能调用该函数" % (finall_time - now_time))        return call_func    return set_num@set_time(60, 5)def s():    print("hello...")s()s()s()time.sleep(2)s()</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git操作</title>
      <link href="/2019/03/31/gong-ju-git-cao-zuo/"/>
      <url>/2019/03/31/gong-ju-git-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，开发人员必备技能。</p><a id="more"></a><h2 id="1-安装Git"><a class="header-anchor" href="#1-安装Git">¶</a>1. 安装Git</h2><ul><li><p>windows：到git官网上下载, <a href="https://gitforwindows.org/" target="_blank" rel="noopener">Download</a> git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p></li><li><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><pre class=" language-language-shell"><code class="language-language-shell">sudo apt-get install git</code></pre><p>安装好后，用<code>git --version</code> 来查看一下版本</p></li></ul><h2 id="2-基本操作"><a class="header-anchor" href="#2-基本操作">¶</a>2. 基本操作</h2><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/Git%E6%93%8D%E4%BD%9C%20.jpg" alt="Git操作"></p><h2 id="3-远程仓库密钥配置"><a class="header-anchor" href="#3-远程仓库密钥配置">¶</a>3. 远程仓库密钥配置</h2><h3 id="1-GitHub密钥配置"><a class="header-anchor" href="#1-GitHub密钥配置">¶</a>1. GitHub密钥配置</h3><h4 id="1-1-设置身份信息"><a class="header-anchor" href="#1-1-设置身份信息">¶</a>1.1. 设置身份信息</h4><p>git设置身份信息</p><pre class=" language-language-shell"><code class="language-language-shell">git config --global user.name "yourname"git config --global user.email "your@email.com"</code></pre><h4 id="1-2-删除-ssh文件夹"><a class="header-anchor" href="#1-2-删除-ssh文件夹">¶</a>1.2. 删除.ssh文件夹</h4><p>（直接搜索该文件夹）下的known_hosts(手动删除即可，不需要git）</p><h4 id="1-3-创建密钥"><a class="header-anchor" href="#1-3-创建密钥">¶</a>1.3. 创建密钥</h4><p>终端输入命令</p><pre class=" language-language-shell"><code class="language-language-shell">ssh-keygen -t rsa -C "your@email.com"（请填你设置的邮箱地址）</code></pre><p>接着出现：</p><pre class=" language-language-shell"><code class="language-language-shell">Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):</code></pre><p>请直接按下回车</p><p>然后系统会自动在.ssh文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打id_rsa.pub</p><p>将全部的内容复制</p><h4 id="1-4-添加公钥"><a class="header-anchor" href="#1-4-添加公钥">¶</a>1.4. 添加公钥</h4><p>打开<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>，登陆你的账户，进入设置</p><p>进入ssh设置</p><p>点击 <code>New SSH key</code></p><p>在key中将刚刚复制的粘贴进去</p><p>最后点击<code>Add SSH key</code></p><h4 id="1-5-测试"><a class="header-anchor" href="#1-5-测试">¶</a>1.5. 测试</h4><p>在终端输入</p><pre class=" language-language-shell"><code class="language-language-shell">ssh -T git@github.com</code></pre><p>你将会看到：</p><pre class=" language-language-shell"><code class="language-language-shell">The authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?</code></pre><p>输入 yes</p><pre class=" language-language-shell"><code class="language-language-shell">Hi humingx! You've successfully authenticated, but GitHub does not provide shell access.</code></pre><p>如果看到Hi后面是你的用户名，就说明成功了。</p><h3 id="2-Gitee仓库密钥配置类似"><a class="header-anchor" href="#2-Gitee仓库密钥配置类似">¶</a>2. Gitee仓库密钥配置类似</h3><blockquote><p>重装系统之后,git push的时候会出现问题:<code>The authenticity of host 'github.com (13.229.188.59)' can't be established.</code>，原因是本地仓库和远程的SSH不匹配</p><p>解决办法：重新配置仓库密钥即可。</p></blockquote><h2 id="4-本地仓库关联远程仓库"><a class="header-anchor" href="#4-本地仓库关联远程仓库">¶</a>4. 本地仓库关联远程仓库</h2><ol><li><p>已有仓库</p><pre class=" language-language-bash"><code class="language-language-bash">cd existing_git_repogit remote add origin https://gitee.com/bookandmusic/test.git</code></pre><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p><pre class=" language-language-bash"><code class="language-language-bash">git push -u origin master</code></pre><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支source推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></li><li><p>新建git仓库，并关联远程仓库</p><pre class=" language-language-bash"><code class="language-language-bash">mkdir testcd testgit inittouch README.mdgit add README.mdgit commit -m "first commit"git remote add origin https://gitee.com/bookandmusic/test.gitgit push -u origin master</code></pre></li><li><p>用git进行push操作的时候，报<code>fatal: TaskCanceledException encountered.</code>的解决方法<br>解决方法如下：</p><pre class=" language-language-shell"><code class="language-language-shell">git config --global credential.helper manager</code></pre><p>之后再push一切正常</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 密钥 </tag>
            
            <tag> 远程仓库关联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js环境配置</title>
      <link href="/2019/03/31/gong-ju-nodejs-huan-jing-pei-zhi/"/>
      <url>/2019/03/31/gong-ju-nodejs-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p><p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p><p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p><a id="more"></a><h2 id="Node-js版本管理"><a class="header-anchor" href="#Node-js版本管理">¶</a>Node.js版本管理</h2><ol><li><p>手动安装nvm</p><pre class=" language-language-bash"><code class="language-language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash</code></pre><pre class=" language-language-bash"><code class="language-language-bash">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash</code></pre><p>运行以上任一命令将下载一个脚本并运行它。<br>该脚本会将nvm存储库克隆到<code>~/.nvm</code>,并尝试将以下代码段中的源代码行添加到正确的配置文件（<code>~/.bash_profile</code>, <code>~/.zshrc</code>, <code>~/.profile</code>, 或 <code>~/.bashrc</code>）</p><pre class=" language-language-bash"><code class="language-language-bash">export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm</code></pre></li><li><p>修改nvm默认镜像源</p><p>用国内镜像快速安装node,把环境变量 NVM_NODEJS_ORG_MIRROR加入到正确的配置文件（<code>~/.bash_profile</code>,<code>~/.zshrc</code>, <code>~/.profile</code>, 或 <code>~/.bashrc</code>）</p><pre class=" language-language-bash"><code class="language-language-bash">export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</code></pre></li><li><p>nvm命令</p><pre class=" language-language-bash"><code class="language-language-bash">nvm version # 查看当前的版本nvm ls-remote # 列出所有可以安装的node版本号nvm install stable # 安装最新稳定版本nvm install  <version> # 安装指定版本号的nodenvm use <version> # 切换使用指定的版本nodenvm ls  # 列出所有已经安装的node版本nvm current # 当前node版本nvm alias default <version>  # 指定默认的node版本nvm alias <name> <version> # 给不同的版本号添加别名nvm unalias <name> ## 删除已定义的别名nvm uninstall <version> 卸载指定的版本</code></pre></li></ol><h2 id="Node-js包管理"><a class="header-anchor" href="#Node-js包管理">¶</a>Node.js包管理</h2><ol><li><p>安装包管理工具: npm、cnpm、yarn</p><pre class=" language-language-bash"><code class="language-language-bash">npm -g install npm@next  # npm升级npm install -g cnpm --registry=https://registry.npm.taobao.org  # cnpm安装npm install -g yarn  # yarn安装</code></pre></li><li><p>查看已安装的所有全局包</p><pre class=" language-language-bash"><code class="language-language-bash">npm list -g --depth=0cnpm list -g --depth=0yarn global list</code></pre></li><li><p>安装包</p><pre class=" language-language-bash"><code class="language-language-bash">npm install -g <package>cnpm install -g <package>yarn global add <package></code></pre></li><li><p>卸载包</p><pre class=" language-language-bash"><code class="language-language-bash">npm uninstall -g <package>cnpm uninstall -g <package>yarn global remove <package></code></pre></li><li><p>更新包</p><pre class=" language-language-bash"><code class="language-language-bash">npm update <package></code></pre></li><li><p>更新本地包</p><pre class=" language-language-bash"><code class="language-language-bash">npm upgrade --saveyarn upgrade</code></pre></li><li><p>其他一些常用的命令</p><pre class=" language-language-bash"><code class="language-language-bash">npm config get registry  # 查看npm当前镜像源npm config set registry https://registry.npm.taobao.org/  # 设置npm镜像源为淘宝镜像yarn config get registry  # 查看yarn当前镜像源yarn config set registry https://registry.npm.taobao.org/  # 设置yarn镜像源为淘宝镜像</code></pre></li></ol><h2 id="Node-js镜像管理"><a class="header-anchor" href="#Node-js镜像管理">¶</a>Node.js镜像管理</h2><ol><li><p>直接编辑npm的配置文件</p><pre class=" language-language-bash"><code class="language-language-bash">npm config edit</code></pre><p>直接修改registry的地址</p><pre class=" language-language-bash"><code class="language-language-bash">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/electron_mirror=https://npm.taobao.org/mirrors/electron/registry=https://registry.npm.taobao.org</code></pre></li><li><p>用代码更改npm的配置文件</p><pre class=" language-language-bash"><code class="language-language-bash">npm config set registry http://registry.npm.taobao.org</code></pre><p>这段代码即将镜像改为淘宝镜像</p></li><li><p>使用nrm管理registry地址</p><ul><li><p>安装nrm</p><pre class=" language-language-bash"><code class="language-language-bash">npm install -g nrm</code></pre></li><li><p>查看镜像列表</p><pre class=" language-language-bash"><code class="language-language-bash">nrm ls</code></pre></li><li><p>切换镜像</p><pre class=" language-language-bash"><code class="language-language-bash">nrm use taobao</code></pre></li><li><p>在nrm添加自己的镜像地址</p><pre class=" language-language-bash"><code class="language-language-bash">nrm add r_name r_url# r_name镜像名字  # r_url镜像地址</code></pre></li><li><p>删除</p><pre class=" language-language-bash"><code class="language-language-bash">nrm del r_name</code></pre></li><li><p>测试镜像的相应速度</p><pre class=" language-language-bash"><code class="language-language-bash">nrm test r_name</code></pre></li></ul></li></ol><h2 id="第三方脚手架"><a class="header-anchor" href="#第三方脚手架">¶</a>第三方脚手架</h2><ol><li><p>vue 3.0(Node最新版)</p><pre class=" language-language-bash"><code class="language-language-bash">npm install -g @vue/cli# ORyarn global add @vue/cli</code></pre></li><li><p>vue2.0</p><p>Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：</p><pre class=" language-language-bash"><code class="language-language-bash">npm install -g @vue/cli-init</code></pre><p>或者直接安装vue-cli脚手架</p><pre class=" language-language-bash"><code class="language-language-bash">cnpm install -g vue-cli</code></pre></li><li><p>http-server</p><p>利用http-server，开启本地服务</p><pre class=" language-language-bash"><code class="language-language-bash">cnpm install -g http-server</code></pre><pre class=" language-language-bash"><code class="language-language-bash">http-server -c-1   （⚠️只输入http-server的话，更新了代码后，页面不会同步更新）Starting up http-server, serving ./Available on:  http://127.0.0.1:8080  http://192.168.8.196:8080Hit CTRL-C to stop the server</code></pre></li><li><p>hexo-cli</p><pre class=" language-language-bash"><code class="language-language-bash">cnpm install -g hexo-cli</code></pre></li><li><p>gitbook-cli</p><pre class=" language-language-bash"><code class="language-language-bash">cnpm install -g gitbook-cli</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> NodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJs </tag>
            
            <tag> npm </tag>
            
            <tag> nvm </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitBook教程</title>
      <link href="/2019/03/31/jiao-cheng-gitbook-jiao-cheng/"/>
      <url>/2019/03/31/jiao-cheng-gitbook-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>GitBook 是一个基于<code>Node.js</code>的命令行工具，可以使用<code>Markdown</code>来制作电子书，并利用<code>Git/Github</code>发布。</p></blockquote><p>支持输出<code>静态站点</code>、<code>PDF</code>、<code>eBook</code>、<code>HTML网页</code>等格式。</p><p>安装 GitBook 需要 Node 环境，具体怎么安装 Node 这里就不多说了。</p><a id="more"></a><h2 id="安装-GitBook"><a class="header-anchor" href="#安装-GitBook">¶</a>安装 GitBook</h2><pre class=" language-language-bash"><code class="language-language-bash">npm install -g gitbook-cli# ORyarn global add gitbook-cli</code></pre><p>检查是否安装成功</p><pre class=" language-language-bash"><code class="language-language-bash">gitbook -V</code></pre><h2 id="导出电子书"><a class="header-anchor" href="#导出电子书">¶</a>导出电子书</h2><p>打开到 gitbook 的目录下</p><h3 id="1、输出静态网页"><a class="header-anchor" href="#1、输出静态网页">¶</a>1、输出静态网页</h3><pre class=" language-language-bash"><code class="language-language-bash">$ gitbook serve .Press CTRL+C to quit ...Starting build ...Successfuly built !Starting server ...Serving book on http://localhost:4000   </code></pre><p>这时候就可以打开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>：进行预览</p><p>同时在项目的目录中多了一个 <code>_book</code> 的文件夹，其中的文件就是生成的静态网页的内容。</p><h3 id="2、导出-PDF"><a class="header-anchor" href="#2、导出-PDF">¶</a>2、导出 PDF</h3><p>在项目的目录中执行</p><pre class=" language-language-bash"><code class="language-language-bash">gitbook pdf .</code></pre><p>项目目录下就会生成 <code>book.pdf</code></p><h3 id="3、导出-epub"><a class="header-anchor" href="#3、导出-epub">¶</a>3、导出 epub</h3><p>在项目目录中执行</p><pre class=" language-language-bash"><code class="language-language-bash">gitbook epub .  </code></pre><p>项目目录下就会生成 <code>book.epub</code></p><h2 id="解决静态网页不能跳转问题"><a class="header-anchor" href="#解决静态网页不能跳转问题">¶</a>解决静态网页不能跳转问题</h2><ul><li><p>在导出的文件夹目录下找到gitbook-&gt;theme.js文件</p></li><li><p>找到下面的代码搜索<code>if(m)for(n.handler&amp;&amp;</code></p></li><li><p>将if(m)改成if(false)</p><pre class=" language-language-js"><code class="language-language-js">if(false)for(n.handler&&(i=n,n=i.handler,o=i.selector),o&&de.find.matchesSelector(Ye,o),n.guid||(n.guid=de.guid++),(u=m.events)||(u=m.events={}),(a=m.handle)||(a=m.handle=function(t){return"undefined"!=typeof de&&de.event.triggered!==t.type?de.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(qe)||[""],l=t.length;l--;)s=Ze.exec(t[l])||[],h=g=s[1],d=(s[2]||"").split(".").sort(),h&&(f=de.event.special[h]||{},h=(o?f.delegateType:f.bindType)||h,f=de.event.special[h]||{},c=de.extend({type:h,origType:g,data:r,handler:n,guid:n.guid,selector:o,needsContext:o&&de.expr.match.needsContext.test(o),namespace:d.join(".")},i),(p=u[h])||(p=u[h]=[],p.delegateCount=0,f.setup&&f.setup.call(e,r,d,a)!==!1||e.addEventListener&&e.addEventListener(h,a)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),o?p.splice(p.delegateCount++,0,c):p.push(c),de.event.global[h]=!0)}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小故事</title>
      <link href="/2019/03/23/sheng-huo-xiao-gu-shi/"/>
      <url>/2019/03/23/sheng-huo-xiao-gu-shi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190517210307-%E8%8C%B6%20.jpg" alt="20190517210307-茶"></p><a id="more"></a><h3 id="关于晚安的事"><a class="header-anchor" href="#关于晚安的事">¶</a>关于晚安的事</h3><p>有一天，天堂放假，一个天使来到人间，为了化解自己的无聊，对一个女孩说，我可以实现你一个愿望，权利，金钱，美貌，爱情……女孩想得很认真，天使有些害怕，如果她说一些他实现不了的愿望，会很没面子。总之一定要让她看到天使是多么厉害，我要她崇拜我，我要让她感激我。“我想每天睡前都能听到你对我说晚安！”天使惊讶于如此简单的愿望，忽然有一种大材小用的感慨。“好，这很容易！”天使根本没有多想，就如此轻易的答应了。女孩也就欢欣雀跃，满心期待着愿望一天一天实现。晚上，在qq上，天使对女孩说：“晚安！”还画了一个：&quot;*&quot;，说这是给她的晚安kiss。女孩也就满足的睡去，梦都散发着甜甜的味道。也偶尔，网关断了，天使也会打个电话给她，对她说晚安，并在电话的另一端亲她的额头，祝她好梦。不知是从何时开始，天使要开始忙自己的事情了，他或许是太忙了，连说晚安的时间都没有了。于是，每天晚上，女孩都满怀期待的等着自己的晚安，却每晚都在失落中入睡，梦里，女孩站在远远的地方，看着忙碌的天使，他或许忙得忘记了晚安的约定，或许等他有空了，他会把亏欠的晚安都补给她。最终，天使忙得都忘记了女孩，终于永远的飞走了，带着那许多亏欠的晚安。很久之后，天堂放假的日子，一大群天使来到人间，他们问女孩，我们可以每人帮你实现一个愿望，权利，金钱，美貌，爱情。……女孩却没有说出自己的愿望，她知道，这是个简单到无法实现的愿望，哪怕是天使，也不能。</p><h3 id="人生"><a class="header-anchor" href="#人生">¶</a>人生</h3><h5 id="26岁"><a class="header-anchor" href="#26岁">¶</a>26岁</h5><p>你看着身边的人都结了婚，婚礼的份子钱逐年递增。春节回家，父母从带你串亲戚，变成了带你去见相亲对象，见了十几个姑娘，你每次都觉得和那个她，差了一点。</p><h5 id="28岁"><a class="header-anchor" href="#28岁">¶</a>28岁</h5><p>你遇到了一个和你遭遇差不多的姑娘，你们有一搭没一搭地聊着。她说：你还不错，你喝了一口可乐说：你也是。<br>你还不确定喜不喜欢她，双方家长就已经摆好了订婚宴。<br>结婚的前一周，你和朋友出去喝酒。你说：不想结婚，朋友说：你啊，就是想太多，谁不是这么过来的？</p><h5 id="29岁"><a class="header-anchor" href="#29岁">¶</a>29岁</h5><p>你们终于结了婚，婚礼办得不大不小，朋友来得不多不少。攒了几年想要去实现理想的钱，搭在了这一场百人的私人庙会上。<br>婚礼进行到中间，司仪带着标准的商业化微笑，对着台下的亲朋喊道，要不要让他们亲一个，台下那些人跟着一起起哄。<br>不知道为什么，你简简单单地亲了一口，俩人恢复到了一开始的站位。<br>你小声说了一句：我爱你。那个昨天还看不惯你倒腾模型的新娘，愣了一下说：我也爱你。<br>你不确定她是不是对你说的，就像你不确定是不是对她说的一样。<br>婚礼结束后，并没有你想象得浪漫，你听着外屋的新娘一笔一笔地算着份子钱。想着不过才两年，怎么就变成这样了。<br>想着想着，洞房夜就睡着了</p><h5 id="30岁"><a class="header-anchor" href="#30岁">¶</a>30岁</h5><p>她怀孕了，辞掉了工作，在家养胎。你在公司逐渐有了点地位，手里管着十来个人，独立负责一个项目。<br>结婚前陪嫁的那辆20万左右的车也变成了你一个人的独享，但你依然不敢放松。<br>每次加班，电话那头都是抱怨与委屈。但你不能争辩什么，谁让她怀了你的孩子。<br>在这一刻，不论是她的父母还是你的父母，都无条件地站在这一边。</p><h5 id="31岁"><a class="header-anchor" href="#31岁">¶</a>31岁</h5><p>孩子落地了，前前后后连孕检加上住院费花了10万块钱，不过无所谓，你看着你的孩子，怎么看怎么喜欢。高兴得仿佛这是你的新生。</p><h5 id="32岁"><a class="header-anchor" href="#32岁">¶</a>32岁</h5><p>这是人生最不愿意重复的一年，平均睡眠3小时，孩子每一个小时都要闹腾一次，第二天拖着睡不醒的眼睛去上班。<br>老板说你上班不干活，回家媳妇说你不干活。你想了半天不明白，那谁干活呢？<br>那辆开了3年的车，成为了你真正的家，你不在抱怨路上拥堵的交通，你甚至开始希望再多堵一会。<br>回到家，你关了发动机，在车上点了一根烟。这是你每天最幸福的十分钟，车前是功名利禄，车尾是柴米油盐。<br>35岁<br>你因为身体越来越差，加班越来越少，晋升的速度也越来越缓慢 。<br>那天下班，媳妇告诉你，孩子要上幼儿园了，双语的一个月3000，你皱了皱眉头，那边就已经不耐烦了。<br>“四单元的老王家孩子，一个月6000”“你已经这样了，你想让孩子也输？”<br>你没说话，回屋给媳妇转了6000块钱。这笔钱，你原本打算，给自己过个生日，买台新电脑。</p><h5 id="38岁"><a class="header-anchor" href="#38岁">¶</a>38岁</h5><p>孩子上了一年级，老师说一年级最关键，打好基础很重要。你笑着说，是是是，老师您多照顾。<br>新生接待的老师看着你不明事理的脸，给你指了一条明路，课外辅导班，一个月2200。</p><h5 id="40岁"><a class="header-anchor" href="#40岁">¶</a>40岁</h5><p>孩子上了三年级，老师说，三年级，最关键，承上启下很重要。你笑着说：是是是，正打算再报个补习班。</p><h5 id="44岁"><a class="header-anchor" href="#44岁">¶</a>44岁</h5><p>孩子上了初中，有一天回到家，他对你说，爸爸，我想学钢琴。你没什么犹豫的，你以为这些年，你已经习惯了。<br>但那句“爸爸现在买不起”你始终说不出口，好在孩子比较懂事。他说：爸爸没事，要不我先学陶笛也可以，你看着这么懂事的孩子，却开心不起来。</p><h5 id="46岁"><a class="header-anchor" href="#46岁">¶</a>46岁</h5><p>孩子上了一个不好不差的高中，有一天你在开会，接到了老师的电话，电话里说你的孩子在学校打架了，叫你去一趟。你唯唯诺诺地和那个比你还小5岁的领导请了个假。<br>到学校又被老师训了一通，无非台词就是那一句，你们做家长的就知道工作，能不能陪陪孩子。<br>你看着这个老师，有点可笑。好像当时说，家长在外辛苦点，多赚点钱让孩子多补补课的和他不是一个人。</p><h5 id="50岁"><a class="header-anchor" href="#50岁">¶</a>50岁</h5><p>孩子上了大学，很争气，是一个一本。他学的专业你有点看不懂，你只知道工作不一定好找而且学费还死贵。<br>你和他深夜想聊聊，准备了半斤白酒，一碟花生米，你说着那些曾经你最讨厌的话。――还是要为以后工作着想，挑个热门的专业，活着比热爱重要。<br>你们从交流变成了争吵，你发现，你老了，老到可能都打不过这个18岁的孩子，你说不过他，只能说一句：我是你爸爸！<br>孩子看着你，知道再怎么争辩都没用，这场确立你最后威严的酒局不欢而散。<br>你听得不真切，在孩子回自己屋的路上好像叨叨了一句，我不想活得像你一样。<br>怎么就哭了呢？50岁的人了。<br>一定是酒太辣了，对不对，一定是酒太辣了。</p><h5 id="55岁"><a class="header-anchor" href="#55岁">¶</a>55岁</h5><p>孩子工作了，似乎有一点理解你了，但你却反了过来，你说不要妥协。</p><h5 id="56岁"><a class="header-anchor" href="#56岁">¶</a>56岁</h5><p>孩子也结婚了，你问他喜欢那个姑娘么。他愣了愣说：喜欢吧</p><h5 id="60岁"><a class="header-anchor" href="#60岁">¶</a>60岁</h5><p>辛苦了一辈子，想出去走走，身边的那个人过了30年，你依旧分不清到底喜不喜欢。<br>你们开始规划旅游路线，这么多年了，你们还是存在分歧，还是在争吵。某个瞬间，你觉得，这样可能也挺好。<br>一切都准备好了，儿子说：爸妈，我工作太忙了，可以帮我照顾一下孩子么。<br>你们退了机票，又回到了30年前。</p><h5 id="70岁"><a class="header-anchor" href="#70岁">¶</a>70岁</h5><p>孩子的孩子也长大了，不用天天操心了，你下定决心说：一定要去玩一趟。可是手边的拐杖，只能支持你走到楼下的花园。</p><h5 id="75岁"><a class="header-anchor" href="#75岁">¶</a>75岁</h5><p>你在医院的病床上，身边聚满了人，你迷迷糊糊的看见医生摇了摇头。<br>周围那些人神情肃穆，你明白了，你要死掉了。你没有感到一丝害怕，你突然问自己，我到底是什么时候死掉的呢？<br>你想起来30岁的那场婚礼，原来，那时候你就死掉了吧。<br>依照惯例，死前的3秒，你的大脑要走马灯，倒叙你这75个年头的一生，画面一张一张地过。<br>1秒<br>2秒<br>两秒过去了，你面无表情地看着这两秒内的回忆。<br>第3秒，突然你笑了，原来已经回到了15岁的那一年。<br>你看见一个男孩，他叼着一袋牛奶，背着书包。从另一个女孩家的阳台下跑过，那个男孩朝窗户里看了看。<br>那是15岁的你暗恋的那个女孩子，你想不起来她长什么样子了，最后一秒你努力地回忆着，然后终于笑了出来。<br>3秒过去了<br>身边的人突然间开始嚎啕大哭，你可能听不清了，你最后听到的嘈杂的声音，是一群十五六的少年起着哄说的――<br>答应他，答应他，答应他。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来来来，你能猜出来吗</title>
      <link href="/2019/03/23/sheng-huo-xiao-hua-yi/"/>
      <url>/2019/03/23/sheng-huo-xiao-hua-yi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/20190517210413-%E5%91%BD%20.jpg" alt="20190517210413-命"></p><a id="more"></a><h3 id="来来来，你能猜出来吗"><a class="header-anchor" href="#来来来，你能猜出来吗">¶</a>来来来，你能猜出来吗</h3><p>考试前，小红对小明说，如果这次你能考全班第一，现在就和你啪啪啪。全班同学都听到了，考卷发下来后，大家都默默的把笔放下，打算交白卷。小明眼泛泪光，看着虎背熊腰200斤的小红，默默的把试卷撕碎吃了！小红微微一笑，在自己的试卷上写下了小明的名字。老师改卷的时候把唯一一份写答案的试卷扔进了碎纸机，毕竟她是小明的母亲，校长在门缝里看到了，偷偷把一张试卷写满，写上了小明的名字，毕竟他和小红妈妈的艺术照还在小红手里，教育局长发现了试卷，把它点着烧了，他满意的看着火光想起了小明嫩滑滑的身体。市长收到消息，偷天换日般的把小刚的试卷换成小明的，毕竟小红有了小明就不会再来打扰他了。省长坐在办公室默默的注视着屏幕上显示出来的市长的一举一动，一道命令下去，学校办公室着火了，毕竟小明可是他的儿子。然而大家都不知道副校长早就把试卷偷偷的拿到了自己的办公室然后走向书架后面的暗门跪在了小红的面前，小红一边脱下假面具和看起来两百斤的厚的衣服露出了倾国倾城的面容和苗条的身材一边用风铃般的声音说着“关于爱情我们永远都不知道他会发生些什么”副校长顺从的说着“是啊是啊”随即含住了小红那比自己还大的丁丁，陶醉的闭上了眼</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 笑话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笑话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客配置教程</title>
      <link href="/2019/03/23/jiao-cheng-hexo-bo-ke-pei-zhi-jiao-cheng/"/>
      <url>/2019/03/23/jiao-cheng-hexo-bo-ke-pei-zhi-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>实现Hexo + GitHub 搭建博客。</p><a id="more"></a><h2 id="Hexo简介"><a class="header-anchor" href="#Hexo简介">¶</a>Hexo简介</h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><blockquote><p>注意: 查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a>以获取更多信息。如果使用Hexo时遇到任何问题，可以在<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">故障排除</a>中找到答案，或者可以在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>上询问。</p></blockquote><h2 id="hexo教程"><a class="header-anchor" href="#hexo教程">¶</a>hexo教程</h2><ol><li>git和nodejs安装好后，就可以安装hexo了</li></ol><pre class=" language-language-shell"><code class="language-language-shell">npm install hexo-cli -gnpm install hexo --save</code></pre><p>依旧用hexo -v查看一下版本</p><p>至此就全部安装完了。</p><ol start="2"><li>接下来初始化一下hexo</li></ol><pre class=" language-language-shell"><code class="language-language-shell">hexo init</code></pre><ol start="3"><li>创建一个新帖子</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ hexo new "我的新帖子"</code></pre><p>更多信息：<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">写作</a></p><ol start="4"><li>运行服务器</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ hexo server</code></pre><p>更多信息：<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">服务器</a></p><ol start="5"><li>生成静态文件</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ hexo generate</code></pre><p>更多信息：<a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">生成</a></p><ol start="6"><li>部署到远程站点</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ hexo deploy</code></pre><p>更多信息：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">部署</a></p><h2 id="Hexo中添加本地图片"><a class="header-anchor" href="#Hexo中添加本地图片">¶</a>Hexo中添加本地图片</h2><ol><li><p>把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p></li><li><p>在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件</p></li><li><p>等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p></li><li><p>最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到<code>xxxx</code>这个文件夹中，然后只需要在<code>xxxx.md</code>中按照markdown的格式引入图片：</p><pre class=" language-language-markdown"><code class="language-language-markdown">![你想输入的替代文字](xxxx/图片名.jpg)</code></pre><blockquote><p><code>xxxx</code>是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入<code>xxxx</code>这个文件夹内就好了，很像引用相对路径。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask易错点</title>
      <link href="/2019/03/22/flask-yi-cuo-dian/"/>
      <url>/2019/03/22/flask-yi-cuo-dian/</url>
      
        <content type="html"><![CDATA[<h4 id="1-with上下文管理器"><a class="header-anchor" href="#1-with上下文管理器">¶</a>1 with上下文管理器</h4><p>常用：</p><pre class=" language-language-python"><code class="language-language-python">with open("file_name","wb") as f:f.write("hello flask")</code></pre><p>自定义：</p><pre class=" language-language-python"><code class="language-language-python">class Foo(gbiect):def __enter__(self):"""进入with语句的时候被with调用"""print("enter called")def __exit_(self, exc_type, exc_val, exc_tb):"""离开with语句的时候被with调用"""        print("exit called")        print("exc_type:%s" % exc_type)        print("exc_val:9%s" % exc_val)print("exc_tb:%s"%exc_tb)with Foo() as foo:    print("helto python")    a=1/0    print("hello end")</code></pre><p>运行结果：</p><blockquote><pre class=" language-language-bash"><code class="language-language-bash">enter called Traceback (most recent call last): hello python File"/Users/delron/Desktop/code/03 with. py", line 39, in <module>exit called     a=1/0ZeroDivisionError: integer division or modulo by zero exc_type:<type ' exceptions. ZeroDivisionError'>exc_val: integer division or modulo by zero exc_tb:<traceback object at 0x1097bc440>Process finished with exit code 1</code></pre></blockquote><h4 id="2-json模块"><a class="header-anchor" href="#2-json模块">¶</a>2 json模块</h4><p>dumps  —&gt; 可以将字典转换为字符串</p><pre class=" language-language-python"><code class="language-language-python">import jsondata = {"name": "python", "age": 18}json_str = json.dumps(data)print(type(json_str), json_str)</code></pre><p>运行结果：</p><pre class=" language-language-python"><code class="language-language-python">str      {"age": 18, "name": "python"}</code></pre><p>loads ——&gt; 将字符串转换为字典</p><pre class=" language-language-python"><code class="language-language-python">import jsona = '{"city": "sz", "country": "china"}'b = json.loads(a)print(type(b), b)</code></pre><p>运行结果：</p><pre class=" language-language-python"><code class="language-language-python">dict      {"city": "sz", "country": "china"}</code></pre><h4 id="3-xss攻击"><a class="header-anchor" href="#3-xss攻击">¶</a>3 xss攻击</h4><p>当前段传送过来的数据默认进行转义，否则，则会默认执行前端传送的数据，则称为xss攻击</p><h4 id="4-flask-和mysql"><a class="header-anchor" href="#4-flask-和mysql">¶</a>4 flask 和mysql</h4><p><strong>Linux：</strong></p><p><em>flask使用mysql数据库需要：</em></p><ol><li><strong>pymysql</strong></li><li><strong>sqlalchemy</strong></li><li><strong>flask_sqlalchemy</strong></li></ol><p><strong>windows：</strong></p><p><em><strong>Flask利用pymysql出现Warning：1366的解决办法</strong></em></p><p><em>flask使用mysql数据库需要：</em></p><ol><li><p><strong>mysql-connector-python</strong></p></li><li><p><strong>sqlalchemy</strong></p></li><li><p><strong>flask_sqlalchemy</strong></p><pre class=" language-language-python"><code class="language-language-python">SQLALCHEMY_DATABASE_URI = "mysql+mysqlconnector://root:mysql@localhost/ihome01"</code></pre></li></ol><h4 id="5-装饰器"><a class="header-anchor" href="#5-装饰器">¶</a>5 装饰器</h4><pre class=" language-language-python"><code class="language-language-python">@app.route("/")def index():   return "index page"</code></pre><pre class=" language-language-python"><code class="language-language-python">def index():   return "index page"app.route("/)(index)</code></pre><p>装饰器不仅仅是定义时可以用，还可以在定义完再使用</p><h4 id="6-自定义正则转换器及蓝图"><a class="header-anchor" href="#6-自定义正则转换器及蓝图">¶</a>6 自定义正则转换器及蓝图</h4><pre class=" language-language-python"><code class="language-language-python">from werkzeug.routing import BaseConverter# 定义正则转换器class ReConverter(BaseConverter):    def __init__(self, url_map, regex):        # 调用父类初始化方法        super(ReConverter, self).__init__(url_map)        # 重新赋值        self.regex = regex</code></pre><pre class=" language-language-python"><code class="language-language-python">  # 添加自定义的转换器    app.url_map.converters["re"] = ReConverter</code></pre><pre class=" language-language-python"><code class="language-language-python">from flask import Blueprint, current_apphtml = Blueprint("web_html", __name__)@html.route("/<re(r'.*'):file_name>")def web_html(file_name):    if not file_name:        file_name = "index.html"    if file_name != "favicon.ico":        file_name = "html/" + file_name    return current_app.send_static_file(file_name)</code></pre><pre class=" language-language-python"><code class="language-language-python"># 注册蓝图app.register_blueprint(html)</code></pre><h4 id="7-登录装饰器"><a class="header-anchor" href="#7-登录装饰器">¶</a>7 登录装饰器</h4><pre class=" language-language-python"><code class="language-language-python"># 定义验证登录状态的装饰器def login_required(view_func):    # wraps函数的作用是将wrapper内层函数的属性设置为被装饰函数view_func的属性    @functools.wraps(view_func)    def wrapper(*args, **kwargs):        # 判断用户登录状态        user_id = session.get("user_id")        # 如果用户是登录状态，则执行登录状态        if user_id is not None:            # 将user_id保存到g对象中，在视图函数中，可以通过g对象获取保存数据            g.user_id = user_id            return view_func(*args, **kwargs)        # 如果未登录，则返回未登录信息        else:            return jsonify(errno=RET.SESSIONERR, errmsg="用户未登录")    return wrapper</code></pre><h4 id="8-视图函数"><a class="header-anchor" href="#8-视图函数">¶</a>8 视图函数</h4><ol><li>路由匹配不能出现相同的地址，即同一地址，不能出现两个视图函数</li><li>路由匹配不能出现不同的函数，即不同的地址，不能出现相同的函数名</li></ol><h4 id="9-参数获取"><a class="header-anchor" href="#9-参数获取">¶</a>9 参数获取</h4><ol><li><p>直接从request中获取json数据，并将其转换为字典</p><pre class=" language-language-python"><code class="language-language-python">house_data = request.get_json()</code></pre></li><li><p>从request中获取文件</p><pre class=" language-language-python"><code class="language-language-python">image_file = request.files.get("house_image")</code></pre></li><li><p>从request中的form表单中获取键值对</p><pre class=" language-language-python"><code class="language-language-python">house_id = request.form.get("house_id")</code></pre></li></ol><h4 id="10-数据库操作"><a class="header-anchor" href="#10-数据库操作">¶</a>10 数据库操作</h4><p>​在同一视图函数中，可以对对象多次修改，只提交一次即可</p><pre class=" language-language-python"><code class="language-language-python">db.session.add(house_image)db.session.add(house)try:    db.session.commit()except Exception as e:    current_app.logger.error(e)    db.session.rollback()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础-项目流程</title>
      <link href="/2019/03/22/django-xiang-mu-liu-cheng/"/>
      <url>/2019/03/22/django-xiang-mu-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="基本流程"><a class="header-anchor" href="#基本流程">¶</a>基本流程</h2><p>使用命令<code>django-admin startproject djangodemo</code>,创建Django项目</p><pre class=" language-language-python"><code class="language-language-python">|-- djangodemo|    |-- __init__.py  # 说明booktest是一个python包。|    |-- settings.py # 项目的配置文件。|    |-- urls.py  # 进行url路由的配置。|    |-- wsgi.py  # web服务器和Django交互的入口。||-- manage.py  # 项目的管理文件。</code></pre><p>使用命令<code>python manage.py startapp books</code>, 创建DjangoApp</p><pre class=" language-language-python"><code class="language-language-python">|- books    |- __init__.py  # 说明目录是一个Python模块。    |- models.py  # 写和数据库项目的内容, 设计模型类。    |- views.py  # 接收请求，进行处理，与M和T进行交互，返回应答。定义处理函数，视图函数。    |- tests.py  # 写测试代码的文件。    |- admin.py  # 网站后台管理相关的文件。</code></pre><h2 id="项目配置"><a class="header-anchor" href="#项目配置">¶</a>项目配置</h2><blockquote><p>修改项目根目下的<code>settings.py</code>文件</p></blockquote><h3 id="注册App"><a class="header-anchor" href="#注册App">¶</a>注册App</h3><pre class=" language-language-python"><code class="language-language-python">INSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'books', # 应用名  ]</code></pre><h3 id="配置数据库"><a class="header-anchor" href="#配置数据库">¶</a>配置数据库</h3><pre class=" language-language-python"><code class="language-language-python">DATABASES = {      'default': {          # 'ENGINE': 'django.db.backends.sqlite3',          # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),          'ENGINE': 'django.db.backends.mysql',          'NAME': 'djangodemo',  # 使用的数据库名字，数据库必须手动创建          'USER': 'root',  # 连接mysql的用户名          'PASSWORD': 'mysql',  # 用户名对应的密码          'HOST': 'localhost',  # 指定mysql数据库所在电脑的IP          'PORT': 3306,  # mysql服务器的端口号      }  }</code></pre><blockquote><p><strong>注意:</strong>  mysql数据库<strong>链接驱动</strong>，django2.x之后，官方建议使用 <code>mysqlclient</code>,若非要使用 <code>pymysql</code>，还需要如下配置</p></blockquote><p>在与<code>settings.py</code>同级的<code>__init__.py</code>文件中添加:</p><pre class=" language-language-python"><code class="language-language-python">import pymysqlpymysql.install_as_MySQLdb()</code></pre><h3 id="配置模板目录"><a class="header-anchor" href="#配置模板目录">¶</a>配置模板目录</h3><pre class=" language-language-python"><code class="language-language-python"># 在项目根目录下, 新建模板目录 templatesTEMPLATES = [  {      'BACKEND': 'django.template.backends.django.DjangoTemplates',      'DIRS': [os.path.join(BASE_DIR, "templates")],      'APP_DIRS': True,      'OPTIONS': {          'context_processors': [              'django.template.context_processors.debug',              'django.template.context_processors.request',              'django.contrib.auth.context_processors.auth',              'django.contrib.messages.context_processors.messages',          ],      },  },]</code></pre><h3 id="配置静态资源"><a class="header-anchor" href="#配置静态资源">¶</a>配置静态资源</h3><pre class=" language-language-python"><code class="language-language-python"># 静态资源展示的url前缀STATIC_URL = '/static/'# 静态资源存放的目录，需要先创建static目录STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]</code></pre><h3 id="本地化配置"><a class="header-anchor" href="#本地化配置">¶</a>本地化配置</h3><pre class=" language-language-python"><code class="language-language-python">LANGUAGE_CODE = 'zh-hans'TIME_ZONE = 'Asia/Shanghai'USE_TZ = True # 设置为True， 数据库存储默认使用UTC时区，设置为False， 使用本地时区</code></pre><h3 id="配置HOST地址"><a class="header-anchor" href="#配置HOST地址">¶</a>配置HOST地址</h3><pre class=" language-language-python"><code class="language-language-python">ALLOWED_HOSTS = ["*"] # 允许客户端通过服务器的任何ip(本地ip和网络ip)访问服务器</code></pre><h2 id="创建后台超级管理员"><a class="header-anchor" href="#创建后台超级管理员">¶</a>创建后台超级管理员</h2><ul><li><p>进入manage.py目录下，使用命令<code>python manage.py createsuperuser</code>来进行创建</p></li><li><p>接下来输入用户名称 : <code>Username(leave bkank to use 'administrator'): root</code></p></li><li><p>然后是输入邮箱（QQemail等都可以）: <code>Email address：xxxx@xxx.com</code></p></li><li><p>输入密码（输入密码时不会显示出来，并且长度必须超过八位才行）: <code>Password：********</code></p></li><li><p>确认密码 : <code>Password(again)：********</code></p></li><li><p>当两次密码输入相同且超过八位的时候，就会提示创建超级用户成功 : <code>Superuser created successfully</code></p></li></ul><h2 id="数据模型"><a class="header-anchor" href="#数据模型">¶</a>数据模型</h2><h3 id="创建模型类"><a class="header-anchor" href="#创建模型类">¶</a>创建模型类</h3><p>在应用<code>books</code>目录下的<code>models.py</code>文件中创建模型类</p><pre class=" language-language-python"><code class="language-language-python">from django.db import models# Create your models here.class BookInfo(models.Model):    title = models.CharField(max_length=20)    pub_date = models.DateField()    read = models.IntegerField(default=0)    comment = models.IntegerField(default=0)    # 删除标记    isDelete = models.BooleanField(default=False)    class Meta:        db_table = 'tb_books'  # 指定表名        verbose_name = '图书'  # 后台显示表名        verbose_name_plural = verbose_name    def __str__(self):        return self.title  # 查询对象时，显示信息class HeroInfo(models.Model):    name = models.CharField(max_length=20)    gender = models.BooleanField(default=False)    comment = models.CharField(max_length=200)    book = models.ForeignKey('BookInfo', on_delete=models.CASCADE)    isDelete = models.BooleanField(default=False)    class Meta:        db_table = 'tb_heros'  # 指定表名        verbose_name = '英雄'  # 后台显示表名        verbose_name_plural = verbose_name    def __str__(self):        return self.name  # 查询对象时，显示信息</code></pre><h3 id="模型类生成表"><a class="header-anchor" href="#模型类生成表">¶</a>模型类生成表</h3><ul><li><p>生成迁移文件<code>python manage.py makemigrations</code></p></li><li><p>迁移文件生成表<code>python manage.py migrate</code>,生成表名的默认格式：应用名_模型类名小写,可以指定表名</p></li></ul><h3 id="Admin后台管理"><a class="header-anchor" href="#Admin后台管理">¶</a>Admin后台管理</h3><p>在应用book下的admin.py中注册模型类。</p><p>告诉djang框架根据注册的模型类来生成对应表管理页面。</p><pre class=" language-language-python"><code class="language-language-python">from book.models import BookInfofrom book.models import HeroInfo# 后台管理相关文件# Register your models here.class BookInfoAdmin(admin.ModelAdmin):    """图书模型管理类"""    list_display = ['id', 'book_title', 'book_pub_date']class HeroInfoAdmin(admin.ModelAdmin):    list_display = ['id', 'hero_name', 'hero_sex', 'hero_comment', 'hero_book']# 注册模型类admin.site.register(BookInfo, BookInfoAdmin)admin.site.register(HeroInfo, HeroInfoAdmin)</code></pre><h2 id="模板"><a class="header-anchor" href="#模板">¶</a>模板</h2><p>在 <code>templates</code>目录下 创建  <code>hero_list.html</code>, 展示所有 英雄信息</p><pre class=" language-language-python"><code class="language-language-python"><!DOCTYPE html><html lang="zh"><head>    <meta charset="UTF-8">    <title>英雄列表</title></head><body><table>    {% for hero in heroes %}   # 类似python的for循环和if判断        {% if not hero.isDelete %}            <tr>                <td>{{ hero.id }}</td>                <td>{{ hero.name }}</td>                <td>{{ hero.gender }}</td>                <td>{{ hero.comment }}</td>                <td>{{ hero.book }}</td>            </tr>        {% endif %}    {% endfor %}</table></body></html></code></pre><h2 id="视图"><a class="header-anchor" href="#视图">¶</a>视图</h2><p>在 <code>books</code> APP目录下的 <code>views.py</code>中创建自己的 视图函数</p><pre class=" language-language-python"><code class="language-language-python">from django.shortcuts import renderfrom books.models import *def hero_list_view(request):    heros = HeroInfo.objects.all()  # 利用模型类查询全部数据    return render(request, 'hero_list.html', context={'heros': heros})  # 利用render函数渲染模板</code></pre><h2 id="路由"><a class="header-anchor" href="#路由">¶</a>路由</h2><p>在 项目同名目录的 <code>urls.py</code>中配置路由</p><pre class=" language-language-python"><code class="language-language-python">from django.urls import pathfrom book.views import *urlpatterns = [    path('heroes/', hero_list_view)]</code></pre><h2 id="项目启动"><a class="header-anchor" href="#项目启动">¶</a>项目启动</h2><ul><li><p>只能通过本地ip访问 : <code>python manage.py runserver</code></p><p>浏览器输入<code>127.0.0.1:8000</code>访问服务器</p></li><li><p>可以通过网络ip访问 : <code>python manage.py runserver 0.0.0.0:8000</code></p><p>浏览器输入<code>网络ip:8000</code>访问服务器，同时需要搭配 <code>settings.py</code>中的配置参数使用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2019/03/22/python-gao-ji-yi-chang/"/>
      <url>/2019/03/22/python-gao-ji-yi-chang/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2006/20190517210629-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%20.png" alt="20190517210629-异常类型"></p><h3 id="自定义异常类型"><a class="header-anchor" href="#自定义异常类型">¶</a>自定义异常类型</h3><pre class=" language-language-python"><code class="language-language-python"># 自定义错误类型class ArgsException(Exception):    def __init__(self, num, num_type):        self.num = num  # 用来描述参数个数        self.num_type = num_type  # 用户描述参数类型num1 = input("输入数字:")num2 = input("输入数字:")try:    if num1.isdigit() is False or num2.isdigit() is False:             # 错误类型的实例对象        raise ArgsException(2, "int")  # raise 异常类型  -> 主动抛出异常except ArgsException as ret:    print("需要%d个%s参数" % (ret.num, ret.num_type))</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔法方法</title>
      <link href="/2019/03/22/python-mian-xiang-dui-xiang-mo-fa-fang-fa/"/>
      <url>/2019/03/22/python-mian-xiang-dui-xiang-mo-fa-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>据说，Python 的对象天生拥有一些神奇的方法，它们总被双下划线所包围，他们是面向对象的 Python 的一切。</p><p>他们是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。</p><p>Python 的魔术方法非常强大，然而随之而来的则是责任。了解正确的方法去使用非常重要！</p><p><img src="https://gitee.com/bookandmusic/imgs/raw/master/uPic/2020%2005/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%20.png" alt="魔法方法"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> python </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
