{"meta":{"title":"Bookandmusic","subtitle":"踮起脚尖，另一种高度","description":null,"author":"bookandmusic","url":"https://www.bookandmusic.cn","root":"/"},"pages":[{"title":"关于我","date":"2019-03-15T16:08:23.000Z","updated":"2021-01-22T07:08:42.000Z","comments":false,"path":"about/index.html","permalink":"https://www.bookandmusic.cn/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-09-30T09:25:30.000Z","updated":"2020-12-01T14:23:48.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.bookandmusic.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-14T15:44:37.000Z","updated":"2020-12-01T14:23:48.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.bookandmusic.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JWS的python实现方案","slug":"WEB-JWS的python实现方案","date":"2021-06-10T15:00:11.000Z","updated":"2021-06-11T15:04:58.574Z","comments":true,"path":"2021/06/10/web-jws-de-python-shi-xian-fang-an/","link":"","permalink":"https://www.bookandmusic.cn/2021/06/10/web-jws-de-python-shi-xian-fang-an/","excerpt":"","text":"JWS在python中的 jws实现方案有以下两种： pyjwt 很多框架的 token认证方案，都是对pyjwt的进一步封装， 如：DRF的 restframework-jwt、Flask的 flask-jwt-extend 12345678910111213141516171819202122import jwtfrom datetime import datetime, timedeltaexpiry = datetime.utcnow() + timedelta(seconds=60*60)secret = &#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&#x27;payload = &#123; &#x27;exp&#x27;: datetime.utcnow() + timedelta(seconds=30), # 过期时间 &#x27;uid&#x27;: 1, &#x27;username&#x27;: &#x27;admin&#x27;&#125;# 加密, 得到 token字符串token = jwt.encode(payload, secret, algorithm=&#x27;HS256&#x27;)print(token)# head部分.payload载荷部分.签名部分# 解密，校验签名payload = jwt.decode(encoded_jwt, secret, algorithms=[&#x27;HS256&#x27;])print(payload)# 如果 token 被修改过后，则会抛出 DecodeError: Signature verification failed# 如果 token 过期后，则会抛出 ExpiredSignatureError: Signature has expired 生成的token： 1b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MjMzMzk0MjQsInVpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiJ9.c__sgvA9VOv54T1R5Nm8Z4scFBMEgHo46xVF3PxtaRw&#x27; 进行base64解码： 1234567In [1]: import base64 In [2]: base64.decodebytes(b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&#x27;)Out[2]: b&#x27;&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;&#x27; In [3]: base64.decodebytes(b&#x27;eyJleHAiOjE2MjMzMzk0MjQsInVpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiJ9&#x27;)Out[3]: b&#x27;&#123;&quot;exp&quot;:1623337821,&quot;uid&quot;:1,&quot;username&quot;:&quot;admin&quot;&#125;&#x27; itsdangerous ItsDangerous默认使用HMAC和SHA-512进行签名, 生成临时身份令牌 有时您只想将一些数据发送到不受信任的环境。但是如何安全地做到这一点？诀窍就是签名。只要知道一个密钥，您就可以对数据进行加密签名并将其移交给其他人。当您取回数据时，可以轻松确保没有人篡改数据。使用itsdangerous可以实现此种方案。 例如： 想通过邮件让用户注册激活的时候地址当中带有用户的信息。但是信息一般都是敏感信息，而且还想让它具有时效性，所以就可以选择itsdangerous模块 1234567891011121314151617181920212223from itsdangerous import TimedJSONWebSignatureSerializerfrom itsdangerous import SignatureExpired, BadSignature, BadDataexpiry = 60secret = &#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&#x27;payload = &#123; &#x27;uid&#x27;: 1, &#x27;username&#x27;: &#x27;admin&#x27;&#125;# 创建序列化器对象serializer = TimedJSONWebSignatureSerializer(secret, expires_in=expiry)# 加密token = serializer.dumps(payload)print(token)# head部分.payload载荷部分.签名部分# 解密，校验签名payload = serializer.loads(token)print(payload )# 如果 token 被修改过后，则会抛出 BadSignature: Signature b&#x27;xxx&#x27; does not match# 如果 token 过期后，则会抛出 SignatureExpired: Signature expired 生成的token： 1b&#x27;eyJhbGciOiJIUzUxMiIsImlhdCI6MTYyMzMzODcwNiwiZXhwIjoxNjIzMzM4NzY2fQ.eyJ1aWQiOjEsInVzZXJuYW1lIjoiYWRtaW4ifQ._cpzkgKX-u7w8r57BGbwMHEg-EkHdJKjC74x_gPvrSGkPq5mrjmAXWFMSit0l_RGV-DzUJA09kEL6uX-ReCL0g&#x27; 进行base64解码： 1234567In [1]: import base64 In [2]: base64.decodebytes(b&#x27;eyJhbGciOiJIUzUxMiIsImlhdCI6MTYyMzMzODcwNiwiZXhwIjoxNjIzMzM4NzY2fQ==&#x27;)Out[2]: b&#x27;&#123;&quot;alg&quot;:&quot;HS512&quot;,&quot;iat&quot;:1623338706,&quot;exp&quot;:1623338766&#125;&#x27; In [3]: base64.decodebytes(b&#x27;eyJ1aWQiOjEsInVzZXJuYW1lIjoiYWRtaW4ifQ==&#x27;)Out[3]: b&#x27;&#123;&quot;uid&quot;:1,&quot;username&quot;:&quot;admin&quot;&#125;&#x27; Base64 对字符串进行base64 解码时，有时候会出现 Incorrect padding: 因为输入的base64编码字符串必须符合base64的padding规则： 当原数据长度不是3的整数倍时, 如果最后剩下两个输入数据，在编码结果后加1个“=”； 如果最后剩下一个输入数据，编码结果后加2个“=”； 如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。 因此，在对上面的 itsdangerous 生成的token进行base64 解码时，需要补上对应的 =","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"web","slug":"技术/python/web","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/web/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://www.bookandmusic.cn/tags/JWT/"},{"name":"JWS","slug":"JWS","permalink":"https://www.bookandmusic.cn/tags/JWS/"},{"name":"itsdangerous","slug":"itsdangerous","permalink":"https://www.bookandmusic.cn/tags/itsdangerous/"},{"name":"pyjwt","slug":"pyjwt","permalink":"https://www.bookandmusic.cn/tags/pyjwt/"}]},{"title":"Flask图片上传与展示","slug":"Flask图片上传与展示","date":"2021-06-08T16:00:28.000Z","updated":"2021-06-12T06:35:11.477Z","comments":true,"path":"2021/06/09/flask-tu-pian-shang-chuan-yu-zhan-shi/","link":"","permalink":"https://www.bookandmusic.cn/2021/06/09/flask-tu-pian-shang-chuan-yu-zhan-shi/","excerpt":"","text":"项目配置1234567891011121314import osclass Config(object): DEBUG = True SQLALCHEMY_DATABASE_URI = &#x27;mysql://root:mysql@127.0.0.1:3306/day08&#x27; SQLALCHEMY_TRACK_MODIFICATIONS = False # 构建项目所在的 绝对路径，也就是 day08 的绝对路径 BASE_DIR = os.path.abspath(os.path.dirname(os.path.dirname(__file__))) # 静态资源存放路径 STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static/&#x27;) # 自定义的 图片上传路径 MEDIA_ROOT = os.path.join(BASE_DIR, &#x27;media/&#x27;) 图片上传与展示static静态资源方式 采用此种方式： 创建APP时，一定要指明静态资源的路径 然后在上传图片时，将上传的图片存放到上一步指明的静态资源路径中 就可以使用static内置的服务，展示图片资源 app创建 创建app时,指明静态资源目录 1app = Flask(__name__, static_folder=Config.STATIC_ROOT, static_url_path=&#x27;/static&#x27;) static_folder： 静态资源路径 static_url_path： 静态资源展示的url前缀 图片上传1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import osfrom uuid import uuid4from flask_restful import Resource, reqparsefrom werkzeug.datastructures import FileStoragefrom app.config import Configfrom .models import *def img_upload(img): if not img: return None # 将图片名按照 . 进行切分， 找到最后一个元素，也就是 文件的后缀名 end_name = img.filename.rsplit(&#x27;.&#x27;)[-1] # 通过文件的后缀名判断 身份为 合法的 图片 if end_name not in [&#x27;jpg&#x27;, &#x27;png&#x27;, &#x27;gif&#x27;, &#x27;jpeg&#x27;]: return None filename = str(uuid4()) + &#x27;.&#x27; + end_name # 为了生成一个不重复的 文件名 img_path = os.path.join(Config.STATIC_ROOT, filename) # 将路径和文件名拼接在一起，方便保存文件 img.save(img_path) # 将图片对象保存到 本地 return filenameclass NewsView(Resource): def post(self): # 1. 创建解析参数的对象 parser = reqparse.RequestParser() # 2. 指明需要解析的参数 parser.add_argument(&#x27;title&#x27;, type=str, location=&#x27;form&#x27;, required=True) parser.add_argument(&#x27;img&#x27;, type=FileStorage, location=&#x27;files&#x27;) # 3. 获取具体的参数 args = parser.parse_args() title = args.get(&#x27;title&#x27;) img = args.get(&#x27;img&#x27;) # 利用自定义函数，将图片保存到本地 filename = img_upload(img) # 4. 创建对象, 注意：图片存储的只是 从media之后的 图片路径 news = News(title=title, img=filename) # 5. 添加到 事务中 db.session.add(news) # 6. 提交事务 try: db.session.commit() except: return &#123; &#x27;msg&#x27;: &#x27;添加失败&#x27; &#125;, 500 # 7. 返回响应 return &#123; &#x27;id&#x27;: news.id, &#x27;title&#x27;: news.title, &#x27;img&#x27;: news.img &#125;, 201 图片访问 通过 http://127.0.0.1:5000/static/filename就可以访问图片 static是app创建时，配置的url前缀 自定义方式 自定义方式实现： app创建时，不需要指明静态资源有关的任何参数 图片的存放路径，可以是 任何一个合适的路径 展示图片时，需要自己定义视图和路由，实现图片展示 图片上传 和上面的图片上传的流程一样，只是 图片存放的路径可以自由指定，不必一定存放到 某个特定路径 图片访问 图片访问时，可以自己读取文件内容，也可以调用flask内置的 方法，返回响应 1234567891011121314151617181920212223import osfrom flask import make_responsefrom app.config import Configclass ImgView(Resource): def get(self, filename): # 1. 拼接除图片的完成路径 img_path = os.path.join(Config.MEDIA_ROOT, filename) # 2. 按照二进制方式打开文件，读到的内容为 二进制文件流，方便接下来的网络传输 try: with open(img_path, &#x27;rb&#x27;) as f: img = f.read() except FileNotFoundError: return None, 404 # 3. 自定义响应 resp = make_response(img) # 4. 声明响应体的类型 为 图片 resp.headers[&#x27;Content-Type&#x27;] = &#x27;image/png&#x27; # 5. 返回响应 return resp 12345678910111213import osfrom flask import send_from_directoryfrom app.config import Configclass ImgView(Resource): def get(self, filename): # 1. 拼接除图片的完成路径 img_path = os.path.join(Config.MEDIA_ROOT, filename) # 2. 使用flask 内置的函数提供响应 return send_from_directory(MEDIA, filename) 通过 http://127.0.0.1:5000/media/filename就可以访问图片 media是自己配置的路由前缀","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Flask","slug":"技术/python/Flask","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Flask/"}],"tags":[{"name":"图片上传","slug":"图片上传","permalink":"https://www.bookandmusic.cn/tags/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"}]},{"title":"python自动化测试","slug":"python自动化测试","date":"2021-05-15T10:48:25.000Z","updated":"2021-06-12T06:39:55.059Z","comments":true,"path":"2021/05/15/python-zi-dong-hua-ce-shi/","link":"","permalink":"https://www.bookandmusic.cn/2021/05/15/python-zi-dong-hua-ce-shi/","excerpt":"","text":"写好了一个项目之后，要确定各个模块是不是稳定运行，有没有bug，比如一个项目有100个路由，可以手动一个一个URL的输入，查看响应有没有毛病，但这样不符合程序员的逼格。 由此，诞生了单元测试与集成测试。 python unittestunittest是python内置的用于测试代码的模块，无需安装， 使用简单方便。 unittest 简介 unittest中最核心的部分是：TestFixture、TestCase、TestSuite、TestRunner unittest case的运行流程： 写好一个完整的TestCase 多个TestCase 由TestLoder被加载到TestSuite里面, TestSuite也可以嵌套TestSuite 由TextTestRunner来执行TestSuite，测试的结果保存在TextTestResult中 TestFixture指的是环境准备和恢复 Test Fixture用于测试环境的准备和恢复还原, 一般用到下面几个函数。 setUp()：准备环境，执行每个测试用例的前置条件 tearDown()：环境还原，执行每个测试用例的后置条件 setUpClass()：必须使用@classmethod装饰器，所有case执行的前置条件，只运行一次 tearDownClass()：必须使用@classmethod装饰器，所有case运行完后只运行一次 Test Case 参数verbosity可以控制错误报告的详细程度：默认为1。 Verbosity=0，表示不输出每一个用例的执行结果； Verbosity=1情况下成功是 .，失败是 F，出错是 E，跳过是 S； Verbosity=2情况下会打印测试的注释,显示详细的执行报告结； 测试的执行跟方法的顺序没有关系, 默认按字母顺序 每个测试方法均以 test_ 开头 Test Suite 一般通过addTest()或者addTests()向suite中添加 case的执行顺序与添加到Suite中的顺序是一致的 使用装饰器的方式来实现跳过测试与预计的失败，常用的主要有3种: @unittest.skip()：直接跳过测试用例； @unittest.skipIf(condition,reason)：当满足条件时跳过测试用例； @unittest.skipUnless(condition,reason)：只有满足某一条件时不跳过，其他的都跳过； Test Loder TestLoadder用来加载TestCase到TestSuite中 loadTestsFrom*()方法从各个地方寻找testcase，创建实例，然后addTestSuite，再返回一个TestSuite实例 defaultTestLoader() 与 TestLoader()功能差不多，复用原有实例 12345unittest.TestLoader().loadTestsFromTestCase(testCaseClass)unittest.TestLoader().loadTestsFromModule(module)unittest.TestLoader().loadTestsFromName(name, module=None)unittest.TestLoader().loadTestsFromNames(names, module=None)unittest.TestLoader().discover() 测试用例 定义实现测试用例，然后调用即可 123456789101112131415161718192021222324252627282930313233343536import unittestimport requestsclass TestCaseDemo(unittest.TestCase): @classmethod def setUpClass(cls): print(&quot;this setupclass() method only called once.\\n&quot;) @classmethod def tearDownClass(cls): print(&quot;this tear_down_class() method only called once too.\\n&quot;) def setUp(self): print(&quot;do something before test : prepare environment.\\n&quot;) def tearDown(self): print(&quot;do something after test : clean up.\\n&quot;) def test_goods_list(self): r = requests.get(&#x27;http://127.0.0.1:8000/goods/&#x27;) # 断言 self.assertEqual(200, r.status_code, &#x27;查询商品失败&#x27;) result = r.json() self.assertEqual(list, type(result), &#x27;查询商品，结果不对&#x27;) def test_goods_create(self): r = requests.post(&#x27;http://127.0.0.1:8000/goods/&#x27;) # 断言 self.assertEqual(405, r.status_code, &#x27;不应该允许添加商品&#x27;)if __name__ == &#x27;__main__&#x27;: unittest.main(verbosity=2) 测试套件上述演示了一种比较基础、简单的测试用例的使用方法，但是这样比较固化，只能自动的去查找以test开头的测试方法，然后顺序的去执行测试方法，这样显然是有点僵化的，不能按照重要程度或者我们的意愿去执行测试方法，而且遇到多个测试用例是会比较混乱。这里要讲的测试套件能够归档测试用例，能够让我们按照指定的顺序去执行测试方法。 创建测试实例 创建测试套件 加载测试实例 添加测试实例到测试套件 创建测试运行组件，加载测试套件 运行测试套件 12345.└── testcase ├── __init__.py ├── test.py # 测试套件 └── test_demo_class.py # 测试实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import HTMLReportfrom unittest import TestLoader, TestSuite, TextTestRunnerimport test_demo_class # 导入测试模块from test_demo_class import TestCaseDemoif __name__ == &#x27;__main__&#x27;: # 2. 创建测试套件 suite = TestSuite() # 3.加载测试实例 # test1 = TestCaseDemo(&quot;test_goods_list&quot;) # test2 = TestCaseDemo(&#x27;test_goods_create&#x27;) tests = [ TestCaseDemo(&quot;test_goods_list&quot;), TestCaseDemo(&quot;test_goods_create&quot;) ] # tests = TestLoader().loadTestsFromModule(test_demo_class) # tests = TestLoader().loadTestsFromTestCase(TestCaseDemo) # tests = TestLoader().loadTestsFromName(&#x27;test_demo_class.TestCaseDemo.test_goods_list&#x27;) # tests = TestLoader().loadTestsFromNames([ # &#x27;test_demo_class.TestCaseDemo.test_goods_list&#x27;, # &#x27;test_demo_class.TestCaseDemo.test_goods_create&#x27; # ]) # tests = TestLoader().discover(&#x27;.&#x27;, &#x27;test_*.py&#x27;, top_level_dir=None) # 4. 添加测试实例到测试套件 # suite.addTest(test1) # suite.addTest(test2) suite.addTests(tests) # 5. 创建运行套件，并运行 runner = TextTestRunner(verbosity=2) # 输出到终端 # runner = HTMLReport.TestRunner(report_file_name=&#x27;test&#x27;, # output_path=&#x27;report&#x27;, # title=&#x27;测试报告&#x27;, # description=&#x27;测试描述&#x27;, # sequential_execution=True # ) # 输出到HTML网页 # runner.run(suite) # with open(&#x27;ut_log.txt&#x27;, &#x27;a&#x27;) as fp: # 输出到txt文件 # runner = TextTestRunner(stream=fp, verbosity=2) # runner.run(suite) django test数据库配置12345678910111213DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27; : &#x27;django.db.backends.mysql&#x27;, &#x27;HOST&#x27;: &#x27;localhost&#x27;, &#x27;PORT&#x27;: &#x27;3306&#x27;, &#x27;NAME&#x27;: &#x27;django_db1&#x27;, # 真实的数据库 &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;PASSWORD&#x27;: &#x27;123456&#x27;, &#x27;TEST&#x27;:&#123; &#x27;NAME&#x27;:&#x27;django_db_test&#x27; # 用于单元测试的数据库 &#125; &#125;&#125; 单元测试文件 在每个APP里面，都有一个test.py文件，可以在里面去定义测试类，并可以直接运行 1234567891011121314151617181920212223242526272829303132from django.test import TestCase, Clientfrom .models import Goods# Create your tests here.class GoodsTestCase(TestCase): def test_goods_list(self): # 创建一个客户端 client = Client() # 模拟客户端访问首页 response = client.get(&#x27;/goods/&#x27;) # 测试，self.assertEqual接收3个参数(被测试对象，正确的测试结果，如果不正确输出什么） # 如果第一个参数的返回值不等于第二个参数，输出第三个参数 self.assertEqual( response.status_code, 200, &#x27;商品查询失败&#x27; ) result = response.json() self.assertEqual( type(result), list, &#x27;商品查询结果不对&#x27; )if __name__ == &#x27;__main__&#x27;: userTestCase = GoodsTestCase() userTestCase.test_goods_list() mock在单元测试进行的同时，就离不开mock模块的存在，初次接触这个概念的时候会有这样的疑问：把要测的东西都模拟掉了还测试什么呢？但在，实际生产中的项目是非常复杂的，对其进行单元测试的时候，会遇到以下问题： 接口的依赖 外部接口调用 测试环境非常复杂 单元测试应该只针对当前单元进行测试, 所有的内部或外部的依赖应该是稳定的, 已经在别处进行测试过的。使用mock 就可以对外部依赖组件实现进行模拟并且替换掉, 从而使得单元测试将焦点只放在当前的单元功能。 因为在为代码进行单元测试的同时，会发现该模块依赖于其他的模块，例如数据库，网络，或者第三方模块的存在，而我们对一个模块进行单元测试的目的，是测试当前模块正常工作，这样就要避开对其他模块的依赖，而mock主要作用便在于，专注于待测试的代码。而在但与测试中，如何灵活的使用mock模块是核心所在。下面便以mock为核心，结合最近所写的代码，阐述mock模块的使用。 123456789101112131415import requestsfrom unittest import mockdef request_lemonfix(): &quot;&quot;&quot; :return: &quot;&quot;&quot; res = requests.get(&#x27;http://www.lemonfix.com&#x27;) return res.status_code.encode(&#x27;utf-8&#x27;)if __name__ == &#x27;__main__&#x27;: request_lemonfix = mock.Mock(return_value=&quot;这里会显示论坛主页&quot;) print(request_lemonfix())","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"模块","slug":"技术/python/模块","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E6%A8%A1%E5%9D%97/"}],"tags":[{"name":"unittest","slug":"unittest","permalink":"https://www.bookandmusic.cn/tags/unittest/"},{"name":"django test","slug":"django-test","permalink":"https://www.bookandmusic.cn/tags/django-test/"},{"name":"mock","slug":"mock","permalink":"https://www.bookandmusic.cn/tags/mock/"}]},{"title":"DRF-图片上传到七牛云","slug":"DRF-图片上传到七牛云","date":"2021-05-03T12:18:19.000Z","updated":"2021-05-03T13:30:50.021Z","comments":true,"path":"2021/05/03/drf-tu-pian-shang-chuan-dao-qi-niu-yun/","link":"","permalink":"https://www.bookandmusic.cn/2021/05/03/drf-tu-pian-shang-chuan-dao-qi-niu-yun/","excerpt":"","text":"流程分析在前后端分离开发中，当上传图片时，一般不会直接把图片等文件资源，直接传到django服务器, 而是使用云服务，此处以七牛云为例，简单演示图片上传的流程。 在Vue上传图片到七牛云时，需要验证身份，因此需要token，而token不建议在前端生成，因此，需要从django中请求token，可以参考七牛云官方文档： 生成上传token Vue获取到token之后，就可以使用post请求，发送图片文件到七牛云服务器 上传成功之后，返回的响应，包含 该文件的key，将 服务器的域名和key拼接，即可得到图片的真正地址 djangodjango中，需要实现两个任务： 生成token，方便Vue上传图片 接收Vue上传成功后的图片地址，保存到数据库 模型类1234567891011121314from django.db import modelsclass Brand(models.Model): name = models.CharField(max_length=10, verbose_name=&#x27;品牌名&#x27;) logo = models.URLField(verbose_name=&#x27;logo&#x27;) class Meta: db_table = &#x27;tb_brand&#x27; verbose_name = &#x27;品牌&#x27; verbose_name_plural = verbose_name def __str__(self): return self.name 序列化器1234567from rest_framework.serializers import ModelSerializerclass BrandSerializer(ModelSerializer): class Meta: model = Brand fields = &#x27;__all__&#x27; 视图 定义方法： 生成一个随机字符串key，代表图片文件名 根据key和其余参数，生成token 12345678910111213141516171819202122from qiniu import Authimport randomimport datetime# 需要填写你的 Access Key 和 Secret Keyaccess_key = &#x27;&#x27;secret_key = &#x27;&#x27;# 要上传的空间bucket_name = &#x27;&#x27;# 构建鉴权对象q = Auth(access_key, secret_key)def generate_token(): # 上传后保存的文件名 key = &#x27;%08d&#x27; % random.randint(0, 99999999) + datetime.datetime.now().strftime(&#x27;%Y%m%d%H%M%S&#x27;) # 生成上传 Token，可以指定过期时间等 # 3600为token过期时间，秒为单位。3600等于一小时 token = q.upload_token(bucket_name, key, 3600) return key, token 每次请求，返回key和token 123456789101112from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom utils.qiniuyun import generate_tokenclass QiniuTokenAPIView(APIView): def get(self, request): key, token = generate_token() return Response(&#123; &#x27;token&#x27;: token, &#x27;key&#x27;: key &#125;) 图片上传成功，实现数据入库 123456from rest_framework.generics import ListCreateAPIViewfrom .serializers import *class BrandListCreateAPIView(ListCreateAPIView): queryset = Brand.objects.all() serializer_class = BrandSerializer 路由12345678from django.urls import pathfrom .views import *urlpatterns = [ path(&#x27;qiniu/token/&#x27;, QiniuTokenAPIView.as_view()), path(&#x27;brand/&#x27;, BrandListCreateAPIView.as_view()),] Vue请求token1234567891011121314151617181920212223242526&lt;script&gt; export default &#123; data() &#123; return &#123; // 定义变量，接收token和key postData: &#123; token: &quot;&quot;, key: &quot;&quot; &#125; &#125; &#125;, methods: &#123; // 1. 定义方法，从django中请求token get_qiniu_token() &#123; this.$axios.get(&#x27;qiniu/token/&#x27;) .then(resp =&gt; &#123; this.postData = resp.data &#125;) &#125; &#125;, // 2. 挂载执行 created() &#123; this.get_qiniu_token(); &#125; &#125;&lt;/script&gt; 上传图片 参数 作用 action 七牛云服务器地址，参考 存储区域_产品简介_对象存储 - 七牛开发者中心 (qiniu.com) data 需要验证的参数，有两个：token、key limit 最多上传个数 file-list 上传成功展示的图片列表 http-request 覆盖默认的上传行为，可以自定义上传的实现, function(params) on-success 文件上传成功时的钩子, function(response, file, fileList) 默认方式 使用element-ui默认的图片上传方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div&gt; &lt;el-upload action=&quot;http://upload-z1.qiniup.com&quot; list-type=&quot;picture-card&quot; :data=&quot;postData&quot; :limit=&quot;1&quot; :on-success=&quot;handleAvatarSuccess&quot; :file-list=&quot;img&quot;&gt; &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; img: [], // 上传成功之后，展示的图片列表 // 上传图片的验证参数 postData: &#123; token: &quot;&quot;, key: &quot;&quot; &#125;, // 需要添加的数据 brand: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, logo: &#x27;&#x27; &#125; &#125; &#125;, methods: &#123; ... handleAvatarSuccess(response, file, fileList) &#123; this.img = fileList this.brand.logo = &#x27;http://qruzvm22h.hb-bkt.clouddn.com/&#x27; + response.key this.get_qiniu_token(); &#125;, ... &#125;&#125;&lt;/script&gt; 自定义提交方式 覆盖element-ui默认的上传方式，自定义方法实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div&gt; &lt;el-upload action=&quot;http://upload-z1.qiniup.com&quot; list-type=&quot;picture-card&quot; :data=&quot;postData&quot; :limit=&quot;1&quot; :http-request=&quot;imgUpload&quot; :file-list=&quot;img&quot;&gt; &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27; export default &#123; data() &#123; return &#123; img: [], // 上传成功之后，展示的图片列表 // 上传图片的验证参数 postData: &#123; token: &quot;&quot;, key: &quot;&quot; &#125;, // 需要添加的数据 brand: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, logo: &#x27;&#x27; &#125; &#125; &#125;, methods: &#123; ... imgUpload(params) &#123; // 第一步.将图片上传到服务器. var formdata = new FormData(); formdata.append(&#x27;file&#x27;, params.file); formdata.append(&#x27;key&#x27;, this.postData.key); formdata.append(&#x27;token&#x27;, this.postData.token); axios(&#123; url: &#x27;http://upload-z1.qiniup.com&#x27;, method: &#x27;post&#x27;, data: formdata, headers: &#123;&#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27;&#125;, &#125;).then((file) =&gt; &#123; // 第二步.将返回的响应中的key拼接为图片网址 var url = &#x27;http://qruzvm22h.hb-bkt.clouddn.com/&#x27; + file.data.key this.img = [&#123;&quot;url&quot;: url&#125;] this.brand.logo = url this.get_qiniu_token(); &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) &#125;, ... &#125;&#125;&lt;/script&gt; 自定义方法，使用axios提交表单数据 提交成功，将返回的key拼接为网址 添加品牌123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;template&gt;&lt;div &gt; &lt;el-form&gt; &lt;el-form-item label=&quot;品牌名称：&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input autocomplete=&quot;off&quot; style=&quot;width: 220px&quot; v-model=&quot;brand.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;品牌logo：&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-upload action=&quot;http://upload-z1.qiniup.com&quot; list-type=&quot;picture-card&quot; :http-request=&quot;imgUpload&quot; :data=&quot;postData&quot; :limit=&quot;1&quot; :file-list=&quot;img&quot;&gt; &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-button @click=&quot;restAddBrand&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addBrand&quot;&gt;确 定&lt;/el-button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; brand: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, logo: &#x27;&#x27; &#125;, img: [], postData: &#123; token: &quot;&quot;, key: &quot;&quot; &#125; &#125; &#125;, methods: &#123; // 重置表单数据 restAddBrand() &#123; this.brand.name = &#x27;&#x27; this.brand.id = &#x27;&#x27; this.brand.logo = &#x27;&#x27; this.img = [] &#125;, // 提交表单数据 addBrand() &#123; console.log(this.brand.logo) this.$axios.post(&#x27;brand/&#x27;, this.brand) .then(resp =&gt; &#123; console.log(resp.data) this.get_brand_list(); &#125;) .catch(err =&gt; &#123; console.log(err.response.data) &#125;) // 添加成功，同样重置表单 this.restAddBrand(); &#125;, &#125;,&#125;&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"DRF","slug":"技术/python/DRF","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/DRF/"}],"tags":[{"name":"element-ui","slug":"element-ui","permalink":"https://www.bookandmusic.cn/tags/element-ui/"},{"name":"axios","slug":"axios","permalink":"https://www.bookandmusic.cn/tags/axios/"}]},{"title":"Git命令","slug":"git命令","date":"2021-03-28T01:15:27.000Z","updated":"2021-03-28T14:48:53.865Z","comments":true,"path":"2021/03/28/git-ming-ling/","link":"","permalink":"https://www.bookandmusic.cn/2021/03/28/git-ming-ling/","excerpt":"","text":"创建仓库git initgit init 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。大多数Git命令在未初始化的仓库中都是无法使用的，所以这就是你运行新项目的第一个命令了。 运行 git init 命令会在你项目的根目录下创建一个新的 .git 目录，其中包含了你项目必需的所有元数据。除了 .git 目录之外，已经存在的项目不会被改变（Git 不强制每个子目录中都有一个 .git 目录）。 1git init 将当前的目录转换成一个 Git 仓库。它在当前的目录下增加了一个 .git 目录，于是就可以开始记录项目版本了。 1git init &lt;directory&gt; 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。 1git init --bare &lt;directory&gt; 初始化一个裸的 Git 仓库，但是忽略工作目录。共享的中心仓库应该总是用 --bare 标记创建。 一般来说，用 —-bare 标记初始化的仓库以 .git 结尾。比如，一个叫repo的仓库，它的空版本应该保存在 repo.git 目录下（这也是为什么我们从 GitHub clone 仓库的时候，地址都是 xxx.git 这样的形式的原因）。 并且这个仓库是可以被正常 clone 和 push 更新的， 裸仓库不包含工作区，所以并不会存在在裸仓库上直接提交变更的情况。 git clonegit clone 命令拷贝整个 Git 仓库。这个命令在本地创建一个完备的Git仓库——它包含自己的历史，管理自己的文件，以及环境和原仓库完全隔离。 为了方便起见，clone 自动创建了一个名为 origin 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。 1git clone &lt;repo&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。 1git clone &lt;repo&gt; &lt;directory&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器上的 &lt;directory&gt; 目录。 保存更改git addgit add 命令将工作目录中的变化添加到暂存区。它告诉 Git 你想要在下一次提交时包含这个文件的更新。但是，git add 不会实质上地影响你的仓库——在你运行 git commit 前更改都还没有真正被记录。 1git add &lt;file&gt; 将 &lt;file&gt; 中的更改加入下次提交的缓存。 1git add &lt;directory&gt; 将 &lt;directory&gt; 下的更改加入下次提交的缓存。 git commitgit commit命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 git add 一样，这是最重要的 Git 命令之一。 1git commit 提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。 1git commit -m &quot;&lt;message&gt;&quot; 提交已经缓存的快照。但将 &lt;message&gt; 作为提交信息，而不是运行文本编辑器。 查看查看状态git statusgit status 命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被 Git 追踪。status 的输出 不会 告诉你任何已提交到项目历史的信息。如果你想看的话，应该使用 git log 命令。 1git status git status 是一个相对简单的命令。 它告诉你 git add 和 git commit 的进展。status 信息还包括了添加缓存和移除缓存的相关指令。 忽略文件未追踪的文件通常有两类。它们要么是项目新增但还未提交的文件，要么是像 .pyc、.obj、.exe 等编译后的二进制文件。显然前者应该出现在 git status 的输出中，而后者会让我们困惑究竟发生了什么。 因此，Git 允许完全忽略这些文件，只需要将路径放在一个特定的 .gitignore 文件中。所有想要忽略的文件应该分别写在单独一行，* 字符用作通配符。比如，将下面这行加入项目根目录的.gitignore文件可以避免编译后的Python模块出现在git status中： 1*.pyc git loggit log 命令显示已提交的快照。你可以列出项目历史，筛选，以及搜索特定更改。git status 允许你查看工作目录和缓存区，而 git log 只作用于提交的项目历史。 log 输出可以有很多种自定义的方式，从简单地筛选提交，到用完全自定义的格式显示。其中一些最常用的 git log 配置如下所示。 1git log 使用默认格式显示完整地项目历史。如果输出超过一屏，你可以用 空格键 来滚动，按 q 退出。 1git log -n &lt;limit&gt; 用 &lt;limit&gt; 限制提交的数量。比如 git log -n 3 只会显示 3 个提交。 1git log --oneline 将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用。 1git log --stat 除了 git log 信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数。 1git log -p 显示代表每个提交的一堆信息。显示每个提交全部的差异（diff），这也是项目历史中最详细的视图。 回滚错误提交git revertgit revert 命令用来撤销一个已经提交的快照。但是，它是通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的 新 提交，而不是从项目历史中移除这个提交。这避免了Git丢失项目历史，这一点对于你的版本历史和协作的可靠性来说是很重要的。 1git revert &lt;commit&gt; 生成一个撤消了 &lt;commit&gt; 引入的修改的新提交，然后应用到当前分支。 git reset如果说 git revert 是一个撤销更改安全的方式，你可以将 git reset 看做一个 危险 的方式。当你用 git reset 来重设更改时(提交不再被任何引用或引用日志所引用)，我们无法获得原来的样子——这个撤销是永远的。使用这个工具的时候务必要小心，因为这是少数几个可能会造成工作丢失的命令之一。 和 git checkout 一样，git reset 有很多种用法。它可以被用来移除提交快照，尽管它通常被用来撤销缓存区和工作目录的修改。不管是哪种情况，它应该只被用于 本地 修改——你永远不应该重设和其他开发者共享的快照。 1git reset &lt;file&gt; 从缓存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不覆盖任何更改。 1git reset 重设缓冲区，匹配最近的一次提交，但工作目录不变。它会取消 所有 文件的缓存，而不会覆盖任何修改，给你了一个重设缓存快照的机会。 1git reset --hard 重设缓冲区和工作目录，匹配最近的一次提交。除了取消缓存之外，--hard 标记告诉 Git 还要重写所有工作目录中的更改。换句话说：它清除了所有未提交的更改，所以在使用前确定你想扔掉你所有本地的开发。 1git reset &lt;commit&gt; 将当前分支的末端移到 &lt;commit&gt;，将缓存区重设到这个提交，但不改变工作目录。所有 &lt;commit&gt; 之后的更改会保留在工作目录中，这允许你用更干净、原子性的快照重新提交项目历史。 1git reset --hard &lt;commit&gt; 将当前分支的末端移到 &lt;commit&gt;，将缓存区和工作目录都重设到这个提交。它不仅清除了未提交的更改，同时还清除了 &lt;commit&gt; 之后的所有提交。 revert VS reset 撤销和重设相比有两个重要的优点。首先，它不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。 其次，git revert 可以针对历史中任何一个提交，而 git reset只能从当前提交向前回溯。比如，你想用 git reset 重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。不用说，这并不是一个优雅的回滚方案。 git cleangit clean 命令将未跟踪的文件从你的工作目录中移除。它只是提供了一条捷径，因为用 git status 查看哪些文件还未跟踪然后手动移除它们也很方便。和一般的 rm 命令一样，git clean 是无法撤消的，所以在删除未跟踪的文件之前想清楚，你是否真的要这么做。 git clean 命令经常和 git reset --hard 一起使用。记住，reset 只影响被跟踪的文件，所以还需要一个单独的命令来清理未被跟踪的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。 1git clean -n 执行一次git clean的『演习』。它会告诉你那些文件在命令执行后会被移除，而不是真的删除它。 1git clean -f 移除当前目录下未被跟踪的文件。-f（强制）标记是必需的，它 不会 删除 .gitignore 中指定的未跟踪的文件。 1git clean -f &lt;path&gt; 移除未跟踪的文件，但限制在某个路径下。 1git clean -df 移除未跟踪的文件，以及目录。 1git clean -xf 移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件。 代码同步Git 给予每个开发者一份自己的仓库拷贝，拥有自己完整的本地历史和分支结构。用户通常共享一系列的提交而不是单个变更集合。Git 允许你在仓库间共享整个分支，而不是从工作副本提交一个差异集合到中央仓库。 下面的命令让你管理仓库之间的连接，将分支「推送」到其他仓库来发布本地历史，或是将分支「拉取」到本地仓库来查看其它开发者的贡献。 git remotegit remote 命令允许你创建、查看和删除和其它仓库之间的连接。远程连接更像是书签，而不是直接跳转到其他仓库的链接。它用方便记住的别名引用不那么方便记住的 URL，而不是提供其他仓库的实时连接。 例如，下图显示了你的仓库和中央仓库以及另一个开发者仓库之间的远程连接。你可以向 Git 命令传递 origin 和 john 的别名来引用这些仓库，替代完整的 URL。 1git remote 列出你和其他仓库之间的远程连接。 1git remote -v 和上个命令相同，但同时显示每个连接的 URL。 1git remote add &lt;name&gt; &lt;url&gt; 创建一个新的远程仓库连接。在添加之后，你可以将 &lt;name&gt;作为 &lt;url&gt; 便捷的别名在其他 Git 命令中使用。 1git remote rm &lt;name&gt; 移除名为的远程仓库的连接。 1git remote rename &lt;old-name&gt; &lt;new-name&gt; 将远程连接从 &lt;old-name&gt; 重命名为 &lt;new-name&gt;。 名为 origin 的远程连接当你用 git clone 克隆仓库时，它自动创建了一个名为 origin 的远程连接，指向被克隆的仓库。当开发者创建中央仓库的本地副本时非常有用，因为它提供了拉取上游更改和发布本地提交的快捷方式。这也是为什么大多数基于 Git 的项目将它们的中央仓库取名为 origin。 仓库的 URLGit 支持多种方式来引用一个远程仓库。其中两种最简单的方式便是 HTTP 和 SSH 协议。HTTP 是允许匿名、只读访问仓库的简易方式。比如： 1http://host/path/to/repo.git 但是，直接将提交推送到一个 HTTP 地址一般是不可行的（你不太可能希望匿名用户也能随意推送）。如果希望对仓库进行读写，你需要使用 SSH 协议： 1ssh://user@host/path/to/repo.git 你需要在托管的服务器上有一个有效的 SSH 账户，但不用麻烦了，Git 支持开箱即用的 SSH 认证连接。 git fetchgit fetch 命令将提交从远程仓库导入到你的本地仓库。拉取下来的提交储存为远程分支，而不是我们一直使用的普通的本地分支。你因此可以在整合进你的项目副本之前查看更改。 1git fetch &lt;remote&gt; 拉取仓库中所有的分支。同时会从另一个仓库中下载所有需要的提交和文件。 1git fetch &lt;remote&gt; &lt;branch&gt; 和上一个命令相同，但只拉取指定的分支。 当你希望查看其他人的工作进展时，你需要 fetch。fetch 下来的内容表示为一个远程分支，因此不会影响你的本地开发。这是一个安全的方式，在整合进你的本地仓库之前，检查那些提交。你可以看到中央仓库的历史进展如何，但它不会强制你将这些进展合并入你的仓库。 git pull在基于 Git 的协作工作流中，将上游更改合并到你的本地仓库是一个常见的工作。我们已经知道应该使用 git fetch，然后是 git merge，但是 git pull 将这两个命令合二为一。 1git pull &lt;remote&gt; 拉取当前分支对应的远程副本中的更改，并立即并入本地副本。效果和 git fetch 后接 git merge origin/. 一致。 1git pull --rebase &lt;remote&gt; 和上一个命令相同，但使用 git rebase 合并远程分支和本地分支，而不是使用 git merge。 下图揭示了 pull 过程中的每一步。 你认为你的仓库已经同步了，但 git fetch 发现 origin 中 master 的版本在上次检查后已经有了新进展。 接着 git merge 立即将 remote master 并入本地的分支。 git pushPush 是你将本地仓库中的提交转移到远程仓库中时要做的事。它和 git fetch 正好相反，fetch 将提交导入到本地分支，而 push 将提交导出到远程分支。它可以覆盖已有的更改，所以你需要小心使用。这些情况请见下面的讨论。 1git push &lt;remote&gt; &lt;branch&gt; 将指定的分支推送到 &lt;remote&gt; 上，包括所有需要的提交和提交对象。它会在目标仓库中创建一个本地分支。为了防止你覆盖已有的提交，如果会导致目标仓库非快速向前合并时，Git 不允许你 push。 1git push &lt;remote&gt; --force 和上一个命令相同，但即使会导致非快速向前合并也强制推送。除非你确定你所做的事，否则不要使用 --force 标记。 1git push &lt;remote&gt; --all 将所有本地分支推送到指定的远程仓库 1git push &lt;remote&gt; --tags 当你推送一个分支或是使用 --all 选项时，标签不会被自动推送上去。--tags 将你所有的本地标签推送到远程仓库中去。 上图显示了当你本地的 master 分支进展超过了中央仓库的 master 分支，当你运行 git push origin master 发布更改时发生的事情。注意，git push 和在远程仓库内部运行 git merge master 事实上是一样的。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"工具/Git","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.bookandmusic.cn/tags/Git/"}]},{"title":"SSH安装与配置","slug":"ssh安装与配置","date":"2021-03-06T01:56:09.000Z","updated":"2021-03-06T07:20:52.025Z","comments":true,"path":"2021/03/06/ssh-an-zhuang-yu-pei-zhi/","link":"","permalink":"https://www.bookandmusic.cn/2021/03/06/ssh-an-zhuang-yu-pei-zhi/","excerpt":"","text":"ssh服务器安装ssh-server1$ sudo apt-get install openssh-server vim -y 设置密码由于SSH使用的就是账号的登录密码，所以不存在单独的SSH密码。如果你需要修改SSH远程登录密码，需要修改这台服务器的账号的登录密码。 1$ passwd 修改配置文件配置ssh客户端1$ vi /etc/ssh/ssh_config 去掉PasswordAuthentication yes前面的#号，保存退出 123456789Host *# ForwardAgent no# ForwardX11 no# ForwardX11Trusted yesPasswordAuthentication yes # 找不到，在命令行模式下，/模板字符串 搜索即可# HostbasedAuthentication no# GSSAPIAuthentication no# GSSAPIDelegateCredentials no# GSSAPIKeyExchange no 配置ssh服务器1$ vi /etc/ssh/sshd_config 把PermitRootLogin prohibit-password改成PermitRootLogin yes，保存退出 123456#LoginGraceTime 2m#PermitRootLogin prohibit-passwordPermitRootLogin yes#StrictModes yes#MaxAuthTries 6#MaxSessions 10 重启服务1/etc/init.d/ssh restart 查看服务是否开启 1$ ps -e | grep ssh ssh客户端安装ssh-client1$ sudo apt install ssh 登录服务器密码登录1ssh -p 22 root@192.168.1.9 密钥登录制作密钥对首先在客户端执行如下命令, 制作密钥对。 12345678910111213141516[root@host ~]$ ssh-keygen # &lt;== 建立密钥对Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): # &lt;== 按 EnterCreated directory &#x27;/root/.ssh&#x27;.Enter passphrase (empty for no passphrase): # &lt;== 输入密钥锁码，或直接按 Enter 留空Enter same passphrase again: # &lt;== 再输入一遍密钥锁码Your identification has been saved in /root/.ssh/id_rsa. # &lt;== 私钥Your public key has been saved in /root/.ssh/id_rsa.pub. # &lt;== 公钥The key fingerprint is:0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host# 密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。# 现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。 上传公钥到服务器方法一(推荐)直接将公钥内容添加到服务器的 授权密钥文件~/.ssh/authorized_keys中 1$ ssh-copy-id -p 22 -i ~/.ssh/id_rsa.pub root@192.168.1.9 执行命令了会要求输入远程机器的密码，输入密码即可。 注：ssh-copy-id默认端口是22，如果您的SSH端口不是22，也就是远程服务器端口修改成其他的了，那就要得加上 -p +端口。 方法二先在客户端使用scp命令将公钥文件上传至服务器 1$ scp ~/.ssh/id_rsa.pub root@192.168.1.9:~/.ssh/ 使用密码登录服务器 1$ ssh -p 22 root@192.168.1.9 在服务器将公钥文件添加到授权密钥文件~/.ssh/authorized_keys中 1$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 登录服务器1$ ssh root@192.168.1.9","categories":[],"tags":[]},{"title":"haystack+Elasticsearch实现搜索引擎","slug":"DRF-haystack+Elasticsearch实现搜索引擎","date":"2021-03-02T12:24:18.000Z","updated":"2021-03-07T07:56:16.988Z","comments":true,"path":"2021/03/02/drf-haystack-elasticsearch-shi-xian-sou-suo-yin-qing/","link":"","permalink":"https://www.bookandmusic.cn/2021/03/02/drf-haystack-elasticsearch-shi-xian-sou-suo-yin-qing/","excerpt":"","text":"搜索引擎原理通过搜索引擎进行数据查询时，搜索引擎并不是直接在数据库中进行查询，而是搜索引擎会对数据库中的数据进行一遍预处理，单独建立起一份索引结构数据。 我们可以将索引结构数据想象成是字典书籍的索引检索页，里面包含了关键词与词条的对应关系，并记录词条的位置。 我们在通过搜索引擎搜索时，搜索引擎将关键字在索引数据中进行快速对比查找，进而找到数据的真实存储位置。 Elasticsearch开源的 Elasticsearch 是目前全文搜索引擎的首选。 它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。 Elasticsearch 的底层是开源库 Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。 Elasticsearch 是用Java实现的。 搜索引擎在对数据构建索引时，需要进行分词处理。分词是指将一句话拆解成多个单字或词，这些字或词便是这句话的关键词。如: 我在广州 我、在、广、州、广州 等都可以是这句话的关键词。 Elasticsearch 不支持对中文进行分词建立索引，需要配合扩展elasticsearch-analysis-ik来实现中文分词处理。 Docker安装Elasticsearch及其扩展 注意： haystack 支持 Elasticsearch 1.x、2.x、5.x，所以不能安装Elasticsearch7.x 创建文件夹 elasticsearch下载中文分词插件 elasticsearch-analysis-ik-5.6.16.zip， 注意：插件需要和elasticsearch版本对应 解压到当前文件夹，并将文件夹重命名为elasticsearch-analysis-ik 创建 DockerFile12FROM elasticsearch:5.6.16ADD elasticsearch-analysis-ik /usr/share/elasticsearch/plugins/elasticsearch-analysis-ik 创建镜像1docker build -f Dockerfile -t bookandmusic/elasticsearch-ik:5.6.16 . 查看镜像1docker images 创建容器12345678docker run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; --name elasticsearch -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; -d bookandmusic/elasticsearch-ik:5.6.16# docker run --name elasticsearch 创建一个es容器并起一个名字；# -p 9200:9200 将主机的9200端口映射到docker容器的9200端口，用来给es发送http请求# -p 9300:9300 9300是es在分布式集群状态下节点之间的通信端口 \\ 换行符# -e 指定一个参数，当前es以单节点模式运行# *注意，ES_JAVA_OPTS非常重要，指定开发时es运行时的最小和最大内存占用为64M和512M，否则就会占用全部可用内存# -d 后台启动服务 注意： 创建容器时，一定要指定内存，否则，则直接闪退 使用postman测试IK分词IK分词效果有两种,一种是ik_max_word（最大分词）和ik_smart（最小分词） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;今天是&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;今天&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;是&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;个&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;好日子&quot;, &quot;start_offset&quot;: 4, &quot;end_offset&quot;: 7, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 4 &#125;, &#123; &quot;token&quot;: &quot;日子&quot;, &quot;start_offset&quot;: 5, &quot;end_offset&quot;: 7, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 5 &#125; ]&#125; 12345678910111213141516171819202122232425&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;今天是&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;个&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;好日子&quot;, &quot;start_offset&quot;: 4, &quot;end_offset&quot;: 7, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125; ]&#125; 使用haystack对接ElasticsearchHaystack为Django提供了模块化的搜索。它的特点是统一的，熟悉的API，可以让你在不修改代码的情况下使用不同的搜索后端（比如 Solr, Elasticsearch, Whoosh, Xapian 等等）。 我们在django中可以通过使用haystack来调用Elasticsearch搜索引擎。 安装依赖包123pip install django-haystackpip install drf-haystack pip install &quot;elasticsearch&gt;=5,&lt;6&quot; drf-haystack是为了在REST framework中使用haystack而进行的封装（如果在Django中使用haystack，则安装django-haystack即可）。 注册应用12345INSTALLED_APPS = [ ... &#x27;haystack&#x27;, ...] 配置在配置文件 settings.py 中配置haystack使用的搜索引擎后端 123456789101112131415# 全文搜索引擎haystack 配置# 不同的搜索引擎，配置不同，详情见官方文档HAYSTACK_CONNECTIONS = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;haystack.backends.elasticsearch5_backend.Elasticsearch5SearchEngine&#x27;, &#x27;URL&#x27;: &#x27;http://127.0.0.1:9200/&#x27;, # 此处为elasticsearch运行的服务器ip地址和端口 &#x27;INDEX_NAME&#x27;: &#x27;meiduo&#x27;, # 指定elasticserach建立的索引库名称 &#125;,&#125;# 搜索结果每页显示数量# HAYSTACK_SEARCH_RESULTS_PER_PAGE = 5# 当添加、修改、删除数据时,实时更新indexHAYSTACK_SIGNAL_PROCESSOR = &#x27;haystack.signals.RealtimeSignalProcessor&#x27; 数据模型类假设有一个商品模型类SKU 123456789101112131415161718192021from django.db import modelsclass SKU(models.Model): &quot;&quot;&quot;商品SKU&quot;&quot;&quot; name = models.CharField(max_length=50, verbose_name=&#x27;名称&#x27;) caption = models.CharField(max_length=100, verbose_name=&#x27;副标题&#x27;) # 当前SKU商品从属的分类 # 隐藏字段category_id是关联的分类的主键id category = models.ForeignKey(GoodsCategory, related_name=&#x27;sku&#x27;, on_delete=models.PROTECT, verbose_name=&#x27;从属类别&#x27;) price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=&#x27;单价&#x27;) stock = models.IntegerField(default=0, verbose_name=&#x27;库存&#x27;) sales = models.IntegerField(default=0, verbose_name=&#x27;销量&#x27;) comments = models.IntegerField(default=0, verbose_name=&#x27;评价数&#x27;) is_launched = models.BooleanField(default=True, verbose_name=&#x27;是否上架销售&#x27;) class Meta: db_table = &#x27;tb_sku&#x27; def __str__(self): return &#x27;%s: %s&#x27; % (self.id, self.name) 索引类通过创建索引类，来指明让搜索引擎对哪些字段建立索引，也就是可以通过哪些字段的关键字来检索数据。 在应用中新建search_indexes.py文件，用于存放索引类 123456789101112131415161718192021from haystack import indexesfrom .models import SKUclass SKUIndex(indexes.SearchIndex, indexes.Indexable): &quot;&quot;&quot;SKU索引数据模型类&quot;&quot;&quot; text = indexes.CharField(document=True, use_template=False) name = indexes.CharField(model_attr=&#x27;name&#x27;) caption = indexes.CharField(model_attr=&#x27;caption&#x27;) category = indexes.CharField(model_attr=&#x27;category&#x27;) def get_model(self): &quot;&quot;&quot;返回建立索引的模型类&quot;&quot;&quot; return SKU def index_queryset(self, using=None): &quot;&quot;&quot;返回要建立索引的数据查询集&quot;&quot;&quot; return self.get_model().objects.filter(is_launched=True) 序列化器SkuSerializer12345678from rest_framework import serializersclass SkuSerializer(ModelSerializer): category = StringRelatedField(read_only=True) class Meta: model = SKU fields = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;caption&#x27;, &#x27;price&#x27;, &#x27;stock&#x27;, &#x27;comments&#x27;, &#x27;category&#x27;, &#x27;default_image&#x27;] HaystackSerializerHaystackSerializer:根据SearchQueryset中可用的模型填充字段,进行序列化解析;此时，API返回的数据仅包含 Elasticsearch检索出匹配关键词的搜索结果。 12345678910from drf_haystack.serializers import HaystackSerializerfrom goods.search_indexes import SKUIndexclass SKUHaystackSerializer(HaystackSerializer): class Meta: &quot;&quot;&quot; SKU索引结果数据序列化器 &quot;&quot;&quot; index_classes = [SKUIndex] fields = (&#x27;text&#x27;, &#x27;name&#x27;, &#x27;caption&#x27;, &#x27;category&#x27;) 但是Haystack通过Elasticsearch检索出匹配关键词的搜索结果后，还会在数据库中取出完整的数据库模型类对象，放到搜索结果的object属性中，并将结果通过SKUIndexSerializer序列化器进行序列化。所以我们可以通过声明搜索结果的object字段以SkuSerializer序列化的形式进行处理，明确要返回的搜索结果中每个数据对象包含哪些字段。 12345678910111213from drf_haystack.serializers import HaystackSerializerfrom goods.search_indexes import SKUIndexclass SKUHaystackSerializer(HaystackSerializer): object = SkuSerializer(read_only=True) class Meta: &quot;&quot;&quot; SKU索引结果数据序列化器: &quot;&quot;&quot; index_classes = [SKUIndex] fields = (&#x27;text&#x27;, &#x27;object&#x27;) HaystackSerializerMixinHaystackSerializerMixin：可以将此mixin混入类添加到序列化器中，以将实际对象用作序列化的数据源，而不是使用存储在搜索索引字段中的数据。 123456from drf_haystack.serializers import HaystackSerializerMixinclass SKUHaystackSerializer(HaystackSerializerMixin, SkuSerializer): class Meta(SkuSerializer.Meta): search_fields = [&quot;text&quot;] 视图12345678910class Page(PageNumberPagination): page_size = 10 page_size_query_param = &#x27;size&#x27; page_query_param = &#x27;page&#x27;class SKUSearchView(HaystackViewSet): index_models = [SKU] serializer_class = SKUHaystackSerializer pagination_class = Page 路由12345678910from django.urls import path, includefrom rest_framework import routersfrom goods.views import *router = routers.DefaultRouter()router.register(r&quot;search&quot;, SKUSearchView, basename=&quot;search&quot;)urlpatterns = [ path(&#x27;&#x27;, include(router.urls))]","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"DRF","slug":"技术/python/DRF","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/DRF/"}],"tags":[{"name":"haystack","slug":"haystack","permalink":"https://www.bookandmusic.cn/tags/haystack/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://www.bookandmusic.cn/tags/Elasticsearch/"},{"name":"DRF","slug":"DRF","permalink":"https://www.bookandmusic.cn/tags/DRF/"}]},{"title":"Celery异步任务","slug":"Django-Celery异步任务","date":"2021-02-28T13:39:31.000Z","updated":"2021-06-12T06:33:25.930Z","comments":true,"path":"2021/02/28/django-celery-yi-bu-ren-wu/","link":"","permalink":"https://www.bookandmusic.cn/2021/02/28/django-celery-yi-bu-ren-wu/","excerpt":"","text":"情景： 用户发起request，并等待response返回。在本些views中，可能需要执行一段耗时的程序，那么用户就会等待很长时间，造成不好的用户体验，比如发送邮件、手机验证码等。 使用celery后，情况就不一样了。 解决： 将耗时的程序放到celery中执行。 Celery 是一个包含一系列的消息任务队列。您可以不用了解内部的原理直接使用，它的使用时非常简单的。 选择并且安装一个消息中间件（Broker） 安装 Celery 并且创建第一个任务 运行职程（Worker）以及调用任务 跟踪任务的情况以及返回值 celery官方网站: http://www.celeryproject.org/ celery中文文档: https://www.celerycn.io/ Celery名词： 任务task：就是一个Python函数。 队列queue：将需要执行的任务加入到队列中。 工人worker：在一个新进程中，负责执行队列中的任务。 代理人broker：负责调度，在布置环境中使用redis。 选择中间人（Broker）Celery 需要一个中间件来进行接收和发送消息，通常以独立的服务形式出现，成为 消息中间人（Broker） 以下有几种选择： RabbitMQ：RabbitMQ 的功能比较齐全、稳定、便于安装。在生产环境来说是首选的。 Redis: Redis 功能比较全，但是如果突然停止运行或断电会造成数据丢失。 安装 Celery可以用标准的 Python 工具，诸如 pip 或 easy_install 来安装： 1$ pip install celery Celery单应用创建Celery实例对象及task任务创建第一个 Celery 实例程序，我们把创建 Celery 程序成为 Celery 应用或直接简称 为 app，创建的第一个实例程序可能需要包含 Celery 中执行操作的所有入口点，例如创建任务、管理职程（Worker）等，所以必须要导入 Celery 模块。 在本教程中将所有的内容，保存为一个 app 文件中。针对大型的项目，可能需要创建 独立的模块。 首先创建 utils/tasks.py： 123456789101112131415161718192021222324252627282930313233import osimport sysimport djangofrom celery import Celeryfrom django.conf import settingsfrom django.core.mail import send_mailfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializerproject_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # 确定项目路径sys.path.append(project_path) # 将项目路径添加到系统搜索路径中os.environ[&#x27;DJANGO_SETTINGS_MODULE&#x27;] = &#x27;django_test.settings&#x27; # 设置项目的配置文件django.setup() # Django初始化app = Celery(&#x27;tasks&#x27;, broker=&#x27;amqp://guest@localhost//&#x27;)@app.taskdef task_send_email(user_id, username, email): # 加密用户信息，生成token info = &#123;&#x27;confirm&#x27;: user_id&#125; serializer = Serializer(settings.SECRET_KEY, 3600) token = serializer.dumps(info).decode() # 发送邮件 &#x27;&#x27;&#x27;发送重置密码邮件&#x27;&#x27;&#x27; reset_url = &quot;&#123;&#125;/user/reset/password/?token=&#123;&#125;&quot;.format(settings.HOST_URL, token) subject = &quot;重置密码&quot; message = &#x27;邮件正文&#x27; sender = settings.DEFAULT_FROM_EMAIL receiver = [email] html_message = &#x27;&lt;h1&gt;&#123;&#125;, 您好！&lt;/h1&gt;请在1小时内点击下面链接重置密码:&lt;br/&gt;&lt;a href=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&#x27;.format(username, reset_url, reset_url) send_mail(subject, message, sender, receiver, html_message=html_message) 第一个参数为当前模块的名称，只有在 __main__ 模块中定义任务时才会生产名称。 第二个参数为中间人（Broker）的链接 URL ，实例中使用的 RabbitMQ（Celery默认使用的也是RabbitMQ）。 更多相关的 Celery 中间人（Broker）的选择方案，可查阅上面的中间人（Broker）。 例如，对于 RabbitMQ 可以写为 amqp://localhost ，使用 Redis 可以写为 redis://localhost。 创建了一个名称为 task_send_email 的任务，实现邮件的发送。 注意： 在 单文件中，想要导入 Django项目的settings.py配置文件 先确定Django项目所在的绝对路径 追加Django所在的路径到系统搜索路径 配置系统的Django环境变量 运行 Celery 子进程（Worker）服务现在可以使用 worker 参数进行执行我们刚刚创建职程（Worker）： 注意： 此时运行celery，是在Django项目下根目录中,此时启动文件路径必须和 调用 异步任务的导包路径一致，否则，不识别，-A celery实例名，即为当前文件的名 1$ celery -A utils.task worker --loglevel=info Celery集成django使用注意: 以前版本的Celery需要一个单独的库才能与Django一起使用，但是从3.1开始，情况不再如此。现在就已支持Django。 注意: Celery 4.0支持Django 1.8和更高版本。对于Django 1.8之前的版本，请使用Celery 3.1。 创建Celery实例对象要将Celery与Django项目一起使用，必须首先定义Celery库的实例(称为 “app”) 如果您拥有当前主流的Django项目结构，例如： 123456- django_test/ - manage.py - django_test/ - __init__.py - settings.py - urls.py 那么建议的方法是创建一个新的django_test/django_test/celery.py模块，该模块定义Celery实例 file: django_test/django_test/celery.py 12345678910111213141516171819202122232425262728from __future__ import absolute_import, unicode_literalsimport osfrom celery import Celery# set the default Django settings module for the &#x27;celery&#x27; program.os.environ.setdefault(&#x27;DJANGO_SETTINGS_MODULE&#x27;, &#x27;django_test.settings&#x27;)app = Celery(&#x27;django_test&#x27;)# Using a string here means the worker doesn&#x27;t have to serialize# the configuration object to child processes.# - namespace=&#x27;CELERY&#x27; means all celery-related configuration keys# should have a `CELERY_` prefix.app.config_from_object(&#x27;django.conf:settings&#x27;, namespace=&#x27;CELERY&#x27;)# Load task modules from all registered Django app configs.app.autodiscover_tasks()@app.task(bind=True)def debug_task(self): print(&#x27;Request: &#123;0!r&#125;&#x27;.format(self.request)) Django加载Celery然后，需要将此程序导入到django_test/django_test/__ init__.py模块中。这样可以确保在Django启动时加载应用程序，以便@shared_task装饰器将使用该应用程序： file:django_test/django_test/__init__.py: 123456789from __future__ import absolute_import, unicode_literals# This will make sure the app is always imported when# Django starts so that shared_task will use this app.from .celery import app as celery_app__all__ = (&#x27;celery_app&#x27;,) 请注意，此示例项目结构适用于较大的项目，对于简单项目，可以使用一个包含的模块来定义应用程序和任务。 步骤解析让我们分解一下第一个模块中发生的情况，首先我们从__freture__导入absolute_import导入unicode_literals，以使我们的celery.py模块不会与库冲突： 1from __future__ import absolute_import 然后，为celery命令行程序设置默认的DJANGO_SETTINGS_MODULE环境变量： 1os.environ.setdefault(&#x27;DJANGO_SETTINGS_MODULE&#x27;, &#x27;django_test.settings&#x27;) 不需要此行，但可以避免始终将设置模块传递到celery程序中。它必须始终在创建应用程序实例之前出现，我们接下来要做的是： 1app = Celery(&#x27;django_test&#x27;) 这是我们的库实例，可以有很多实例，但是使用Django时可能没有理由。 我们还将Django设置模块添加为Celery的配置源。这意味着不必使用多个配置文件，而直接从Django设置中配置Celery；但也可以根据需要将它们分开。 1app.config_from_object(&#x27;django.conf:settings&#x27;, namespace=&#x27;CELERY&#x27;) 大写名称空间意味着所有Celery配置选项必须以大写而不是小写指定，并以CELERY_开头，因此例如task_always_eager设置变为CELERY_TASK_ALWAYS_EAGER，broker_url设置变为CELERY_BROKER_URL。 可以直接传递设置对象，但是使用字符串更好，因为这样一来，工作人员就不必序列化该对象。 CELERY_名称空间也是可选的，但建议使用（以防止与其他Django设置重叠）。 接下来，可重用应用程序的常见做法是在单独的task.py模块中定义所有任务，而Celery可以自动发现这些模块： 1app.autodiscover_tasks() 在上述行中，Celery将按照task.py约定自动发现所有已安装应用程序中的任务： 123456- app1/ - tasks.py - models.py- app2/ - tasks.py - models.py 这样，不必手动将各个模块添加到CELERY_IMPORTS设置中。 最后，debug_task示例是一个转储其自己的请求信息的任务。这是使用Celery 3.1中引入的新的bind = True任务选项来轻松引用当前任务实例。 使用@shared_task装饰器编写的任务可能会存在于可重用应用程序中，并且可重用应用程序不能依赖于项目本身，因此不能直接导入应用程序实例。 @shared_task装饰器可让您创建任务而无需任何具体的应用程序实例： file: user/tasks.py: 12345678910111213141516171819202122232425# Create your tasks herefrom __future__ import absolute_import, unicode_literalsfrom celery import shared_taskfrom django.conf import settingsfrom django.core.mail import send_mailfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializer@shared_taskdef task_send_email(user_id, username, email): # 加密用户信息，生成token info = &#123;&#x27;confirm&#x27;: user_id&#125; serializer = Serializer(settings.SECRET_KEY, 3600) token = serializer.dumps(info).decode() # 发送邮件 &#x27;&#x27;&#x27;发送重置密码邮件&#x27;&#x27;&#x27; reset_url = &quot;&#123;&#125;/user/reset/password/?token=&#123;&#125;&quot;.format(settings.HOST_URL, token) subject = &quot;重置密码&quot; message = &#x27;邮件正文&#x27; sender = settings.DEFAULT_FROM_EMAIL receiver = [email] html_message = &#x27;&lt;h1&gt;&#123;&#125;, 您好！&lt;/h1&gt;请在1小时内点击下面链接重置密码:&lt;br/&gt;&lt;a href=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&#x27;.format(username, reset_url,reset_url) send_mail(subject, message, sender, receiver, html_message=html_message) 运行 Celery 子进程（Worker）服务现在可以使用 worker 参数进行执行我们刚刚创建职程（Worker）： 注意： 此时运行celery，是在Django项目下，-A celery实例名，即为Django项目的同名目录 1$ celery -A django_test worker --loglevel=info 调用任务需要调用我们创建的实例任务，可以通过 delay() 进行调用。 delay() 是 apply_async() 的快捷方法，可以更好的控制任务的执行（详情：调用任务：Calling Tasks）： 1234567891011121314151617from django.contrib.auth import authenticatefrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.permissions import IsAuthenticatedfrom user.tools.auth import JSONWebTokenAuthentication # 自定义token认证类# from .task import task_send_email # 导入Django集成的task任务from utils.task import task_send_email # 导入 celery单应用的task任务class ResetPassword(APIView): authentication_classes = [JSONWebTokenAuthentication] permission_classes = [IsAuthenticated] def post(self, request): user = request.user task_send_email.delay(user_id=user.id, username=user.username, email=user.email) return Response(&#x27;发送成功&#x27;) 该任务已经有职程（Worker）开始处理，可以通过控制台输出的日志进行查看执行情况。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"Celery","slug":"Celery","permalink":"https://www.bookandmusic.cn/tags/Celery/"},{"name":"单文件导入配置项","slug":"单文件导入配置项","permalink":"https://www.bookandmusic.cn/tags/%E5%8D%95%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E9%85%8D%E7%BD%AE%E9%A1%B9/"},{"name":"异步操作","slug":"异步操作","permalink":"https://www.bookandmusic.cn/tags/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"}]},{"title":"Django基础(六)-ORM操作","slug":"Django-6-ORM操作","date":"2021-01-23T14:37:39.000Z","updated":"2021-05-13T06:05:24.688Z","comments":true,"path":"2021/01/23/django-6-orm-cao-zuo/","link":"","permalink":"https://www.bookandmusic.cn/2021/01/23/django-6-orm-cao-zuo/","excerpt":"","text":"模型类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 品牌class Brand(models.Model): name = models.CharField(max_length=20, verbose_name=&#x27;品牌名&#x27;) class Meta: db_table = &#x27;tb_brand&#x27;# 分类class Cate(models.Model): name = models.CharField(max_length=20, verbose_name=&#x27;分类名&#x27;) class Meta: db_table = &#x27;tb_cate&#x27;# 商品表： id、name、price、history、stock、 salesclass Goods(models.Model): cate = models.ForeignKey(null=True, to=Cate, on_delete=models.CASCADE, verbose_name=&#x27;分类&#x27;) brand = models.ForeignKey(null=True, to=Brand, on_delete=models.CASCADE, verbose_name=&#x27;品牌&#x27;) name = models.CharField(max_length=20, verbose_name=&#x27;商品名&#x27;) price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=&#x27;价格&#x27;) history = models.IntegerField(default=0, verbose_name=&#x27;浏览量&#x27;) stock = models.IntegerField(default=0, verbose_name=&#x27;库存&#x27;) sales = models.IntegerField(default=0, verbose_name=&#x27;销量&#x27;) class Meta: db_table = &#x27;tb_goods&#x27;# 订单：订单id、创建时间、更新时间、用户、总数、总价、实付金额、订单状态class Order(models.Model): status_choices = ( (0, &#x27;未支付&#x27;), (1, &#x27;未收货&#x27;), (2, &#x27;未评价&#x27;), (3, &#x27;已完成&#x27;), ) order_id = models.CharField(max_length=64, verbose_name=&#x27;订单号&#x27;, primary_key=True) create_time = models.DateTimeField(auto_now_add=True, verbose_name=&#x27;创建时间&#x27;) update_time = models.DateTimeField(auto_now=True, verbose_name=&#x27;更新时间&#x27;) user = models.ForeignKey(to=User, on_delete=models.CASCADE, verbose_name=&#x27;用户&#x27;) total = models.IntegerField(default=0, verbose_name=&#x27;商品总数&#x27;) total_amount = models.DecimalField(default=0, max_digits=10, decimal_places=2, verbose_name=&#x27;商品总价&#x27;) pay_amount = models.DecimalField(default=0, max_digits=10, decimal_places=2, verbose_name=&#x27;实付金额&#x27;) status = models.SmallIntegerField(choices=status_choices, verbose_name=&#x27;订单状态&#x27;) class Meta: db_table = &#x27;tb_order&#x27;# 订单商品表：id、 name、price、num、goods_id(外键)、order_id(外键)、amountclass OrderGoods(models.Model): order = models.ForeignKey(to=Order, related_name=&#x27;order_goods&#x27;, on_delete=models.CASCADE, verbose_name=&#x27;订单&#x27;) goods = models.ForeignKey(to=Goods, related_name=&#x27;orders&#x27;, on_delete=models.CASCADE, verbose_name=&#x27;商品&#x27;) name = models.CharField(max_length=20, verbose_name=&#x27;商品名&#x27;) price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=&#x27;价格&#x27;) num = models.IntegerField(verbose_name=&#x27;数量&#x27;) amount = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=&#x27;小计&#x27;) class Meta: db_table = &#x27;tb_order_goods&#x27; 查询聚合 聚合查询函数是对一组值执行计算，并返回单个值。 Django 使用聚合查询前要先从 django.db.models 引入 Avg、Max、Min、Count、Sum（首字母大写）。 1from django.db.models import Avg,Max,Min,Count,Sum # 引入函数 聚合查询返回值的数据类型是字典。 1aggregate(别名 = 聚合函数名(&quot;属性名称&quot;)) 查询所有订单的总价 1Order.objects.aggregate(sum=Sum(&quot;total_amount&quot;)) 查询所有商品的平均价格 1Goods.objects.aggregate(avg=Avg(&quot;price&quot;)) 分组 分组查询一般会用到聚合函数，所以使用前要先从 django.db.models 引入 Avg,Max,Min,Count,Sum（首字母大写） 1from django.db.models import Avg,Max,Min,Count,Sum # 引入函数 返回值： 分组后，用 values 取值，则返回值是 QuerySet ,数据类型里面为一个个字典； 分组后，用 values_list 取值，则返回值是 QuerySet ,数据类型里面为一个个元组。 MySQL 中的 limit 相当于 ORM 中的 QuerySet 数据类型的切片。 注意： annotate 里面放聚合函数。 values 或者 values_list 放在 annotate 前面：values 或者 values_list 是声明以什么字段分组，annotate 执行分组。 values 或者 values_list 放在annotate后面： annotate 表示直接以当前表的pk执行分组，values 或者 values_list 表示查询哪些字段， 并且要将 annotate 里的聚合函数起别名，在 values 或者 values_list 里写其别名。 查询每天的订单量、销售额 123456Order.objects.\\annotate(day=TruncDay(&#x27;create_time&#x27;)).\\ # 将订单对象，添加一个新字段# 按照日期分组，然后对 分组结果 进行聚合计算values(&#x27;day&#x27;).annotate(total=Count(&#x27;id&#x27;),sum=Sum(&#x27;total_amount&#x27;)).\\# 从聚合结果中，查询哪些字段values(&#x27;day&#x27;, &#x27;total&#x27;, &#x27;sum&#x27;) 查询每天商品的销售额 1OrderGoods.objects.annotate(day=TruncDay(&#x27;order__create_time&#x27;)).values(&#x27;day&#x27;).annotate(sum=Sum(&#x27;amount&#x27;)).values(&#x27;day&#x27;, &#x27;sum&#x27;) 查询每个品牌商品的销售额 1OrderGoods.objects.values(&#x27;goods__brand__name&#x27;).annotate(sum=Sum(&#x27;amount&#x27;)) 查询每类商品的销售额 1OrderGoods.objects.values(&#x27;goods__cate__name&#x27;).annotate(sum=Sum(&#x27;amount&#x27;)) 查询每天用户新增量 1User.objects.annotate(day=TruncDay(&#x27;date_joined&#x27;)).values(&#x27;day&#x27;).annotate(n=Count(&#x27;id&#x27;))","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"ORM操作","slug":"ORM操作","permalink":"https://www.bookandmusic.cn/tags/ORM%E6%93%8D%E4%BD%9C/"}]},{"title":"Django基础(二)-视图","slug":"Django-2-视图","date":"2021-01-23T14:31:00.000Z","updated":"2021-06-12T06:31:06.390Z","comments":true,"path":"2021/01/23/django-2-shi-tu/","link":"","permalink":"https://www.bookandmusic.cn/2021/01/23/django-2-shi-tu/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"django基础","slug":"django基础","permalink":"https://www.bookandmusic.cn/tags/django%E5%9F%BA%E7%A1%80/"}]},{"title":"好用的CLI工具","slug":"工具-好用的 CLI 工具","date":"2020-12-27T14:10:35.000Z","updated":"2021-01-21T07:06:06.000Z","comments":true,"path":"2020/12/27/gong-ju-hao-yong-de-cli-gong-ju/","link":"","permalink":"https://www.bookandmusic.cn/2020/12/27/gong-ju-hao-yong-de-cli-gong-ju/","excerpt":"","text":"1 Starship如果必须要从本篇文章中选择一个我最喜欢的终端工具——那非 Starship 莫属。Starship 可以适用于任何 Shell。你只需要安装它，然后在相应的配置文件.bashrc/.zshrc添加一行配置，剩下的工作交给它来完成就好了。 1eval &quot;$(starship init bash)&quot; 它可以做到： 根据你是否在代码仓库中添加了新文件、是否修改了文件、是否暂存了文件等情况，用相应的符号表示 git 仓库的状态。 根据你所在的 Python 项目目录，展示 Python 的版本号，这也适用于 Go/Node/Rust/Elm 等其他编程语言环境。 展示上一个命令执行所用的时间，指令运行时间必须在毫秒级别。 如果上一个命令执行失败，会展示相应的错误提示符。 还有不计其数的其他信息可以展示。但是，它能以更加友好的形式智能地给你呈现! 1234567891011121314151617181920212223242526272829303132333435363738394041# startship 个性化配置[character] # 正在配置的组件名称是“character”symbol = &quot;&gt;&quot; # 提示符中在输入文本之前显示的符号error_symbol = &quot;✗&quot; # 如果上一条命令失败，提示符中在输入文本之前显示的符号use_symbol_for_status = true # 指示是否改变显示符号来指出错误状态style_success = &quot;bold green&quot; # 上次命令成功时使用的样式style_failure = &quot;bold red&quot; # 上次命令失败时使用的样式# 当 starship 扫描当前目录下的文件和文件夹时，最多使用 10 毫秒scan_timeout = 10[battery]full_symbol = &quot;🔋&quot; # 电量满标志charging_symbol = &quot;⚡️&quot; # 充电标志discharging_symbol = &quot;💀&quot; # 放电标志[[battery.display]] # 当电量在 0% 到 30% 时以 &quot;bold red&quot; 样式显示threshold = 30style = &quot;bold red&quot;[[battery.display]] # 当电量在 30% 到 100% 时以 &quot;bold yellow&quot; 样式显示threshold = 100style = &quot;bold yellow&quot;[cmd_duration]min_time = 100 # 显示此组件所需的最短执行时长prefix = &quot;underwent &quot; # 直接在执行时长前显示的前缀style = &quot;bold yellow&quot; # 此组件的样式[directory] # 显示当前目录的路径truncation_length = 8 # 当前目录路径被截断后最多保留的父目录数量。truncate_to_repo = true # 是否只截断到您当前处于的 git 仓库根目录下。prefix = &quot;in&quot; # 直接在显示路径前显示的前缀。style = &quot;bold cyan&quot; # 此组件的样式。[time]disabled = false # 启用时间组件use_12hr = false # 禁用12小时制format = &quot;🕙[ %T ]&quot; # 时间格式time_range = &quot;-&quot; # 显示时间的范围，必须是24小时制 官网地址：https://starship.rs/ 2 fzffzf— fuzzy finder，即模糊查找器。它是一种通用工具，可让你使用模糊搜索来查找文件、历史命令、进程、git 提交等。你键入一些字母，它会尝试匹配结果列表中任何位置的字母。输入的字母越多，结果也就越准确。你可能在其他的代码编辑器中有过这种类型的搜索使用体验——当你想打开某个文件时，只键入文件名的一部分而不用输入完整路径就能进行查找——这就是模糊搜索。 我通过 fish fzf 插件插件使用它，因此我可以搜索命令历史记录或快速打开文件。这是可以每天为我节省不少时间的一个非常棒的工具。 fzf默认会以“extened-search”模式启动， 这种模式下你可以输入多个以空格分隔的搜索关键词， 如^music .mp3$, sbtrkt !fire. Token Match type Description sbtrkt fuzzy-match 匹配sbtrkt ^music prefix-exact-match 以music开头 .mp3^ suffix-exact-match 以.mp3结尾 ‘wild exact-match(quoted) 精确包含wild !fire inverse-exact-match 不包含fire !.mp3$ inverse-suffix-exact-match 不以.mp3结尾 如果你不想用fuzzy match， 可以用fzf -e做精确匹配符号”|”可以做or匹配， 比如 1^core go$|rb$|py$ 表示以core开头，以go或rb或py结尾的 下载地址：https://github.com/junegunn/fzf 3 fd类似于系统自带的 find 命令，但使用起来更简单，查找速度更快，并且具有良好的默认设置。 简单搜索fd设计用于查找文件系统中的条目. 你可以执行的最基本的搜索就是运行一个参数:搜索模式的fd. 例如,假设您想查找您的旧脚本 (包括netflix) : 12&gt; fd netflSoftware/python/imdb-ratings/netflix-details.py 如果只调用一个这样的参数,fd递归检索当前目录中, 包含模式netfl的任何条目. 正则表达式搜索搜索模式被视为正则表达式. 这里,我们搜索开始x并以rc结束的条目. : 1234&gt; cd /etc&gt; fd &#x27;^x.*rc$&#x27;X11/xinit/xinitrcX11/xinit/xserverrc 指定根目录如果我们想搜索一个特定的目录,它可以作为第二个参数fd: 1234&gt; fd passwd /etc/etc/default/passwd/etc/pam.d/passwd/etc/passwd 仅运行fdfd可以不带参数调用. 这是非常有用的,以便快速地查看当前目录中的所有条目,递归地 (类似于ls -R) : 12345&gt; cd fd/tests&gt; fdtestenvtestenv/mod.rstests.rs 搜索特定的文件扩展名通常,我们对特定类型的所有文件感兴趣. 这可以用-e (或) --extension选择权. 在这里,我们搜索FD仓库中的所有md文件: 1234&gt; cd fd&gt; fd -e mdCONTRIBUTING.mdREADME.md 这个-e选项可以与搜索模式结合使用: 1234&gt; fd -e rs modsrc/fshelper/mod.rssrc/lscolors/mod.rstests/testenv/mod.rs 下载地址：https://github.com/sharkdp/fd 4 ripgrep 上图为 grep（左）与 rg（右）命令执行时的对比。 与上述fd指令类似，ripgrep是grep命令的替代方法， 不过ripgrep的执行速度更快，而且具有健全的默认配置以及丰富的彩色输出。 它同样会跳过被.gitignore忽略以及隐藏的文件，因此如果有特殊需要，我们可以设置指令别名：rga =&#39;rg -uuu&#39;。它会禁用所有智能筛选，并使ripgrep的表现与标准的 grep 指令一致。 简单搜索1ls | rg App 正则表达式搜索1ls | rg ^App.*$ 指定文件搜索1rg ^def.*$ 01_two-sum.py 下载地址：https://github.com/BurntSushi/ripgrep 5 htop 和 glances在 Linux 或 Mac 上显示进程运行状态信息最常用工具是我们熟悉的top，它是每位系统管理员的好帮手。而且，即使是像我一样主要从事网络开发，查看计算机的运行状况也很有用。你知道，只是看一下当前到底是 Docker 进程还是 Chrome 进程吃掉了你所有的 RAM，应该如何做吗？ htop工具是top工具的绝佳替代品。 top工具是非常基础的监控工具，提供的功能有限，因此很多人转去使用 htop。htop比起top，优势很明显——除了功能更加完善以外，它的色彩搭配也很丰富，整体上使用起来更加友好。 借助 glances，还可以让你一目了然地快速了解系统当前状态。 glances 是htop的补充工具。除了列出所有进程及其 CPU 和内存使用情况之外，它还可以显示有关系统的其他信息，比如： 网络及磁盘使用情况 文件系统已使用的空间和总空间 来自不同传感器（例如电池）的数据 以及最近消耗过多资源的进程列表 我选择使用htop来筛选和终止进程，因为对我来讲，效率提高了不少，我也使用 glances可以快速浏览一下计算机的运行状况。它提供 API 接口、Web UI 以及支持各种导出格式，因此你可以将系统监视提高到一个新 Level。因此我在这里强烈推荐一波！ htop 下载地址：https://hisham.hm/htop/ glances 下载地址：https://nicolargo.github.io/glances/ 6 virtualenvVirtualenv 是用于在 Python 中创建虚拟环境的工具（比起内置的venv模块，我更喜欢 Virtualenv）。 virtualenvwrapper 是 virtualenv 的虚拟环境管理器。它提供了许多命令来执行快速创建、列出或删除虚拟环境等操作。 virtualenv 下载地址： https://pypi.org/project/virtualenv/ 7 Homebrew 如果你使用的是 Mac，那我就无需再介绍 Homebrew 了。它是 macOS 上被业界普遍认可的软件包管理器。 下载地址：https://brew.sh/ 在Mac下面安装Mysql、Redis、Node之类软件的时候，比较方便的方式是使用Homebrew（号称是The missing package manager for OS X）。不过Homebrew是命令行方式，用起来不是那么的友好，所以就有了Cakebrew。 网站：https://www.cakebrew.com/ 非常友好的图形界面，使用起来简单快捷。 而LaunchRocket呢，则是一个帮助管理Homebrew安装的服务的软件，比如你使用Homebrew安装的Mysql、Redis、MongoDB，是让它自启动呢，还是手动启动，传统方式需要使用命令行的命令，而使用LaunchRocket则可以在图形界面中进行管理了！ 网站：https://github.com/jimbojsb/launchrocket 8 tree你可以通过brew install tree安装该工具。如果要查看给定目录的内容，那么 tree 是执行此操作的必备工具。它能以漂亮的树状结构显示所有子目录及文件： 1234567891011121314$ tree ..├── recovery.md├── README.md├── archive├── automator│ ├── Open\\\\ Iterm2.workflow│ │ └── Contents│ │ ├── Info.plist│ │ ├── QuickLook│ │ │ └── Thumbnail.png│ │ └── document.wflow│ └── Start\\\\ Screen\\\\ Saver.workflow├── brew-cask.sh 9 bat 类似于在终端中常用的用于显示文件内容的cat命令，但是bat效果更佳。 它增加了语法高亮显示，git gutter 标记（如果适用），自动分页（如果文件很大）等功能，并且使得输出的内容阅读起来更加友好。 bat 下载地址：https://github.com/sharkdp/bat 10 httpie 如果你需要发送一些 HTTP 请求，但发现使用curl不够直观，那么请尝试一下httpie。这是一款非常好用的curl替代工具。合理的默认配置以及简洁的语法使它更易于使用，命令返回也是彩色输出，甚至支持为不同类型的身份验证安装相应的插件。 httpie 下载地址：https://httpie.org/ 11 tldr简化版的命令帮助手册。“man pages” 包含了 Linux 软件的手册，这些手册解释了如何使用给定的命令。你可以尝试运行man cat或man grep来查看相关命令的帮助手册。它们描述的非常详细，有时可能难以掌握。因此，tldr社区的目的，就是将每个命令的帮助手册进行简化，方便用户查阅。 tldr适用于几乎所有的受欢迎的软件。正如我提到的，这是社区的努力和功劳，虽然不太可能包含所有的软件的简化帮助手册。但是当某个帮助手册被纳入管理并起作用时，它提供的信息通常就是你要查找的内容。 比如，如果你要创建一些文件的 gzip 压缩存档，man tar可以为你提供可能的参数选择。而tldr tar会列出一些我们常见的示例——如图所示，第二个示例正是你要执行的操作： “man pages” 展示的信息太全面了，但是很多时候使用tldr可以更快地帮你找到特定信息，这才是用户真正想要的。 tldr 下载地址：https://tldr.sh/ 12 exa exa是ls命令的一个可替代方案。 它色彩艳丽，还可以显示 git 状态等其他信息，自动将文件大小转换为方便人们阅读的单位，并且所有这些都保持与ls几乎相同的执行速度。虽然我很喜欢这个工具并推荐给你们，但由于某种原因，我仍然坚持使用 ls。 exa 下载地址：https://the.exa.website/ 13 litecli 和 mycli 这是我首选的 SQLite 和 mysql的解决方案。借助自动提示和语法突出显示，它们比默认的sqlite3和mysql工具要好用很多。 litecli 下载地址：https://litecli.com/ mycli 下载地址：https://www.mycli.net/ 14 ncdu 这是在终端进行磁盘分析时使用的工具，它使用起来简单快捷。当我需要释放一些硬盘空间时，会默认使用这款工具。 ncdu 下载地址：https://dev.yorhel.nl/ncdu","categories":[{"name":"系统","slug":"系统","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"Mac","slug":"系统/Mac","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/Mac/"}],"tags":[{"name":"CLI","slug":"CLI","permalink":"https://www.bookandmusic.cn/tags/CLI/"},{"name":"终端工具","slug":"终端工具","permalink":"https://www.bookandmusic.cn/tags/%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7/"}]},{"title":"Vue组件间通信方式","slug":"vue 组件间通信六种方式（完整版） ","date":"2020-12-27T13:56:48.000Z","updated":"2021-06-12T06:38:56.764Z","comments":true,"path":"2020/12/27/vue-zu-jian-jian-tong-xin-liu-chong-fang-shi-wan-zheng-ban/","link":"","permalink":"https://www.bookandmusic.cn/2020/12/27/vue-zu-jian-jian-tong-xin-liu-chong-fang-shi-wan-zheng-ban/","excerpt":"","text":"前言组件是 vue.js 最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系： 如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。 针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。本文总结了 vue 组件间通信的几种方式，如 props/$emit、$emit/$on、vuex、$parent / $children、$attrs/$listeners和 provide/inject，以通俗易懂的实例讲述这其中的差别及使用场景，希望对小伙伴有些许帮助。 方法一、props/$emit父组件 A 通过 props 的方式向子组件 B 传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。 1. 父组件向子组件传值接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件 Users.vue 中如何获取父组件 App.vue 中的数据 users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;] 1.1 App.vue父组件12345678910111213141516171819&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 前者自定义名称便于子组件调用，后者要传递数据名 --&gt; &lt;users v-bind:users=&quot;users&quot;&gt;&lt;/users&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Users from &quot;./components/Users&quot;export default &#123; name: &#x27;App&#x27;, data()&#123; return&#123; users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;] &#125; &#125;, components:&#123; &quot;users&quot;:Users &#125;&#125; 1.2 Users.vue子组件123456789101112131415161718&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/li&gt;//遍历传递过来的值，然后呈现到页面 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;HelloWorld&#x27;, props:&#123; users:&#123; //这个就是父组件中子标签自定义名字 type:Array, required:true &#125; &#125;&#125;&lt;/script&gt; 总结：父组件通过 props 向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed 2. 子组件向父组件传值（通过事件形式）接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击 “Vue.js Demo” 后，子组件向父组件传递值，文字由原来的 “传递的是一个值” 变成“子向父组件传值”，实现子组件向父组件值的传递。 2.1 Header.vue 子组件1234567891011121314151617181920&lt;template&gt; &lt;header&gt; &lt;h1 @click=&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;//绑定一个点击事件 &lt;/header&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;app-header&#x27;, data() &#123; return &#123; title:&quot;Vue.js Demo&quot; &#125; &#125;, methods:&#123; changeTitle() &#123; this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);//自定义事件 传递值“子向父组件传值” &#125; &#125;&#125;&lt;/script&gt; 2.2 App.vue 父组件123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;app-header v-on:titleChanged=&quot;updateTitle&quot; &gt;&lt;/app-header&gt; &lt;!-- 与子组件titleChanged自定义事件保持一致 --&gt; &lt;!-- updateTitle($event)接受传递过来的文字 --&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Header from &quot;./components/Header&quot;export default &#123; name: &#x27;App&#x27;, data()&#123; return&#123; title:&quot;传递的是一个值&quot; &#125; &#125;, methods:&#123; updateTitle(e)&#123; //声明这个函数 this.title = e; &#125; &#125;, components:&#123; &quot;app-header&quot;:Header, &#125;&#125;&lt;/script&gt; 总结：子组件通过 events 给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。 方法二、$emit/$on这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件, 巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案 vuex。 1. 具体实现方式：123var Event=new Vue();Event.$emit(事件名,数据);Event.$on(事件名,data =&gt; &#123;&#125;); 2. 举个例子假设兄弟组件有三个，分别是 A、B、C 组件，C 组件如何获取 A 或者 B 组件的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;div id=&quot;itany&quot;&gt; &lt;my-a&gt;&lt;/my-a&gt; &lt;my-b&gt;&lt;/my-b&gt; &lt;my-c&gt;&lt;/my-c&gt;&lt;/div&gt;&lt;template id=&quot;a&quot;&gt; &lt;div&gt; &lt;h3&gt;A组件：&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;send&quot;&gt;将数据发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;b&quot;&gt; &lt;div&gt; &lt;h3&gt;B组件：&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;send&quot;&gt;将数组发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;c&quot;&gt; &lt;div&gt; &lt;h3&gt;C组件：&#123;&#123;name&#125;&#125;，&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var Event = new Vue(); //定义一个空的Vue实例var A = &#123; template: &#x27;#a&#x27;, data() &#123; return &#123; name: &#x27;tom&#x27; &#125; &#125;, methods: &#123; send() &#123; Event.$emit(&#x27;data-a&#x27;, this.name); &#125; &#125;&#125;var B = &#123; template: &#x27;#b&#x27;, data() &#123; return &#123; age: 20 &#125; &#125;, methods: &#123; send() &#123; Event.$emit(&#x27;data-b&#x27;, this.age); &#125; &#125;&#125;var C = &#123; template: &#x27;#c&#x27;, data() &#123; return &#123; name: &#x27;&#x27;, age: &quot;&quot; &#125; &#125;, mounted() &#123;//在模板编译完成后执行 Event.$on(&#x27;data-a&#x27;,name =&gt; &#123; this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event &#125;) Event.$on(&#x27;data-b&#x27;,age =&gt; &#123; this.age = age; &#125;) &#125;&#125;var vm = new Vue(&#123; el: &#x27;#itany&#x27;, components: &#123; &#x27;my-a&#x27;: A, &#x27;my-b&#x27;: B, &#x27;my-c&#x27;: C &#125;&#125;); &lt;/script&gt; $on 监听了自定义事件 data-a 和 data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。 方法三、vuex 1. 简要介绍 Vuex 原理Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 进行，Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作 (常见于调用后端接口异步获取更新数据) 或批量的同步操作需要走 Action，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根据 State 的变化，渲染到视图上。 2. 简要介绍各模块在流程中的功能： Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。 dispatch：操作行为触发方法，是唯一能执行 action 的方法。 actions：操作行为处理模块, 由组件中的$store.dispatch(&#39;action 名称&#39;, data1)来触发。然后由 commit() 来触发 mutation 的调用 , 间接更新 state。负责处理 Vue Components 接收到的所有交互行为。包含同步 / 异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。 commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。 mutations：状态改变操作方法，由 actions 中的commit(&#39;mutation 名称&#39;)来触发。是 Vuex 修改 state 的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。 state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。 getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。 3.Vuex 与 localStoragevuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在 vuex 里数据改变的时候把数据拷贝一份保存到 localStorage 里面，刷新之后，如果 localStorage 里有保存的数据，取出来再替换 store 里的 state。 1234567891011121314151617181920212223let defaultCity = &quot;上海&quot;try &#123; // 用户关闭了本地存储功能，此时在外层加个try...catch if (!defaultCity) &#123; defaultCity = JSON.parse(window.localStorage.getItem(&#x27;defaultCity&#x27;)) &#125;&#125; catch (e) &#123;&#125;export default new Vuex.Store(&#123; state: &#123; city: defaultCity &#125;, mutations: &#123; changeCity(state, city) &#123; state.city = city try &#123; window.localStorage.setItem(&#x27;defaultCity&#x27;, JSON.stringify(state.city)); // 数据改变的时候把数据拷贝一份保存到localStorage里面 &#125; catch (e) &#123; &#125; &#125; &#125;&#125;) 这里需要注意的是：由于 vuex 里，我们保存的状态，都是数组，而 localStorage 只支持字符串，所以需要用 JSON 转换： 12JSON.stringify(state.subscribeList); // array -&gt; stringJSON.parse(window.localStorage.getItem(&quot;subscribeList&quot;)); // string -&gt; array 方法四、$attrs/$listeners多级组件嵌套需要传递数据时，通常使用的方法是通过 vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此 Vue2.4 版本提供了另一种方法 —-$attrs/$listeners $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 interitAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件 接下来我们看个跨级通信的例子： 123456789101112131415161718192021222324252627// index.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;浪里行舟&lt;/h2&gt; &lt;child-com1 :foo=&quot;foo&quot; :boo=&quot;boo&quot; :coo=&quot;coo&quot; :doo=&quot;doo&quot; title=&quot;前端工匠&quot; &gt;&lt;/child-com1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);export default &#123; components: &#123; childCom1 &#125;, data() &#123; return &#123; foo: &quot;Javascript&quot;, boo: &quot;Html&quot;, coo: &quot;CSS&quot;, doo: &quot;Vue&quot; &#125;; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920212223// childCom1.vue&lt;template class=&quot;border&quot;&gt; &lt;div&gt; &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);export default &#123; components: &#123; childCom2 &#125;, inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性 props: &#123; foo: String // foo作为props属性绑定 &#125;, created() &#123; console.log(this.$attrs); // &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920212223// childCom2.vue&lt;template&gt; &lt;div class=&quot;border&quot;&gt; &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;/p&gt; &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;child-com3 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom3 = () =&gt; import(&quot;./childCom3.vue&quot;);export default &#123; components: &#123; childCom3 &#125;, inheritAttrs: false, props: &#123; boo: String &#125;, created() &#123; console.log(this.$attrs); // &#123;&quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125; &#125;&#125;;&lt;/script&gt; 1234567891011121314// childCom3.vue&lt;template&gt; &lt;div class=&quot;border&quot;&gt; &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; coo: String, title: String &#125;&#125;;&lt;/script&gt; 如上图所示$attrs表示没有继承数据的对象，格式为 {属性名：属性值}。Vue2.4 提供了$attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。 简单来说：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。 方法五、provide/inject1. 简介Vue2.2.0 新增 API, 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 2. 举个例子假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件 123456// A.vueexport default &#123; provide: &#123; name: &#x27;浪里行舟&#x27; &#125;&#125; 1234567// B.vueexport default &#123; inject: \\[&#x27;name&#x27;\\], mounted () &#123; console.log(this.name); // 浪里行舟 &#125;&#125; 可以看到，在 A.vue 里，我们设置了一个 provide: name，值为 浪里行舟，它的作用就是将 name 这个变量提供给它的所有子组件。而在 B.vue 中，通过 inject 注入了从 A 组件中提供的 name 变量，那么在组件 B 中，就可以直接通过 this.name 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。 需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的 —-vue 官方文档所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 浪里行舟。 3.provide 与 inject 怎么实现数据响应式一般来说，有两种办法： provide 祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如 props，methods 使用 2.6 最新 API Vue.observable 优化响应式 provide(推荐) 我们来看个例子：孙组件 D、E 和 F 获取 A 组件传递过来的 color 值，并能实现数据响应式变化，即 A 组件的 color 变化后，组件 D、E、F 会跟着变（核心代码如下：） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// A 组件 &lt;div&gt; &lt;h1&gt;A 组件&lt;/h1&gt; &lt;button @click=&quot;() =&gt; changeColor()&quot;&gt;改变color&lt;/button&gt; &lt;ChildrenB /&gt; &lt;ChildrenC /&gt;&lt;/div&gt;...... data() &#123; return &#123; color: &quot;blue&quot; &#125;; &#125;, // provide() &#123; // return &#123; // theme: &#123; // color: this.color //这种方式绑定的数据并不是可响应的 // &#125; // 即A组件的color变化后，组件D、E、F不会跟着变 // &#125;; // &#125;, provide() &#123; return &#123; theme: this//方法一：提供祖先组件的实例 &#125;; &#125;, methods: &#123; changeColor(color) &#123; if (color) &#123; this.color = color; &#125; else &#123; this.color = this.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;; &#125; &#125; &#125; // 方法二:使用2.6最新API Vue.observable 优化响应式 provide // provide() &#123; // this.theme = Vue.observable(&#123; // color: &quot;blue&quot; // &#125;); // return &#123; // theme: this.theme // &#125;; // &#125;, // methods: &#123; // changeColor(color) &#123; // if (color) &#123; // this.theme.color = color; // &#125; else &#123; // this.theme.color = this.theme.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;; // &#125; // &#125; // &#125; 12345678910111213141516// F 组件 &lt;template functional&gt; &lt;div class=&quot;border2&quot;&gt; &lt;h3 :style=&quot;&#123; color: injections.theme.color &#125;&quot;&gt;F 组件&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; inject: &#123; theme: &#123; //函数式组件取值不一样 default: () =&gt; (&#123;&#125;) &#125; &#125;&#125;;&lt;/script&gt; 虽说 provide 和 inject 主要为高阶插件 / 组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！ 方法六、$parent / $children与 ref ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 ref来访问组件的例子： 12345678910111213// component-a 子组件export default &#123; data () &#123; return &#123; title: &#x27;Vue.js&#x27; &#125; &#125;, methods: &#123; sayHello () &#123; window.alert(&#x27;Hello&#x27;); &#125; &#125;&#125; 12345678910111213// 父组件&lt;template&gt; &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted () &#123; const comA = this.$refs.comA; console.log(comA.title); // Vue.js comA.sayHello(); // 弹窗 &#125; &#125;&lt;/script&gt; 不过，这两种方法的弊端是，无法在跨级或兄弟间通信。 1234// parent.vue&lt;component-a&gt;&lt;/component-a&gt;&lt;component-b&gt;&lt;/component-b&gt;&lt;component-b&gt;&lt;/component-b&gt; 我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。 总结常见使用场景可以分为三类： 父子通信： 父向子传递数据是通过 props，子向父是通过 events（$emit）；通过父链 / 子链也可以通信（$parent / $children）；ref 也可以访问组件实例；provide / inject API；$attrs/$listeners 兄弟通信： Bus；Vuex 跨级通信： Bus；Vuex；provide / inject API、$attrs/$listeners 参考文章 Vue.js 组件精讲 Vue.js 官方文档 Vue 开发实战 Vuex 数据本地储存 Vuex 框架原理与源码分析 Vue 组件通信方式全面详解","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.bookandmusic.cn/tags/Vue/"},{"name":"组件通信","slug":"组件通信","permalink":"https://www.bookandmusic.cn/tags/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"}]},{"title":"Django-中间件","slug":"Django-中间件","date":"2020-12-09T23:50:31.000Z","updated":"2021-01-21T07:03:03.000Z","comments":true,"path":"2020/12/10/django-zhong-jian-jian/","link":"","permalink":"https://www.bookandmusic.cn/2020/12/10/django-zhong-jian-jian/","excerpt":"","text":"1 中间件介绍Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。 中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。 我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。 因为改变的是全局，所以需要谨慎实用，用不好会影响到性能 2 中间件作用如果你想修改请求，例如被传送到view中的HttpRequest对象。 或者你想修改view返回的HttpResponse对象，这些都可以通过中间件来实现。 可能你还想在view执行之前做一些操作，这种情况就可以用 middleware来实现。 Django默认的中间件：（在django项目的settings模块中，有一个 MIDDLEWARE_CLASSES 变量，其中每一个元素就是一个中间件，如下图） 12345678910111213141516171819MIDDLEWARE = [ &#x27;django.middleware.security.SecurityMiddleware&#x27;, # 为request/response提供了几种xss脚本过滤的安全改进，无它不安全 &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, # 开启session会话支持，无它无session &#x27;django.middleware.common.CommonMiddleware&#x27;, # 基于APPEND_SLASH和PREPEND_WWW的设置来重写URL， # 如果APPEND_SLASH设为True，并且初始URL 没有以斜线结尾以及在URLconf 中没找到对应定义，这时形成一个斜线结尾的新URL； # 如果PREPEND_WWW设为True，前面缺少 www.的url将会被重定向到相同但是以一个www.开头的ur &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, # 添加跨站点请求伪造的保护，通过向POST表单添加一个隐藏的表单字段，并检查请求中是否有正确的值，无它无csrf保护 &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;, # 在视图函数执行前向每个接收到的user对象添加HttpRequest属性，表示当前登录的用户，无它用不了request.user &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;, # 开启基于Cookie和会话的消息支持，无它无message &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;, # 对点击劫持的保护] 3 自定义中间件3.1 创建中间件创建中间件有两种方式： 3.1.1 闭包函数构建 定义一个中间件闭包函数，然后返回一个可以被调用的中间件。 中间件闭包函数需要接收一个可以调用的get_response对象。 返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。 1234567891011def my_middleware(get_response): print(&#x27;init 被调用&#x27;) def middleware(request): print(&#x27;before request 被调用&#x27;) response = get_response(request) print(&#x27;after response 被调用&#x27;) return response return middleware 3.1.2 类构建需要继承 django.utils.deprecation.MiddlewareMixin这个类 可以重写的5个方法: 1234567891、process_request(self,request)2、process_view(self, request, callback, callback_args, callback_kwargs)3、process_template_response(self,request,response)4、process_exception(self, request, exception)5、process_response(self, request, response) 以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。 123456789101112131415161718192021222324252627282930313233343536class SimMiddleware(MiddlewareMixin): def __init__(self, get_response): print(&#x27;init=====&#x27;) self.get_response = get_response def process_request(self, request): &quot;&quot;&quot; 处理请求前: 在每个请求上，request对象产生之后，url匹配之前调用,返回None或HttpResponse对象 &quot;&quot;&quot; print(&#x27;before request=====&#x27;, request) def process_view(self, request, view_func, *view_args, **view_kwargs): &quot;&quot;&quot; :param view_func: Django即将使用的视图函数,它是实际的函数对象，而不是函数的名称作为字符串 :param view_args: 将传递给视图的位置参数的列表 :param view_kwargs: 将传递给视图的关键字参数的字典; view_args和view_kwargs都不包含第一个视图参数（request） &quot;&quot;&quot; # 处理视图前：在每个请求上，url匹配之后，视图函数调用之前调用，返回None或HttpResponse对象 print(&#x27;before view=======&#x27;) def process_template_response(self, request, response): # 在视图函数执行完后立即执行的, 执行 该 函数有一个前提条件，那就是视图函数返回的对象要有一个 render() 方法 # （或者表明该对象是一个 TemplateResponse 对象或等价方法） print(&quot;render template=======&quot;) return response def process_exception(self, request, exception): # 这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象 print(&quot;raise exception=======&quot;) return HttpResponse(exception) def process_response(self, request, response): # 处理响应后：视图函数调用之后，所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse对象 print(&#x27;after response=======&#x27;, response) return response 3.2 注册中间件在django项目的settings模块中，在 MIDDLEWARE_CLASSES 变量中添加自定义中间件 12345MIDDLEWARE = [ ... &#x27;book.middleware.my_middleware&#x27;, # book为应用名,middleware为文件名 &#x27;book.middleware.SimMiddleware&#x27;] 3.3 中间件效果 首先是 项目启动时，中间件的初始化 12init=====init 被调用 3.3.1 正常视图12345class Index(View): def get(self, request): print(&quot;Index============&quot;) return HttpResponse(&quot;hello Django&quot;) 当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求会依次穿过所有中间件的process_request方法,最后到达views的函数中，views函数处理后，在依次穿过所有中间件的process_response方法,最后返回给请求者。 1234567before request 被调用before request===== &lt;WSGIRequest: GET &#x27;/&#x27;&gt;before view=======Index============after response======= &lt;HttpResponse status_code=200, &quot;text/html; charset=utf-8&quot;&gt;after response 被调用[21/Sep/2020 14:29:59] &quot;GET / HTTP/1.1&quot; 200 12 3.3.2 错误视图123456class Index(View): def get(self, request): print(&quot;Index============&quot;) 3/0 return HttpResponse(&quot;hello Django&quot;) 此时，视图发生异常， 会执行中间件的 process_exception方法，而在该方法中，将异常信息作为响应返回，因此，页面显示&quot;division by zero&quot; 12345678before request 被调用before request===== &lt;WSGIRequest: GET &#x27;/&#x27;&gt;before view=======Index============raise exception=======after response======= &lt;HttpResponse status_code=200, &quot;text/html; charset=utf-8&quot;&gt;after response 被调用[21/Sep/2020 14:34:15] &quot;GET / HTTP/1.1&quot; 200 16 3.3.3 模板视图12345class Index(View): def get(self, request): print(&quot;Index============&quot;) return TemplateResponse(request, &#x27;index.html&#x27;) 注意: 只有返回的对象是TemplateResponse 对象或等价方法时，才执行中间件的 process_template_response方法，直接调用render方法无效。 12345678before request 被调用before request===== &lt;WSGIRequest: GET &#x27;/&#x27;&gt;before view=======Index============render template=======after response======= &lt;TemplateResponse status_code=200, &quot;text/html; charset=utf-8&quot;&gt;after response 被调用[21/Sep/2020 14:49:05] &quot;GET / HTTP/1.1&quot; 200 149 TemplateResponse VS render TemplateResponse将模板的渲染延迟到视图完成之后。这允许任何模板响应中间件在响应上运行，并有可能在呈现模板之前更改模板或上下文数据。模板响应中间件运行后，将渲染模板，并在将响应返回给客户端之前对渲染的内容运行常规响应中间件。 render()立即呈现模板，并返回HttpResponse。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://www.bookandmusic.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"Django基础(三)-模板","slug":"Django-3-模板","date":"2020-12-09T09:27:02.000Z","updated":"2021-06-12T06:31:11.767Z","comments":true,"path":"2020/12/09/django-3-mo-ban/","link":"","permalink":"https://www.bookandmusic.cn/2020/12/09/django-3-mo-ban/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"django基础","slug":"django基础","permalink":"https://www.bookandmusic.cn/tags/django%E5%9F%BA%E7%A1%80/"}]},{"title":"Django-邮件发送","slug":"Django-邮件发送","date":"2020-12-03T14:07:31.000Z","updated":"2021-06-12T06:32:46.688Z","comments":true,"path":"2020/12/03/django-you-jian-fa-song/","link":"","permalink":"https://www.bookandmusic.cn/2020/12/03/django-you-jian-fa-song/","excerpt":"","text":"我们常常会用到一些发送邮件的功能，比如：有人注册网站之后，需要向其邮箱中发送激活链接，只有点击激活链接，激活账户之后，才允许登录。 配置相关参数在 settings.py 的最后面加上类似这些 12345678EMAIL_BACKEND = &#x27;django.core.mail.backends.smtp.EmailBackend&#x27;EMAIL_USE_TLS = False # 是否使用TLS安全传输协议(用于在两个通信应用程序之间提供保密性和数据完整性。)EMAIL_USE_SSL = True # 是否使用SSL加密，qq企业邮箱要求使用EMAIL_HOST = &#x27;smtp.163.com&#x27; # 发送邮件的邮箱 的 SMTP服务器，这里用了163邮箱EMAIL_PORT = 465 # 发件箱的SMTP服务器端口EMAIL_HOST_USER = &#x27;xxxxx@xmdaren.com&#x27; # 发送邮件的邮箱地址EMAIL_HOST_PASSWORD = &#x27;*********&#x27; # 发送邮件的邮箱密码(这里使用的是授权码)DEFAULT_FROM_EMAIL = EMAIL_HOST_USER # 默认的发送方 DEFAULT_FROM_EMAIL 还可以写成这样： 1DEFAULT_FROM_EMAIL = &#x27;mac &lt;mac@163.com&gt;&#x27; 这样别人收到的邮件中就会有你设定的名称。 下面是一些常用的邮箱： 163 邮箱 126 邮箱 QQ 邮箱 其它邮箱参数可以登陆邮箱寻找帮助信息，也可以尝试在搜索引擎中搜索：”SMTP 邮箱名称”，比如：”163 SMTP” 进行查找。 发送邮件 发送普通邮件可以使用django.core.mail模块下的send_mail函数进行 123456789send_mail(subject, message, from_email, recipient_list, fail_silently=False, html_message=None)# 将邮件发送至recipient_list中的每一个收件人&#x27;&#x27;&#x27;subject: 发送邮件标题message: 发送邮件正文from_email: 发件人邮箱地址recipient_list: 一个字符串列表，每一个数据为接收者的邮箱地址html_message: 如果指定该值，则发送的内容类型为text/html为一个html邮件内容&#x27;&#x27;&#x27; 123456789101112131415from django.conf import settingsfrom django.core.mail import send_maildef send_regiser_active_email(to_email, username, token): &#x27;&#x27;&#x27;发送激活邮件&#x27;&#x27;&#x27; active_url = &quot;&#123;&#125;/user/active/&#123;&#125;&quot;.format(settings.HOST_URL, token) subject = &quot;xxx欢迎信息&quot; message = &#x27;邮件正文&#x27; sender = settings.DEFAULT_FROM_EMAIL receiver = [to_email] html_message = &#x27;&lt;h1&gt;&#123;&#125;, 欢迎您成为xxx注册会员&lt;/h1&gt;请点击下面链接激活您的账户&lt;br/&gt;&lt;a href=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&#x27;.format(username, active_url, active_url) send_mail(subject, message, sender, receiver, html_message=html_message) 邮件激活注册成功，发送激活链接, 注意：为了安全考虑，可以使用itsdangerous，根据用户信息加密生成 token 1234567891011from itsdangerous import TimedJSONWebSignatureSerializer as Serializer # 加密用户信息，生成tokeninfo = &#123;&#x27;confirm&#x27;: user.id&#125;serializer = Serializer(settings.SECRET_KEY, 3600)token = serializer.dumps(info).decode()# 发送邮件send_regiser_active_email(email, username, token) 用户点击激活链接，进行账户激活 1234567891011121314151617# 进行解密， 获取要激活的用户信息serializer = Serializer(settings.SECRET_KEY, 3600)try: # 获取用户id info = serializer.loads(token) # 在路由匹配中，获取tokenexcept (SignatureExpired, BadSignature) as error: return redirect(reverse(&quot;user:activeemail&quot;)) # 激活失败，重写跳转到邮箱激活页面else: user_id = info.get(&quot;confirm&quot;) # 获取用户信息 user = User.objects.get(id=user_id) user.is_active = 1 user.save() # 跳转到登录界面 return redirect(reverse(&#x27;user:login&#x27;)) # 激活成功，跳转到登录页面","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"邮件","slug":"邮件","permalink":"https://www.bookandmusic.cn/tags/%E9%82%AE%E4%BB%B6/"}]},{"title":"Django-缓存","slug":"Django-缓存","date":"2020-12-01T13:49:38.000Z","updated":"2021-01-23T15:21:14.000Z","comments":true,"path":"2020/12/01/django-huan-cun/","link":"","permalink":"https://www.bookandmusic.cn/2020/12/01/django-huan-cun/","excerpt":"","text":"缓存简介在动态网站中,用户所有的请求,服务器都会去数据库中进行相应的增,删,查,改,渲染模板,执行业务逻辑,最后生成用户看到的页面. 当一个网站的用户访问量很大的时候,每一次的的后台操作,都会消耗很多的服务端资源,所以必须使用缓存来减轻后端服务器的压力. 缓存是将一些常用的数据保存到内存或者memcache中,在一定的时间内有人来访问这些数据时,则不再去执行数据库及渲染等操作,而是直接从内存或memcache的缓存中去取得数据,然后返回给用户。 Django缓存缓存方式 Django提供了6种缓存方式 开发调试缓存 内存缓存 文件缓存 数据库缓存 Memcache缓存(使用python-memcached模块) Memcache缓存(使用pylibmc模块) 经常使用的有文件缓存和Mencache缓存, 而选用不同的缓存方式，实际就是需要缓存的数据保存的位置不同。只需要修改django项目的配置文件settings.py，即可实现不同缓存方式的切换。 开发调试 此模式为开发调试使用,实际上不执行任何操作 12345678910CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.dummy.DummyCache&#x27;, # 缓存后台使用的引擎 &#x27;TIMEOUT&#x27;: 300, # 缓存超时时间（默认300秒，None表示永不过期，0表示立即过期） &#x27;OPTIONS&#x27;: &#123; &#x27;MAX_ENTRIES&#x27;: 300, # 最大缓存记录的数量（默认300） &#x27;CULL_FREQUENCY&#x27;: 3, # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3） &#125;, &#125;&#125; 内存缓存 将缓存内容保存至内存区域中 1234567891011CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.locmem.LocMemCache&#x27;, # 指定缓存使用的引擎 &#x27;LOCATION&#x27;: &#x27;unique-snowflake&#x27;, # 写在内存中的变量的唯一值 &#x27;TIMEOUT&#x27;: 300, # 缓存超时时间(默认为300秒,None表示永不过期) &#x27;OPTIONS&#x27;: &#123; &#x27;MAX_ENTRIES&#x27;: 300, # 最大缓存记录的数量（默认300） &#x27;CULL_FREQUENCY&#x27;: 3, # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3） &#125; &#125;&#125; 文件缓存 把缓存数据存储在文件中 1234567891011CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.filebased.FileBasedCache&#x27;, # 指定缓存使用的引擎 &#x27;LOCATION&#x27;: &#x27;/var/tmp/django_cache&#x27;, # 指定缓存的路径 &#x27;TIMEOUT&#x27;: 300, # 缓存超时时间(默认为300秒,None表示永不过期) &#x27;OPTIONS&#x27;: &#123; &#x27;MAX_ENTRIES&#x27;: 300, # 最大缓存记录的数量（默认300） &#x27;CULL_FREQUENCY&#x27;: 3, # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3） &#125; &#125;&#125; 数据库缓存 把缓存数据存储在数据库中 12345678910CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.db.DatabaseCache&#x27;, # 指定缓存使用的引擎 &#x27;LOCATION&#x27;: &#x27;cache_table&#x27;, # 数据库表 &#x27;OPTIONS&#x27;: &#123; &#x27;MAX_ENTRIES&#x27;: 300, # 最大缓存记录的数量（默认300） &#x27;CULL_FREQUENCY&#x27;: 3, # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3） &#125; &#125;&#125; 注意,创建缓存的数据库表使用的语句: 1python manage.py createcachetable Memcached缓存Memcached是Django原生支持的缓存系统.要使用Memcached,需要下载Memcached的支持库python-memcached或pylibmc. 使用python-memcached模块连接memcache 12345678910CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.memcached.MemcachedCache&#x27;, # 指定缓存使用的引擎 &#x27;LOCATION&#x27;: &#x27;192.168.10.100:11211&#x27;, # 指定Memcache缓存服务器的IP地址和端口 &#x27;OPTIONS&#x27;: &#123; &#x27;MAX_ENTRIES&#x27;: 300, # 最大缓存记录的数量（默认300） &#x27;CULL_FREQUENCY&#x27;: 3, # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3） &#125; &#125;&#125; 使用pylibmc模块连接memcache 1234567891011CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.memcached.PyLibMCCache&#x27;, # 指定缓存使用的引擎 &#x27;LOCATION&#x27;: &#x27;192.168.10.100:11211&#x27;, # 指定本机的11211端口为Memcache缓存服务器 &#x27;OPTIONS&#x27;: &#123; &#x27;MAX_ENTRIES&#x27;: 300, # 最大缓存记录的数量（默认300） &#x27;CULL_FREQUENCY&#x27;: 3, # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3） &#125;, &#125;&#125; Memcached是基于内存的缓存,数据存储在内存中.所以如果服务器死机的话,数据就会丢失,所以Memcached一般与其他缓存配合使用 缓存应用 在使用缓存之前，必选先选择一种缓存方式，按照上面的配置信息在 settings.py中实现对应配置。 全站使用缓存 如果想要对整个项目的所有GET和HEAD方法的正常返回结果进行缓存，可以通过中间件实现 用户的请求通过中间件，经过一系列的认证等操作，如果请求的内容在缓存中存在，则使用FetchFromCacheMiddleware获取内容并返回给用户 当返回给用户之前，判断缓存中是否已经存在，如果不存在，则UpdateCacheMiddleware会将缓存保存至Django的缓存之中，以实现全站缓存 请求来了，是从上到下入走中间件；响应的时候是从下到上走中间件。因此，获取页面放在最后，保存页面放最前面 12345678910111213MIDDLEWARE = [ &#x27;django.middleware.cache.UpdateCacheMiddleware&#x27;, # 响应HttpResponse中设置几个headers &#x27;django.middleware.security.SecurityMiddleware&#x27;, &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, &#x27;django.middleware.common.CommonMiddleware&#x27;, &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;, &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;, &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;, &#x27;django.middleware.cache.FetchFromCacheMiddleware&#x27;, # 用来缓存通过GET和HEAD方法获取的状态码为200的响应] CACHE__MIDDLEWARE_SECONDS=15 # 设定超时时间为15秒 此时在中间件中已经设置过缓存，因此其余代码不变，视图中正常执行逻辑，即可实现全站缓存。 1234567891011from django.http.response import HttpResponseimport timedef index(request): print(&#x27;视图函数被调用&#x27;) result = 0 for i in range(10): result += i time.sleep(0.5) ctime = time.strftime(&#x27;%H:%M:%S&#x27;, time.localtime()) return HttpResponse(&quot;时间&#123;&#125;的结果是:&#123;&#125;&quot;.format(ctime, result)) 单独视图 如果不想对所有的查询结果缓存，而只是为单个视图函数添加缓存，就可以使用装饰器实现 12345678910111213from django.views.decorators.cache import cache_pagefrom django.http.response import HttpResponseimport time@cache_page(10) # 缓存10秒def index(request): print(&#x27;视图函数被调用&#x27;) result = 0 for i in range(10): result += i time.sleep(0.5) ctime = time.strftime(&#x27;%H:%M:%S&#x27;, time.localtime()) return HttpResponse(&quot;时间&#123;&#125;的结果是:&#123;&#125;&quot;.format(ctime, result)) 因为缓存的原因,不停的刷新浏览器时会发现：第一次请求页面时，会等待5秒，计算完全部数据数据， 才可以返回结果；在下一次请求时，利用缓存结果，可以很快得到响应数据；直到10秒之后，缓存过期，重新进行该过程。 模板缓存 如果并不想对页面的其余部分做任何处理，只是相对页面的一部分 进行缓存， 就可以使用 模板缓存 实现 如果想对缓存进行更多的控制，可以使用 cache模板标签来缓存模板的一个片段。 views视图函数 1234567from django.shortcuts import renderimport timedef index(request): print(&#x27;视图函数被调用&#x27;) ctime = time.strftime(&#x27;%H:%M:%S&#x27;, time.localtime()) return render(request, &#x27;page.html&#x27;, &#123;&#x27;ctime&#x27;: ctime&#125;) 前端网页 123456789101112131415161718&#123;% load cache %&#125; # 放在缓存片段的上面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模板缓存&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这里是未缓存的时间:&#123;&#123; ctime &#125;&#125;&lt;/p&gt;# 将按给定的时间缓存包含块中的内容。 # 它最少需要两个参数：缓存时间（以秒为单位）；给缓存片段起的名称,该名称将被视为是字符串，而不是变量# 设定超时时间为10秒, 给缓存模板片段起名为 &quot;time&quot;&#123;% cache 10 time %&#125; &lt;p&gt;这里是缓存的时间:&#123;&#123; ctime &#125;&#125;&lt;/p&gt;&#123;% endcache %&#125;&lt;/body&gt;&lt;/html&gt; 刷新浏览器可以看到,第一个时间实时变化,后面一个时间每10秒钟变化一次 手动缓存 如果不想为一个方法（页面）进行缓存，只想缓存某个字段的话，可以 手动缓存 1234567891011121314151617from django.core.cache import cachefrom django.http.response import HttpResponseimport timedef index(request): print(&#x27;视图函数被调用&#x27;) result = cache.get(&#x27;result&#x27;) if not result: result = 0 for i in range(10): result += i time.sleep(0.5) cache.set(&#x27;result&#x27;, result, 10) ctime = time.strftime(&#x27;%H:%M:%S&#x27;, time.localtime()) return HttpResponse(&quot;时间&#123;&#125;的结果是:&#123;&#125;&quot;.format(ctime, result)) Redis缓存参考","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://www.bookandmusic.cn/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"Django-数据分页","slug":"Django-数据分页","date":"2020-11-30T13:45:42.000Z","updated":"2021-06-12T06:32:15.395Z","comments":true,"path":"2020/11/30/django-shu-ju-fen-ye/","link":"","permalink":"https://www.bookandmusic.cn/2020/11/30/django-shu-ju-fen-ye/","excerpt":"","text":"当页面因需要展示的数据条目过多，导致无法在一个页面全部显示。这时，页面经常会采用分页形式进行展示，然后每页显示 20 或者 50 等条数据。分页经常在网站上随处可见， 分页的实现不仅提高了用户体验，还是减轻数据库读取数据的压力。Django 自带名为 Paginator 的分页工具， 方便我们实现分页功能。本文就讲解如何使用 Paginator 实现分页功能。 PaginatorPaginator 类的作用是将我们需要分页的数据分割成若干份。当我们实现化一个 Paginator 类的实例时，需要给 Paginator 传入两个参数。第一个参数是数据源，可以是一个列表、元组、以及查询结果集 QuerySet。第二个参数需要传入一个整数，表示每页显示数据条数。具体用法如下： 导入分页模块1from django.core.paginator import Paginator 获取queryset对象1goods_list = Goods.objects.all().order_by(&#x27;id&#x27;) 实例化分页类对象1paginator = Paginator(goods_list, 2) Paginator类对象的属性 序号 属性名 说明 1 num_pages 返回分页之后的总页数 2 page_range 返回分页后的页码列表 Paginator类对象的方法 序号 方法名 说明 1 get_page(self, number) 返回第number页的page类实例对象 Page实例对象的属性 序号 属性名 说明 1 number 返回当前页的页码 2 object_list 返回当前页的数据查询集 3 paginator 返回对应的Paginator类对象 page实例对象的方法 序号 方法名 说明 1 has_previous 判断当前页是否有前一页 2 has_next 判断当前页是否有下一页 3 previous_page_number 返回前一页的页码 4 next_page_number 返回下一页的页码 分页功能实现views函数123456789101112131415161718192021222324class IndexView(View): def get(self, request): page_number = request.GET.get(&#x27;page&#x27;, 1) # 获取客户端发送的页码，默认为1 page_size = request.GET.get(&#x27;page_size&#x27;, 2) # 获取客户端发送的每页数量，默认为1 try: page_number = int(page_number) # 处理页码， 过滤无效的数据 except: page_number = 1 goods_list = Goods.objects.all().order_by(&#x27;id&#x27;) paginator = Paginator(goods_list, page_size) # 得到分页器对象 page = paginator.get_page(page_number) # 得到当前页码对象 # 获取页码列表 index = page.number - 1 # 当前页码对应的索引 max_index = paginator.num_pages - 1 # 最大索引 # 为了得到显示7个页码的列表，从当前索引向前数3个，向后数3个，加上本身，即7个页码 start_index = index - 3 if index &gt;= 3 else 0 end_index = index + 3 if index &lt;= max_index - 3 else max_index # 最后处理过的页码列表 page_range = paginator.page_range[start_index:end_index + 1] return render(request, &#x27;index.html&#x27;, context=&#123;&#x27;goods&#x27;: page, &#x27;page_range&#x27;: page_range&#125;) 模板实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!-- 引入bootstrap样式文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;css/bootstrap.min.css&#x27; %&#125;&quot;&gt;&lt;!--数据遍历展示--&gt;&lt;table class=&quot;table&quot;&gt; &lt;thead class=&quot;thead-light&quot;&gt; &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;#&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;名称&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;单价&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;数量&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;图片&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for good in goods.object_list %&#125; &lt;tr&gt; &lt;th&gt;&#123;&#123; good.id &#125;&#125;&lt;/th&gt; &lt;td&gt;&#123;&#123; good.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; good.price &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; good.nums &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;/media/&#123;&#123; good.img &#125;&#125;&quot; alt=&quot;&quot; style=&quot;width: 100px;height: 130px&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;!--底部分页按钮--&gt;&lt;nav aria-label=&quot;Page navigation example&quot; style=&quot;margin: 0 auto&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li class=&quot;page-item&quot;&gt; &#123;% if goods.has_previous %&#125; &lt;a href=&quot;&#123;% url &#x27;goods:index&#x27; %&#125;?page=&#123;&#123; goods.previous_page_number &#125;&#125;&quot; class=&quot;page-link&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &#123;% else %&#125; &lt;a href=&quot;#&quot; class=&quot;page-link&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/li&gt; &#123;% for page in page_range %&#125; &lt;li class=&quot;page-item&quot;&gt; &#123;% ifequal page goods.number %&#125; &lt;a href=&quot;#&quot; class=&quot;page-link&quot;&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt; &#123;% else %&#125; &lt;a href=&quot;&#123;% url &#x27;goods:index&#x27; %&#125;?page=&#123;&#123; page &#125;&#125;&quot; class=&quot;page-link&quot;&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt; &#123;% endifequal %&#125; &lt;/li&gt; &#123;% endfor %&#125; &lt;li class=&quot;page-item&quot;&gt; &#123;% if goods.has_next %&#125; &lt;a href=&quot;&#123;% url &#x27;goods:index&#x27; %&#125;?page=&#123;&#123; goods.next_page_number &#125;&#125;&quot; class=&quot;page-link&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &#123;% else %&#125; &lt;a href=&quot;#&quot; class=&quot;page-link&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 路由配置123urlpatterns = [ path(&#x27;&#x27;, IndexView.as_view(), name=&#x27;index&#x27;), # /?page=1&amp;page_size=2]","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"分页","slug":"分页","permalink":"https://www.bookandmusic.cn/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"JWT浅析","slug":"web-JWT浅析","date":"2020-10-24T12:38:26.000Z","updated":"2021-06-10T16:00:25.188Z","comments":true,"path":"2020/10/24/web-jwt-qian-xi/","link":"","permalink":"https://www.bookandmusic.cn/2020/10/24/web-jwt-qian-xi/","excerpt":"","text":"JWT起源 Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519). token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。 JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。 说起 JWT，我们应该来谈一谈基于 token 的认证和传统的 session 认证的区别。 传统的 session 认证我们知道，http 协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据 http 协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为 cookie, 以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了, 这就是传统的基于 session 认证。 但是这种基于 session 的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于 session 认证应用的问题就会暴露出来. 基于 session 认证所显露的问题Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言 session 都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。 扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上, 这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。 CSRF: 因为是基于 cookie 来进行用户识别的, cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。 基于 token 的鉴权机制基于 token 的鉴权机制类似于 http 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。 流程上是这样的： 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个 token 客户端存储 token，并在每次请求时附送上这个 token 值 服务端验证 token 值，并返回数据 这个 token 必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。 那么我们现在回到 JWT 的主题上。 JWT解析网上大多数介绍JWT的文章实际介绍的都是JWS(JSON Web Signature),也往往导致了人们对于JWT的误解，但是JWT并不等于JWS，JWS只是JWT的一种实现，除了JWS外，JWE(JSON Web Encryption)也是JWT的一种实现。 下面就来详细介绍一下JWT与JWE的两种实现方式： JSON Web Signature(JWS)JSON Web Signature是一个有着简单的统一表达形式的字符串：由三段信息构成的，将这三段信息文本用.链接一起就构成了 Jwt 字符串。 第一部分我们称它为头部（header) 第二部分我们称其为载荷（payload, 类似于飞机上承载的物品) 第三部分是签证（signature) 然后将每一部分进行base64编码之后，就像这样: 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ header（头信息）jwt 的头部承载两部分信息： 令牌类型（即：JWT） 散列算法（HMAC、RSASSA、RSASSA-PSS等） 完整的头部就像下面这样的 JSON： 1234&#123; &#x27;typ&#x27;: &#x27;JWT&#x27;, &#x27;alg&#x27;: &#x27;HS256&#x27;&#125; 然后将头部进行 base64 加密（该加密是可以对称解密的), 构成了第一部分. 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 Payload（有效载荷）载荷就是存放有效信息的地方，其中包含claims。claims是关于实体（常用的是用户信息）和其他数据的声明，claims有三种类型： Registered claims（注册的声明）： 这些是一组预定义的claims，非强制性的，但是推荐使用， iss（发行人）， exp（到期时间）， sub（主题）， aud（观众）等； Public claims（公共的声明）: 自定义claims，注意不要和JWT注册表中属性冲突，这里可以查看JWT标准注册表 Private claims（私有的声明）: 这些是自定义的claims，用于在同意使用这些claims的各方之间共享信息，它们既不是Registered claims，也不是Public claims。 标准中注册的声明 建议但不强制使用 iss: jwt 签发者 sub: jwt 所面向的用户 aud: 接收 jwt 的一方 exp: jwt 的过期时间，这个过期时间必须要大于签发时间，注意，这个值是秒数，而不是毫秒数。 nbf: 定义在什么时间之前，该 jwt 都是不可用的. iat: jwt 的签发时间 jti: jwt 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。 name：用户全名 公共的声明公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 但不建议添加敏感信息，因为该部分在客户端可解密。 私有的声明私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。 在官网有详细的属性说明，尽量使用里面提到的 Registered Claim Names，这样可以提高阅读性 自定义一个 payload: 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 然后将其进行 base64 加密，得到 Jwt 的第二部分。 1eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 signaturejwt 的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64 后的) payload (base64 后的) secret 这个签名的计算跟第一部分中的 alg 属性有关，假如是 HS256，那么服务端需要保存一个私钥，比如 secret 。然后，把第一部分和第二部分生成的两个字符串用 . 连接之后，用 HS256 进行加盐secret加密，然后就构成了 jwt 的第三部分。 1TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 将这三部分用.连接成一个完整的字符串, 构成了最终的 jwt: 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 注意：secret 是保存在服务器端的，jwt 的签发生成也是在服务器端的，secret 就是用来进行 jwt 的签发和 jwt 的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个 secret, 那就意味着客户端是可以自我签发 jwt 了。 JSON Web Encryption(JWE)相对于JWS，JWE则同时保证了安全性与数据完整性。JWE由五部分组成： 我们来看看一个标准的JWE过程是怎样的： JOSE含义与JWS头部相同。 生成一个随机的Content Encryption Key （CEK）。 使用RSAES-OAEP 加密算法，用公钥加密CEK，生成JWE Encrypted Key。 生成JWE初始化向量。 使用AES GCM加密算法对明文部分进行加密生成密文Ciphertext,算法会随之生成一个128位的认证标记Authentication Tag。 对五个部分分别进行base64编码。 可见，JWE的计算过程相对繁琐，不够轻量级，因此适合与数据传输而非token认证，但该协议也足够安全可靠，用简短字符串描述了传输内容，兼顾数据的安全性与完整性。 总结优点 因为 json 的通用性，所以 JWT 是可以进行跨语言支持的，像 JAVA,JavaScript,NodeJS,Python 等很多语言都可以使用。 它不需要在服务端保存会话信息, 所以它易于应用的扩展。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"web","slug":"技术/python/web","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/web/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://www.bookandmusic.cn/tags/JWT/"},{"name":"JWS","slug":"JWS","permalink":"https://www.bookandmusic.cn/tags/JWS/"},{"name":"JWE","slug":"JWE","permalink":"https://www.bookandmusic.cn/tags/JWE/"}]},{"title":"Vue引入本地资源","slug":"Vue引入本地资源","date":"2020-10-23T14:28:48.000Z","updated":"2021-06-12T06:38:06.540Z","comments":true,"path":"2020/10/23/vue-yin-ru-ben-di-zi-yuan/","link":"","permalink":"https://www.bookandmusic.cn/2020/10/23/vue-yin-ru-ben-di-zi-yuan/","excerpt":"简单介绍一下在Vue项目中引入本地资源的实现方式:","text":"简单介绍一下在Vue项目中引入本地资源的实现方式: 引入本地图片使用 @引入：这是在组件内直接引用和普通的 html 方法一样，代码如下 1&lt;img src=&quot;@/assets/test.png&quot; alt=&quot;test.png&quot;&gt; 使用 vue 的方法引入：这是典型的 vue 思想，使用数据来操纵 dom； 首先在组件内使用 import … from 引入 1import imgUrl from &#x27;../assets/test.png&#x27;; 然后在 data 里面声明 12345data: function () &#123; return &#123; imgSrc: imgUrl &#125; &#125; 最后绑定数据 1&lt;img :src=&quot;imgSrc&quot; alt=&quot;imgSrc&quot;&gt; 引入样式文件在\b\b项目的 src 文件下，新建一个 style 文件夹，存放 css 文件。 全局引入将外部的 css 文件放到 style 文件下，引入外部文件只需在 main.js\b文件中 1import &#x27;./style/reset.css&#x27; 局部引入123&lt;style scoped&gt; @import &#x27;../assets/iconfont/iconfont.css&#x27;; // 这个分号一定要写，要不会报错&lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.bookandmusic.cn/tags/Vue/"},{"name":"图片","slug":"图片","permalink":"https://www.bookandmusic.cn/tags/%E5%9B%BE%E7%89%87/"},{"name":"样式","slug":"样式","permalink":"https://www.bookandmusic.cn/tags/%E6%A0%B7%E5%BC%8F/"}]},{"title":"Deepin OS 安装 NVIDIA驱动","slug":"系统-deepin OS 安装NVIDIA驱动","date":"2020-09-03T10:20:35.000Z","updated":"2021-01-25T02:59:36.000Z","comments":true,"path":"2020/09/03/xi-tong-deepin-os-an-zhuang-nvidia-qu-dong/","link":"","permalink":"https://www.bookandmusic.cn/2020/09/03/xi-tong-deepin-os-an-zhuang-nvidia-qu-dong/","excerpt":"","text":"工具 / 原料 一台电脑 Deepin15.10.2 系统 N 卡官网驱动 方法 / 步骤一、驱动下载本教程以 GTX1050 为例，前往 N 卡官网下载对应的驱动 : 然后选择一个下载即可，我下载的是NVIDIA-Linux-x86_64-430.26.run，最好不要下载最新的驱动，有可能有 Bug。(为可方便起见，建议更改文件名为 001.run，千万别忘了. run，该文件名只是为了好敲入命令。) 二、禁用 nouveau 驱动 如果之前在 Deepin 中安装过 NVIDIA 驱动，请将其全部删除： 在终端执行命令: sudo apt autoremove nvidia(没有可以跳过) 在终端执行命令: 1sudo dedit /etc/modprobe.d/blacklist.conf 然后在将以下内容复制到文件中 123456789blacklist nouveaublacklist lbm-nouveauoptions nouveau modeset=0alias nouveau offalias lbm-nouveau off 保存退出 接下来在终端执行命令: 1sudo update-initramfs -u 重启系统，再次进入系统，可能会发现分 辨率异常。(分辨率异常就说明成功禁用 nouveau 驱动重启系统，重启后查看是否生效， 1lsmod |grep -i nouveau 三、NVIDIA 安装过程 使用快捷键 CTRL+ALT+F2 进入终端，登录自己的账号 (就是用户名和密码)。 暂时关闭图形界面： 1sudo service lightdm stop 给下载好的 nvidia 驱动文件设置执行权限 (文件默认在 /home/用户名/Downloads/ 目录下，用户名为你自己的用户名，如果你改文件名了，就填你改后的文件名，千万别填 NVIDIA-Linux-x86_64-430.26.run)。 1sudo chmod a+x /home/用户名/Downloads/NVIDIA-Linux-x86_64-430.26.run 驱动安装： 1sudo sh /home / 用户名 / Downloads/NVIDIA-Linux-x86_64-430.26.run (一系列 yes，还有一个界面选择 install and cover，意为安装和覆盖。) 重启系统： 1sudo reboot 安装完成后重启，执行 nvidia-smi 发现这时候其实 NVIDIA 的显卡并没有工作，显存一点都没占用。主要是由于我的电脑是双显卡，这时候其实依然是 intel 集成显卡在工作，所以还要做下面的工作。 四、设置默认 nvidia 显卡工作1lspci | egrep &#x27;VGA|3D&#x27; 执行上述命令获取 nvidia 显卡设备 BusID，例如: 01:00.0 填写 PCI:1:0:0， 然后编辑 /etc/X11/xorg.conf，注意其中 PCI 部分填写 PCI:1:0:0， 12345678910Section &quot;Module&quot; Load &quot;modesetting&quot;EndSectionSection &quot;Device&quot; Identifier &quot;nvidia&quot; Driver &quot;nvidia&quot; BusID &quot;PCI:X:X:X&quot; Option &quot;AllowEmptyInitialConfiguration&quot;EndSection 编辑~/.xinitrc， 123xrandr --setprovideroutputsource modesetting NVIDIA-0xrandr --autoxrandr --dpi 96 编辑/etc/lightdm/display_setup.sh， 1234#!/bin/shxrandr --setprovideroutputsource modesetting NVIDIA-0xrandr --autoxrandr --dpi 96 然后执行 1sudo chmod +x /etc/lightdm/display_setup.sh 编辑 /etc/lightdm/lightdm.conf 在 [Seat:*] 行下添加， 1display-setup-script=/etc/lightdm/display_setup.sh 重启动后，查看是否生效，nvidia-smi 发现已经生效。","categories":[{"name":"系统","slug":"系统","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"系统/linux","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/linux/"}],"tags":[{"name":"deepin","slug":"deepin","permalink":"https://www.bookandmusic.cn/tags/deepin/"},{"name":"nvidia","slug":"nvidia","permalink":"https://www.bookandmusic.cn/tags/nvidia/"}]},{"title":"网络通信-多种方式实现并发 Web Server","slug":"网络通信-多种方式实现并发 Web Server","date":"2020-08-16T13:40:36.000Z","updated":"2021-01-25T02:59:13.000Z","comments":true,"path":"2020/08/16/wang-luo-tong-xin-duo-chong-fang-shi-shi-xian-bing-fa-web-server/","link":"","permalink":"https://www.bookandmusic.cn/2020/08/16/wang-luo-tong-xin-duo-chong-fang-shi-shi-xian-bing-fa-web-server/","excerpt":"","text":"下面我们使用 Python 来实现并发的 Web Server，其中采用了多进程、多线程、协程、单进程单线程非阻塞、select、epoll的方式。 一、使用子进程来实现并发 Web Server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import socketimport reimport multiprocessing# 注意： 不同的实现方式，但是对请求的处理方式相同，只是主函数中对客户端请求的接收方式不同 def handle_request(new_socket): while True: # 接收请求 recv_msg = new_socket.recv(1024).decode(&quot;utf-8&quot;) if recv_msg == &quot;&quot;: print(&quot;recv null&quot;) new_socket.close() return # 从请求中解析出URI recv_lines = recv_msg.splitlines() print(recv_lines) # 使用正则表达式提取出URI ret = re.match(r&quot;[^/]+(/[^ ]*)&quot;, recv_lines[0]) if ret: # 获取URI字符串 file_name = ret.group(1) # 如果URI是/，则默认返回index.html的内容 if file_name == &quot;/&quot;: file_name = &quot;/index.html&quot; try: # 根据请求的URI，读取相应的文件 fp = open(&quot;.&quot; + file_name, &quot;rb&quot;) except: # 找不到文件，响应404 response_msg = &quot;HTTP/1.1 404 NOT FOUND\\r\\n&quot; response_msg += &quot;\\r\\n&quot; response_msg += &quot;&lt;h1&gt;----file not found----&lt;/h1&gt;&quot; new_socket.send(response_msg.encode(&quot;utf-8&quot;)) else: html_content = fp.read() fp.close() response_body = html_content # 响应正确 200 OK response_header = &quot;HTTP/1.1 200 OK\\r\\n&quot; response_header += &quot;Content-Length:%d\\r\\n&quot; % len(response_body) response_header += &quot;\\r\\n&quot; response = response_header.encode(&quot;utf-8&quot;) + response_body # 返回响应数据 new_socket.send(response)def main(): # 创建TCP SOCKET实例 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # # 设置重用地址 # tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址（默认本机IP）和端口 tcp_server_socket.bind((&quot;&quot;, 7890)) # 监听 tcp_server_socket.listen(128) # 循环接收客户端连接 while True: new_socket, client_addr = tcp_server_socket.accept() # 启动一个子进程来处理客户端的请求 sub_p = multiprocessing.Process(target=handle_request, args=(new_socket,)) sub_p.start() # 这里要关闭父进程中的new_socket，因为创建子进程会复制一份new_socket给子进程 new_socket.close() # 关闭整个SOCKET tcp_server_socket.close()if __name__ == &quot;__main__&quot;: main() 我们使用进程来实现并发的 Web Server，也就是将 accept 到 new_socket 传递给子进程去处理，处理函数还是 handle_request。 但是这里注意，子进程会从父进程中将所有的变量进行拷贝，也就是说父进程和子进程中各有一份 new_socket，而在 Linux 下，socket 对应的也是一个文件描述符，而这两个 new_socket 实际上是指向同一个 fd 的。所以我们将 new_socket 交给子进程后，父进程就可以马上关闭自己的 new_socket 了，当子进程服务完毕后，关闭子进程中的 new_socket，这样对应的 FD 才会正真关闭，此时才会触发四次挥手。所以父进程代码中的 new_socket.close() 非常重要。 二、使用线程来实现并发 Web Server在第一节中，我们使用进程来实现并发，但是进程对资源消耗很大，一般不推荐使用。所以这里我们使用线程来实现并发，很简单，我们将 multiprocessing.Process 替换为 threaing.Thread 就可以了： 123456789101112131415161718192021222324252627import socketimport reimport threadingfrom web_server import handle_requestdef main(): # 创建TCP SOCKET实例 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置重用地址 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址（默认本机IP）和端口 tcp_server_socket.bind((&quot;&quot;, 7890)) # 监听 tcp_server_socket.listen(128) # 循环接收客户端连接 while True: new_socket, client_addr = tcp_server_socket.accept() # 启动一个线程来处理客户端的请求 t = threading.Thread(target=handle_request, args=(new_socket,)) t.start() # 关闭整个SOCKET tcp_server_socket.close()if __name__ == &quot;__main__&quot;: main() 我们发现，除了将子进程的创建过程替换成了线程的创建过程，后面的 new_socket.close() 也被删除了，这是因为线程是公用进程资源的，new_socket 不会被复制，所以 socket 对应的 FD，只有一个 new_socket 指向他。 如果此时我们仍然在这里关闭 new_socket，那么在线程再使用 new_socket 就会报错。如下信息： 123456789Exception in thread Thread-1:Traceback (most recent call last): File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py&quot;, line 926, in _bootstrap_inner self.run() File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py&quot;, line 870, in run self._target(*self._args, **self._kwargs) File &quot;/Users/mac/PycharmProjects/Month2/web_server.py&quot;, line 9, in handle_request recv_msg = new_socket.recv(1024).decode(&quot;utf-8&quot;)OSError: [Errno 9] Bad file descriptor 三、使用协程来实现并发 Web Server使用进程和线程来实现的并发 Web Server，当并发访问量很大时，资源消耗都很高。所以这里使用协程来实现并发服务器。 1234567891011121314151617181920212223242526272829import socketimport reimport geventfrom gevent import monkeymonkey.patch_all()from web_server import handle_requestdef main(): # 创建TCP SOCKET实例 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # # 设置重用地址 # tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址（默认本机IP）和端口 tcp_server_socket.bind((&quot;&quot;, 7890)) # 监听 tcp_server_socket.listen(128) # 循环接收客户端连接 while True: new_socket, client_addr = tcp_server_socket.accept() # 启动一个协程来处理客户端的请求 gevent.spawn(handle_request, new_socket) # 关闭整个SOCKET tcp_server_socket.close()if __name__ == &quot;__main__&quot;: main() 使用 gevent 来实现协程，并发处理请求。 四、使用单进程单线程非阻塞模拟实现高并发HTTP服务器前面我们使用的多进程和多线程来处理并发，是因为 socket.recv() 是阻塞的，每次 accept 一个连接，就需要交给一个新的进程或线程去处理，从而不影响下一个 socket 连接。 但是我们可以通过单进程单线程和非阻塞的方式来完成并发 socket 的处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import socketimport timeimport redef handle_request(new_socket, recv_msg): # 从请求中解析出URI recv_lines = recv_msg.splitlines() # 使用正则表达式提取出URI ret = re.match(r&quot;[^/]+(/[^ ]*)&quot;, recv_lines[0]) if ret: # 获取URI字符串 file_name = ret.group(1) # 如果URI是/，则默认返回index.html的内容 if file_name == &quot;/&quot;: file_name = &quot;/index.html&quot; try: # 根据请求的URI，读取相应的文件 fp = open(&quot;.&quot; + file_name, &quot;rb&quot;) except: # 找不到文件，响应404 response_msg = &quot;HTTP/1.1 404 NOT FOUND\\r\\n&quot; response_msg += &quot;\\r\\n&quot; response_msg += &quot;&lt;h1&gt;----file not found----&lt;/h1&gt;&quot; new_socket.send(response_msg.encode(&quot;utf-8&quot;)) else: html_content = fp.read() fp.close() response_body = html_content # 响应正确 200 OK response_header = &quot;HTTP/1.1 200 OK\\r\\n&quot; response_header += &quot;Content-Length:%d\\r\\n&quot; % len(response_body) response_header += &quot;\\r\\n&quot; response = response_header.encode(&quot;utf-8&quot;) + response_body # 返回响应数据 new_socket.send(response)def main(): # 创建TCP SOCKET实例 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置重用地址 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址（默认本机IP）和端口 tcp_server_socket.bind((&quot;&quot;, 7890)) # 监听 tcp_server_socket.listen(128) # 将accept设置为非阻塞,这里设置一次，后面不管调多少次accept都是非阻塞的 tcp_server_socket.setblocking(False) # 定义一个列表，将每次连接的socket加入该列表 client_socket_list = list() fd_to_addr = &#123;&#125; # 循环接收客户端连接 while True: time.sleep(0.5) try: new_socket, client_addr = tcp_server_socket.accept() except Exception as ret: # 当没有客户端链接的时候，抛出异常 pass else: print(&quot;客户端&#123;&#125; OnLine。。。。&quot;.format(client_addr)) # 当有客户端链接的时候 # 将new_socket.recv()设置为非阻塞的 new_socket.setblocking(False) # 将new_socket加入列表 client_socket_list.append(new_socket) # 将 conn 和 addr 信息分别保存起来 fd_to_addr[new_socket.fileno()] = client_addr # 遍历socket列表，检查每一个socket是否有数据到达，或者客户端是否断开 for client_socket in client_socket_list: try: recv_content = client_socket.recv(1024).decode(&quot;utf-8&quot;) except Exception as ret: # 异常，表示该客户端没有发数据过来 pass else: # 正常，表示客户端发了数据，或者客户端断开连接（断开连接会导致recv正常返回） if recv_content: # 有数据，调用请求处理代码 handle_request(client_socket, recv_content) else: print(&quot;客户端&#123;&#125;OffLine。。。。&quot;.format(fd_to_addr[client_socket.fileno()])) # recv正常返回，且数据为空，表示客户端断开了链接 # 将该socket踢出列表 client_socket_list.remove(client_socket) # 服务器也关闭连接 client_socket.close() # 关闭整个SOCKET tcp_server_socket.close()if __name__ == &quot;__main__&quot;: main() 上面代码主要是说明在单进程单线程情况下，如何将 accept 和 recv 分开，并且都用非阻塞的方式来处理，这样每次查看是否有客户端链接进来的时候，都会去检查所有已链接的 socket 是否有数据发送过来。 在这种方式中，我们使用单进程单线程模拟了并发处理 socket 连接的功能，但这些 socket 连接的处理不是并行的。当一个 socket 处理数据时间比较长时，也会造成整个程序的等待。 特别注意的是，在请求处理函数 handle_request 中，我们将请求内容作为参数一并传递进去。然后在返回 200 OK 的时候，在响应头中添加了 Content-Length 字段，这个字段用于告诉客户端，此次发送的响应体有多大。当客户端收完指定大小的数据，就认为这次服务器发送的数据已经发送完毕。他就可以继续发送下一个新的请求。 在 handle_request 中可以看到，new_socket.close() 已经被删除，也就是说服务器不会自动关闭连接，而直到客户端断开连接之前，服务器都保持长连接。断开连接由客户端来发起。 五、使用select实现高并发HTTP服务器在编写了单进程非阻塞式服务器之后，还有另外种写服务器的方法，便是利用select。select是对底层操作系统的一个访问操作，因而效率较高，比单进程非阻塞中的for循环遍历效率要高，可以利用select进行选择，选择出来可以读取信息的套接字、可以发送信息的套接字、以及产生的异常（分别是三个返回值）。 1readable, writable, exceptionable = select([], [], []) 以上即为select的使用方法，程序执行到该语句后进行阻塞等待，接收到新的套接字之后便解阻塞。程序思路便是利用select检测、选择出能读取的套接字（包括服务器套接字、客户端套接字），将接收到消息的客户端套接字存入列表（列表中本来只有服务器套接字），之后进行for循环遍历，读取套接字中的信息或者进行与客户端的连接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from socket import *from select import selectfrom web_server import handle_requestdef main(): # 创建套接字 server_socket = socket(AF_INET, SOCK_STREAM) # 设置可以重复使用绑定的信息 server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 绑定本机信息 server_socket.bind((&quot;&quot;, 8080)) # 主动监听 server_socket.listen(128) # 将accept设置为非阻塞 server_socket.setblocking(False) inputs = [server_socket] fd_to_addr = &#123;&#125; while True: readable, writable, exceptionable = select(inputs, [], []) for sock in readable: if sock == server_socket: clientSocket, clientAddr = server_socket.accept() # 当有客户端链接的时候 # 将new_socket.recv()设置为非阻塞的 clientSocket.setblocking(False) inputs.append(clientSocket) # 将 addr 信息保存起来 fd_to_addr[clientSocket.fileno()] = clientAddr print(&quot;客户端&#123;&#125; OnLine。。。。&quot;.format(clientAddr)) else: message = sock.recv(1024) if message: # print(&#x27;message from [%s] is %s&#x27; % (str(sock), message.decode(&#x27;utf-8&#x27;))) handle_request(sock, message.decode(&quot;utf8&quot;)) else: print(&#x27;[%s] OffLine。。。。&#x27; % (fd_to_addr[sock.fileno()])) inputs.remove(sock) sock.close()if __name__ == &#x27;__main__&#x27;: main() select版服务器有一定的缺点，便是只能处理1024个并发客户端，因而其效率还是有一定的局限性。 六、使用epoll实现高并发HTTP服务器我们在最后使用单进程+单线程+非阻塞+长连接实现了一个可并发处理客户端连接的服务器。他的原理可以用以下的图来描述： 解释： HTTP服务器是我们使用 单进程+单线程+非阻塞+长连接实现 的web服务器。 在实现的时候，我们创建了一个存放已接受Socket连接的列表，该列表是在应用程序的内存空间中的。如图中深蓝色部分 当有3个客户端接入的时候，列表中一共存在3个对应的socket句柄，分别对应三个小黄框。 灰色小框代表服务器接收请求的socket。 我们在进行无限循环的时候，首先是检查是否有新的客户端接入，相当于检查灰色小框是否有数据到达。然后轮询3个小黄框对应socket是否有数据到达。轮询的效率是很低的。 服务器在使用accept和recv时，实际上是委托操作系统帮他检查是否有数据到达，由于这个列表的socket都处于用户内存空间，所以需要将其复制到内核空间。操作系统检查完毕后，如果有数据就返回数据给应用程序，如果没有数据就以异常的方式通知应用程序。而且不光这样，操作系统可能还同时在运行其他的应用程序，这样效率会非常低。 我们再来看epoll的图： 解释： 1.我们可以看到，在结构上，最大的区别在于，存放socket的列表不处于应用程序内部。在epoll中，这个存放socket的列表处于一个特殊的内存空间，这个内存空间是应用程序与内核共享的空间。也就是说，当应用程序委托操作系统检查是否有数据到达时，无需将复制数据给内核空间，操作系统可以直接进行检查。 2.操作系统检查到某个socket有数据到达，使用事件通知的形式，直接告诉应用程序，而不是以轮询的方式。打个比方，一个厨师挨个问50个人饿了没，如果饿了就给他东西吃，这是轮询。而50个人中，谁饿了谁举手，厨师就给吃的，这叫事件通知。很明显，事件通知的效率会特别高。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from socket import *import selectfrom web_server import handle_requestdef main(): # 创建套接字 server_socket = socket(AF_INET, SOCK_STREAM) # 设置可以重复使用绑定的信息 server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 绑定本机信息 server_socket.bind((&quot;&quot;, 8080)) # 主动监听 server_socket.listen(128) # 将accept设置为非阻塞 server_socket.setblocking(False) # 创建epoll对象 epoll = select.epoll() # 注册事件到epoll中 # epoll.register(fd[, eventmask]) # 注意，如果fd已经注册过，则会发生异常 # 将创建的套接字添加到epoll的事件监听中 # 注册tcp套接字 epoll.register(server_socket.fileno(), select.EPOLLIN) &#x27;&#x27;&#x27;因为epoll返回的触发事件对应的是套接字文件描述符，所以需要在字典中加入对应关系&#x27;&#x27;&#x27; # 定义一个字典，用于存放fd和套接字的对应关系，因为操作系统在事件通知的时候，使用的是fd，而不是套接字，我们需要使用fd来找到对应 # 的套接字，从而可以调用accept和recv fd_to_socket = &#123;&#125; fd_to_addr = &#123;&#125; # 循环接收客户端连接 while True: # 使用一个列表来接受操作系统的事件通知，poll()是阻塞的，当有数据到达时，poll才会解开阻塞 epoll_list = epoll.poll() for fd, event in epoll_list: # 首先判断事件通知中的fd是否对应监听套接字（监听套接字调用accept） if fd == server_socket.fileno(): conn, addr = server_socket.accept() # 监听到一个新的客户端连接，将conn也注册到epoll中 epoll.register(conn.fileno(), select.EPOLLIN) print(&#x27;有新的客户端到来%s&#x27; % str(addr)) # 将 conn 和 addr 信息分别保存起来 fd_to_socket[conn.fileno()] = conn fd_to_addr[conn.fileno()] = addr else: # 如果不是监听套接字，那么都是客户端对应的套接字 # 接收数据 recvData = fd_to_socket[fd].recv(1024).decode(&#x27;utf8&#x27;) if recvData: handle_request(fd_to_socket[fd], recvData) # 如果没有数据，则表示客户端断开连接 else: # 从 epoll 中移除该 连接 fd epoll.unregister(fd) # 关闭fd对应的socket fd_to_socket[fd].close() print(&quot;%s---offline---&quot; % str(fd_to_addr[fd]))if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"网络通信","slug":"技术/网络通信","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"TCP","slug":"技术/网络通信/TCP","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCP/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://www.bookandmusic.cn/tags/TCP/"},{"name":"WEB Server","slug":"WEB-Server","permalink":"https://www.bookandmusic.cn/tags/WEB-Server/"},{"name":"高并发","slug":"高并发","permalink":"https://www.bookandmusic.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"网络通信-简单WEB服务器","slug":"网络通信-Simple Web Server","date":"2020-08-16T13:23:36.000Z","updated":"2021-01-25T02:59:22.000Z","comments":true,"path":"2020/08/16/wang-luo-tong-xin-simple-web-server/","link":"","permalink":"https://www.bookandmusic.cn/2020/08/16/wang-luo-tong-xin-simple-web-server/","excerpt":"本篇文章介绍如何实现一个简单 的Web Server 以及对应的问题解决方案。 一、如何使用Python实现一个返回固定页面的Web Server 使用socket创建一个TCP Server 接受来自浏览器的TCP链接，并接收HTTP请求 返回固定响应数据给浏览器","text":"本篇文章介绍如何实现一个简单 的Web Server 以及对应的问题解决方案。 一、如何使用Python实现一个返回固定页面的Web Server 使用socket创建一个TCP Server 接受来自浏览器的TCP链接，并接收HTTP请求 返回固定响应数据给浏览器 12345678910111213141516171819202122232425262728293031323334353637import socket, timedef handle_request(new_socket): # 接收请求 recv_msg = new_socket.recv(1024) print(recv_msg) # 响应数据 response_msg = &quot;HTTP/1.1 200 OK\\r\\n&quot; response_msg += &quot;\\r\\n&quot; response_msg += &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot; # 返回响应数据（二进制数据） time.sleep(1) new_socket.send(response_msg.encode(&quot;utf-8&quot;)) # 关闭该次socket连接 new_socket.close()def main(): # 创建TCP SOCKET实例 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 绑定地址（默认本机IP）和端口 tcp_server_socket.bind((&quot;&quot;, 8890)) # 监听 tcp_server_socket.listen(128) # 循环接收客户端连接 while True: new_socket, client_addr = tcp_server_socket.accept() # 处理每个客户端的请求 handle_request(new_socket) # 关闭整个SOCKET tcp_server_socket.close()if __name__ == &#x27;__main__&#x27;: main() 缺陷： 这种简单的web server是阻塞的，同时只能处理一个请求。 二、解决服务器端口占用问题问题描述：当浏览器访问服务器时，服务器收到请求，马上返回响应数据，并且调用了new_socket.close()。此时，马上重启服务器的话，可能会提示端口被占用。 这是因为TCP的四次挥手过程中，谁先发送FIN包，则谁会在发送最后一个ACK包后进入TIME_WAIT状态，此状态会等待2MSL的时间（大概2-4分钟）。在这个阶段，服务器绑定的端口资源是被占用的。等这个阶段过了，端口会进入CLOSED状态，则可以被再次利用。 如何解决服务器重启端口被占用的问题： 1234567891011121314151617def main(): # 创建TCP SOCKET实例 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置重用地址 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址（默认本机IP）和端口 tcp_server_socket.bind((&quot;&quot;, 7890)) # 监听 tcp_server_socket.listen(128) # 循环接收客户端连接 while True: new_socket, client_addr = tcp_server_socket.accept() # 处理每个客户端的请求 handle_request(new_socket) # 关闭整个SOCKET tcp_server_socket.close() 在创建socket实例之后，设置可以重用地址，就可以解决报错问题。 三、TCP协议3次握手、4次挥手 三次握手： 三次握手流程和目的都相对简单： 客户端向服务器发送SYN flag的包，并携带seq为x。 服务器收到SYN包后，开始准备对应的资源，准备好后，发送SYN+ACK包，这实际上是服务器回应客户端的ACK包，合并了服务器让客户端准备资源的SYN包。所以携带了对应SYN的seq y，以及ACK=x+1。 客户端收到服务器发来的SYN包，则回复ACK包，ack=y+1。 这样3次握手就建立好了，客户端和服务器都进入ESTABLISHED状态，表示资源都准备完毕。所以TCP的三次握手实际上是客户端与服务器之间互相要求准备资源以及回复资源已准备好的过程。 理论上应该是4次握手，但为了增加性能减小时间开销，中间的两次数据传输（服务器发送的SYN和ACK）合并在一起了。所以变成了3次握手。 四次挥手： 四次挥手相对比较复杂： 假设客户端在完成数据传输后，首先开始发送FIN包（也就是我们的客户端程序调用socket.close()的时候，系统底层会自动发送FIN包），则表示客户端已经没有需要发送给服务器的数据。由于SOCKET是全双工的，所以客户端发送FIN只是表示客户端以后都不在发送数据，但此时还可以接收数据。 客户端发送出FIN包后，就会进入FIN WAIT-1状态，该状态一般很难观测到，因为该状态只维持到服务器响应ACK包，一般情况下都是瞬间就返回了（注意这里和3次握手不同，这里的ACK包不能与服务器发送的FIN包合并，因为服务器可能还有数据要继续发送给客户端，所以服务器可能要等到数据传输完毕才会向客户端发送FIN包，这就是为什么是四次挥手） 服务器收到客户端发来的FIN包，则马上发送回应的ACK包，此包没有意外的话，会瞬间到达客户端。 客户端收到ACK包后，结束FIN WAIT-1状态，进入FIN WAIT-2状态，该状态的目的是等待服务器发送FIN包。 服务器完成了最后的数据发送，则向客户端发送FIN包（也就是服务器程序调用socket.close()的时候，系统底层会自动发送FIN包），表示服务器以后也没有数据要发送了，开始断开服务器的发送通道。 服务器在发送出FIN后，会进入LAST-ACK状态（例如等待4s）。这个状态是为了等待客户端恢复确认的ACK包，因为服务器发送出去的FIN包，他无法确认客户端是否收到，如果超出waittime还未收到ACK包，则重新发送FIN包。 客户端如果正确收到了服务器发送的FIN包，理论上应该释放资源，并发送ACK包。但是如果客户端发出的ACK包由于某些原因，服务器并未收到，那么服务器在几秒后会重新发送FIN包，但客户端已经把资源释放掉了，则就会出现问题。怎么解决这个问题呢？解决方案是，客户端收到服务器发送的FIN包，并不马上释放资源（例如绑定的端口等），而是先回复ACK包，并进入TIME-WAIT状态，这个状态要持续2MSL（2-3分钟）。如果在2MSL时间段中，服务器都没有重新发送FIN包，则表示服务器已经收到了自己发出的ACK包，这是客户端才放心的释放资源。 最终客户端在等待2MSL后，进入CLOSED状态。服务器在确认收到最后一个ACK包后直接进入CLOSED状态。 资源占用的解释： 我们知道，客户端是使用随机端口来发起TCP连接的，所以客户端首先发送FIN包的话，最后的2MSL是由客户端来等待，即使2-3分钟资源未被释放，也不会影响客户端另外发起新的请求（因为可用的随机端口很多，不会出现冲突）。 但是如果由服务器来首先发起FIN，则最后的2MSL要由服务器来等待，则在2-3分钟内，服务器绑定的端口并未被释放，所以如果此时重启服务器，则会出现资源未释放、端口被占用的情况。 结论：尽量让客户端来发起断开连接的请求。如果要使服务器断开请求还不会出现占用端口的情况，则可以参考前面第二节的方法，为服务器SOCKET设置资源重用的属性。 四、改善简单WEB Server前面我们实现的简单Web Server不管客户端请求的URI是什么，我们都只能返回固定的&quot;Hello“字符串。我们对其进行改善，让其根据接收到的请求，来返回不同的页面数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import socketimport redef handle_request(new_socket): # 接收请求 recv_msg = &quot;&quot; recv_msg = new_socket.recv(1024).decode(&quot;utf-8&quot;) if recv_msg == &quot;&quot;: print(&quot;recv null&quot;) new_socket.close() return # 从请求中解析出URI recv_lines = recv_msg.splitlines() print(recv_lines) # 使用正则表达式提取出URI ret = re.match(r&quot;[^/]+(/[^ ]*)&quot;, recv_lines[0]) if ret: # 获取URI字符串 file_name = ret.group(1) # 如果URI是/，则默认返回index.html的内容 if file_name == &quot;/&quot;: file_name = &quot;/index.html&quot; try: # 根据请求的URI，读取相应的文件 fp = open(&quot;.&quot; + file_name, &quot;rb&quot;) except: # 找不到文件，响应404 response_msg = &quot;HTTP/1.1 404 NOT FOUND\\r\\n&quot; response_msg += &quot;\\r\\n&quot; response_msg += &quot;&lt;h1&gt;----file not found----&lt;/h1&gt;&quot; new_socket.send(response_msg.encode(&quot;utf-8&quot;)) else: html_content = fp.read() fp.close() # 响应正确 200 OK response_msg = &quot;HTTP/1.1 200 OK\\r\\n&quot; response_msg += &quot;\\r\\n&quot; # 返回响应头 new_socket.send(response_msg.encode(&quot;utf-8&quot;)) # 返回响应体 new_socket.send(html_content) # 关闭该次socket连接 new_socket.close()def main(): # 创建TCP SOCKET实例 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # # 设置重用地址 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址（默认本机IP）和端口 tcp_server_socket.bind((&quot;&quot;, 7890)) # 监听 tcp_server_socket.listen(128) # 循环接收客户端连接 while True: new_socket, client_addr = tcp_server_socket.accept() # 处理每个客户端的请求 handle_request(new_socket) # 关闭整个SOCKET tcp_server_socket.close()if __name__ == &quot;__main__&quot;: main() 以上代码重点在于解析出GET /index.html HTTP/1.1中的/index.html部分，知道服务器要请求什么内容，然后按需找到对应的文件，已二进制方式读取文件内容并返回给客户端即可。 如果客户端没有指定访问的内容，则默认返回index.html页面。 注意异常的处理。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"网络通信","slug":"技术/网络通信","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"TCP","slug":"技术/网络通信/TCP","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCP/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://www.bookandmusic.cn/tags/TCP/"},{"name":"WEB Server","slug":"WEB-Server","permalink":"https://www.bookandmusic.cn/tags/WEB-Server/"}]},{"title":"网络通信-长连接与短连接","slug":"网络通信-长连接与短连接","date":"2020-08-16T10:27:27.000Z","updated":"2021-01-25T02:59:18.000Z","comments":true,"path":"2020/08/16/wang-luo-tong-xin-chang-lian-jie-yu-duan-lian-jie/","link":"","permalink":"https://www.bookandmusic.cn/2020/08/16/wang-luo-tong-xin-chang-lian-jie-yu-duan-lian-jie/","excerpt":"","text":"简单介绍长连接与短连接的优缺点。 1. 短连接： client 向 server 发起连接请求 server 接到请求，双方建立连接 client 向 server 发送消息 server 回应 client 一次读写完成，此时双方任何一个都可以发起 close 操作 2. 长连接： client 向 server 发起连接 server 接到请求，双方建立连接 client 向 server 发送消息 server 回应 client 一次读写完成，连接不关闭 后续读写操作… 长时间操作之后 client 发起关闭请求 3. 优缺点分析 长连接可以省去较多的 TCP 建立和关闭的操作，节约时间。但是如果用户量太大容易造成服务器负载过高最终导致服务不可用 短连接对于服务器来说实现起来较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但是如果用户访问量很大, 往往可能在很短时间内需要创建大量的连接，造成服务器响应速度过慢 4. 总结 小的 WEB 网站的 http 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源来让套接字保持存活。 对于中大型 WEB 网站一般都采用长连接，好处是响应用户请求的时间更短，用户体验更好，虽然更耗硬件资源一些，但这都不是事儿。另外，数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"网络通信","slug":"技术/网络通信","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"TCP","slug":"技术/网络通信/TCP","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCP/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://www.bookandmusic.cn/tags/TCP/"},{"name":"短连接","slug":"短连接","permalink":"https://www.bookandmusic.cn/tags/%E7%9F%AD%E8%BF%9E%E6%8E%A5/"},{"name":"长连接","slug":"长连接","permalink":"https://www.bookandmusic.cn/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"}]},{"title":"RESTful规范的API接口设计","slug":"web-RESTful 规范的 API 接口设计","date":"2020-08-14T12:38:26.000Z","updated":"2021-01-23T15:09:50.000Z","comments":true,"path":"2020/08/14/web-restful-gui-fan-de-api-jie-kou-she-ji/","link":"","permalink":"https://www.bookandmusic.cn/2020/08/14/web-restful-gui-fan-de-api-jie-kou-she-ji/","excerpt":"","text":"在项目中，需要为 APP 撰写 API。刚开始接触的时候，并没有考虑太多，就想提供 URL，APP 端通过该 URL 进行查询、创建、更新等操作即可。但再对相关规范进行了解后，才发现，API 的设计并没有那么简单，远远不是 URL 的问题，而是一个通信协议的整体架构。 使用 SSL（https）来提供 URL 首先，使用 https 可以在数据包被抓取时多一层加密。 我们现在的 APP 使用环境大部分都是在路由器 WIFI 环境下，一旦路由器被入侵，那么黑客可以非常容易的抓取到用户通过路由器传输的数据，如果使用 http 未经加密，那么黑客可以很轻松的获取用户的信息，甚至是账户信息。 其次，即使使用 https，也要在 API 数据传输设计时，正确的采用加密。 例如直接将 token 信息放在 URL 中的做法，即使你使用了 https，黑客仅能抓到域名字符部分，不能抓到请求的数据，但是 URL 可以在浏览器或特殊客户端工具中直接看到。因此，使用 https 进行请求时，要采用 POST、PUT 或者 HEAD 的方式传输必要的数据。 使用 GET、POST、PUT、DELETE 这几种请求模式请求模式也可以说是动作、数据传输方式，通常我们在 web 中的 form 有 GET、POST 两种。 而在 HTTP 中，存在以下这几种。 请求方式 功能 GET（选择） 从服务器上获取一个具体的资源或者一个资源列表。 POST（创建） 在服务器上创建一个新的资源。 PUT（更新） 以整体的方式更新服务器上的一个资源。 PATCH （更新） 只更新服务器上一个资源的一个属性。 DELETE（删除） 删除服务器上的一个资源。 HEAD 获取一个资源的元数据，如数据的哈希值或最后的更新时间。 OPTIONS 获取客户端能对资源做什么操作的信息。 在 URI 中体现资源，而非动作阅读 RESTful 架构的参考文献之后，你会了解什么是资源的概念，以及 REST 的确切含义。再构建 API 的 URL 的时候，URI 中应该仅包含资源（对象），而不要加入动作。 比如 /user/1/update ，其中 update 就是一个动作，虽然我们希望通过这个 URI 来实现用户 ID 为 1 的用户进行信息更新，但是按照 RESTful 的规范，update作为动作，应该用上面的 PUT 来表示，所以请求更新用户信息，应该使用 PUT /user/1 来表示更新用户 ID 为 1 的用户信息。 如果去对应上面的请求模式： GET 表示显示、列出、展示 POST 表示提交、创建 PUT 表示更新 DELETE 表示删除 版本API 的开发直接关系了 APP 是否可以正常使用，如果原本运行正常的 API，突然改动，那么之前使用这个 API 的 APP 可能无法正常运行。APP 是不可能强迫用户主动升级的，因此，通过 API 版本来解决这个问题。也就是说，API 的多个版本是同时运行的，而且都要保证可以正常使用。 按照 RESTful 的规范，不同的版本也应该用相同的 API URL，通过 header 信息来判断版本，再调用不同版本的程序进行处理。但是这明显会给开发带来巨大的成本。 解决办法有两种： 新版本兼容旧版本，所有旧版本的动作、字段、操作，都在新版本中可以被实现，但明显这样的维护成本很大； 不同的版本，用不同的 URL 来提供服务，比如在 URL 中通过 v1、v2 来区分版本号，或者采用子域名的方式，比如 v2.api.xxx.com/user 的方式。 HTTP 响应码在用户发出请求，服务端对请求进行响应时，给予正确的 HTTP 响应状态码，有利于让客户端正确区分遇到的情况。 状态码 请求方式 描述 200 [GET] （OK成功）服务器成功返回用户请求的数据,该操作是幂等的（Idempotent） 201 [POST/PUT/PATCH] （CREATED已建立）用户新建或修改数据成功 202 [*] (Accepted接受请求)表示一个请求已经进入后台排队（异步任务） 204 [DELETE] (NO CONTENT无内容) 用户删除数据成功 300 （Multiple Choices多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （Permanently Moved永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （Temporarily Moved临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （See Other查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码 304 （Not Modified未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 （Use Proxy使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 Temporary Redirect（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 400 [POST/PUT/PATCH] INVALID REQUEST(坏请求) 用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 [*] Unauthorized (未授权) 表示用户没有权限（令牌、用户名、密码错误） 403 [*] Forbidden （禁止）表示用户得到授权（与401错误相对），但是访问是被禁止的 404 [*] NOT FOUND （未找到）用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 405 Method not allowed（方法不被允许）不支持该Request的方法 406 Not Acceptable（无法接受）无法使用请求的内容特性来响应请求的网页，也就是后台的返回结果前台无法解析（比如用户请求 JSON 格式，但是只有 XML 格式） 407 Proxy Authentication Required（要求进行代理认证）与状态码401类似， 用于需要进行认证的代理服务器. 408 Request Timeout(请求超时) 如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接 410 [GET] Gone （过去的）用户请求的资源被永久删除，且不会再得到的 422 [POST/PUT/PATCH] Unprocesable entity （不可处理）当创建一个对象时，发生一个验证错误 500 [*] INTERNAL SERVER ERROR(服务器内部错误）服务器发生错误，用户将无法判断发出的请求是否成功 返回值结构在完成了上面的 URL 部署之后，接下来我们来看看返回结果应该怎么样来确定。 我看到大部分文献中指出，最好使用 JSON 进行返回，而非 xml。 我认为原因可能有两点： JSON 可以很好的被很多程序支持，javascript 的 ajax 可以直接将 JSON 转换为对象。 JSON 的格式在容量上比 xml 小很多，可以减低宽带占用，提高传输效率。 那么，返回值应该怎么去部署呢？ 首先，字段的合理返回，数据的包裹。因为返回值中，我们常常要对数据进行区分分组，或者按照从属关系打包，所以，我们再返回时，最好有包裹的思想，把数据存放在不同的包裹中进行返回。 12345678&#123; &#x27;error_code&#x27;: 0, &#x27;data&#x27;: &#123; &#x27;user_id&#x27;: 1, &#x27;username&#x27;: &#x27;xiaomin&#x27; &#125;, &#x27;server_time&#x27;: 14939939&#125; 上面返回的 JSON 中，使用 data 来作为数据包，将所有数据统一以这个字段进行包裹。除了 data，也可以用 list 等其他形式的包裹，命名都是自己来根据自己的需要确定的。 12345678&#123; &#x27;error_code&#x27;: 0, &#x27;list&#x27;: [ &#123;&#x27;user_id&#x27;: 1, &#x27;username&#x27;: &#x27;xiaoming&#x27;&#125;, &#123;&#x27;user_id&#x27;: 2, &#x27;username&#x27;: &#x27;goudan&#x27;&#125; ] &#x27;server_time&#x27;: 14939939&#125; 总之，不要不分包，直接把所有数据和一些你想返回的全局数据混在一起进行返回。 其次，错误码。错误码的作用是方便查找错误原因，通常情况下，可以用 error_code 来表示，当 error_code=0 时，表示没有发生错误，当 error_code&gt;0 时，发生了错误，并且提供较为详细的文档，告诉客户端对应的 error_code 值所产生的错误的原因和位置。 最后，空白压缩和字符转换。也就是返回的 JSON 结果不要换行和空格，用一行返回结果，使整个结果文本容量最小。同时，中文等字符或结果中有引号，都进行字符转换，防止结果无法被正确识别。 鉴权其实也就是客户端的权限控制。一般而言，会给客户端分发一个 token 来确定该客户端的唯一身份。客户端在请求时，通过这个 token，判断发出请求的客户端所对应的用户，及其相关信息和权限。 前文已经提到了，token 信息不是用来进行处理的数据，虽然可以通过 POST、PUT 等进行数据提交或传输，但是从 RESTful 规范来讲，它不属于操作数据，在服务端进行处理时，仅是利用 token 进行鉴权处理，所以，我的建议是通过 header 来发送 token。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"web","slug":"技术/python/web","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/web/"}],"tags":[{"name":"API","slug":"API","permalink":"https://www.bookandmusic.cn/tags/API/"},{"name":"RESTful","slug":"RESTful","permalink":"https://www.bookandmusic.cn/tags/RESTful/"}]},{"title":"python内存管理","slug":"python高级-内存管理","date":"2020-07-30T13:53:24.000Z","updated":"2021-01-23T14:53:26.000Z","comments":true,"path":"2020/07/30/python-gao-ji-nei-cun-guan-li/","link":"","permalink":"https://www.bookandmusic.cn/2020/07/30/python-gao-ji-nei-cun-guan-li/","excerpt":"","text":"内存管理机制 Python中不但变量名无需事先声明，而且也无需类型声明。在Python语言中，对象的类型和内存占用都是运行时确定的。在赋值时解释器会根据语法和右侧的操作数来决定新对象的类型。在对象创建后，一个该对象的引用会被赋值给左侧的变量。 id()函数 python的内置函数 id()可以用来查看对象的内存地址 1234567891011121314&gt;&gt;&gt; a = 1&gt;&gt;&gt; id(a)24834392&gt;&gt;&gt; a = &#x27;banana&#x27;&gt;&gt;&gt; id(a)139990659655312&gt;&gt;&gt; a = 3&gt;&gt;&gt; b = 3&gt;&gt;&gt; id(a)10289448&gt;&gt;&gt; id(b)10289448 引用计数 要保持追踪内存中的对象，Python使用了引用计数这一简单技术。 也就是说Python内部记录着所有使用中的对象各有多少引用。 一个内部跟踪变量，称为引用计数器。 每个对象各有多少个引用，简称引用计数。 当对象被创建时，就创建了一个引用计数，当这个对象不再需要时，也就是说，这个对象的引用计数变为0时，它通常会被垃圾回收。 增加引用计数 减少引用计数 is和==在讲is和==这两种运算符区别之前，首先要知道Python中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。 is和==都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。 is也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同。 ==是python标准操作符中的比较操作符，用来比较判断两个对象的value(值)是否相等 可变类型与不可变类型 list、dict、set属于可变类型 number、str、tuple、bool属于不可变类型 不可变数据类型在第一次声明赋值声明的时候, 会在内存中开辟一块空间, 用来存放这个变量被赋的值, 而这个变量实际上存储的, 并不是被赋予的这个值, 而是存放这个值所在空间的内存地址, 通过这个地址, 变量就可以在内存中取出数据了. 所谓不可变就是说, 我们不能改变这个数据在内存中的值, 所以当我们改变这个变量的赋值时, 只是在内存中重新开辟了一块空间, 将这一条新的数据存放在这一个新的内存地址里, 而原来的那个变量就不在引用原数据的内存地址而转为引用新数据的内存地址了。 结合不可变数据类型，可变数据类型就很好理解来，可变数据类型是指变量所指向的内存地址处的值是可以被改变的。 从另外一个角度来看： 可变类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。 可变数据类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。 内存管理优化Python采用基于值的内存管理模式，相同的值在内存中只有一份。这是很多Python教程上都会提到的一句话，但实际情况要复杂的多。什么才是值？什么样的值才会在内存中只保存一份？这是个非常复杂的问题。 在python交互环境中首先明确一点，整数、实数、字符串是真正意义上的值，而上面那句话中的“值”主要指不可变类型中的整数和字符串。对于列表、元组、字典、集合以及range对象、map对象等容器类对象，它们不是普通的“值”，即使看起来是一样的，在内存中也不会只保存一份。 整数123456In [51]: a = 12In [52]: b = 12In [53]: a is bOut[53]: True python中对于小的整数存在一个缓存池。为了避免因创建相同的值而重复申请内存空间所带来的效率问题， Python解释器会在启动时创建出小整数池，范围是[-5,256]，该范围内的小整数对象是全局解释器范围内被重复使用，永远不会被垃圾回收机制回收。 实数123456In [8]: a = 12.5In [9]: b = 12.5In [10]: a is bOut[10]: False 对于实数，由于计算机存储实数会有精度问题，很难精确存储，所以不进行缓存，也就是说，即使看起来是一样的实数，在内存中也不是一份。 字符串12345678910111213In [63]: a = &quot;abc123_&quot;In [64]: b = &quot;abc123_&quot;In [65]: a is bOut[65]: TrueIn [66]: a = &quot;12 3&quot;In [67]: b = &quot;12 3&quot;In [68]: a is bOut[68]: False 由于变量的存储机制，python增加了字符串的intern机制。也就是说，值同样的字符串对象（整数也使用）仅仅会保存一份，是共用的，这也决定了字符串必须是不可变对象。 1234567891011121314151617181920In [70]: c = &quot;a&quot; + &quot;b&quot; # 在 compile-time（编译时）已经求完值，被替换成了&#x27;ab&#x27;, In [71]: id(c)Out[71]: 4489029232In [72]: d = &quot;ab&quot; # 此时，内存中已经有 &#x27;ab&#x27;, 因此直接引用即可In [73]: id(d)Out[73]: 4489029232 In [74]: id(a + &quot;b&quot;) # 在run-time（运行时）拼接的，导致没有被主动internOut[74]: 4519083312 In [75]: a = &#x27;hello world&#x27;In [76]: b = &#x27;hello world&#x27;In [77]: a is b # intern机制仅仅对那些看起来像是Python标识符的字符串对象才会触发Out[77]: False intern机制 优点：在创建新的字符对象时，如果内存中已经存在，则直接引用，避免频繁的创建和销毁内存，提升效率。 缺点：在拼接字符串时，或者在改动字符串时会极大的影响性能。原因是字符串在Python当中是不可变对象，所以对字符串的改动不是inplace（原地）操作，需要新开辟内存地址，新建对象。这也是为什么拼接字符串的时候不建议用+而是用join()。join()是先计算出全部字符串的长度，然后再一一拷贝，仅仅创建一次对象。 总结 单词，即Python标识符，不可修改，默认开启intern机制，共用对象，引用计数为0时自动被回收。 字符串（包含了除Python标识符以外的字符），不可修改，默认没有开启intern机制，引用计数为0时自动被回收。 特殊情况下（动态拼接），不会被主动intern。 元组123456In [4]: a = (1, 2)In [5]: b = (1, 2)In [6]: a is bOut[6]: False 对于元组等容器类对象，它们不是普通的“值”，即使看起来是一样的，在内存中也不会只保存一份。 在Python代码中在同一模块文件中，不可变类型的数字、字符串、元组， 在值相同时，只会保存一份;而不同模块中的不同值，才会重新生成。 模块 bbb.py 12345c1 = 1000c2 = &quot;hello world % &quot;c3 = (1, 2)c4 = 12.3 模块 aaa.py 12345678910111213141516171819202122from bbb import *a = 1000b = 1000print(a is b) # Trueprint(a is c1) # Falsea = &quot;hello world % &quot;b = &quot;hello world % &quot;print(a is b) # Trueprint(a is c2) # Falsea = (1, 2)b = (1, 2)print(a is b) # Trueprint(a is c3) # Falsea = 12.3b = 12.3print(a is b) # Trueprint(a is c4) # False 引用计数+标记清理+分代回收","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"系统","slug":"技术/python/系统","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"引用计数","slug":"引用计数","permalink":"https://www.bookandmusic.cn/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"name":"分代回收","slug":"分代回收","permalink":"https://www.bookandmusic.cn/tags/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6/"},{"name":"标记清除","slug":"标记清除","permalink":"https://www.bookandmusic.cn/tags/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4/"}]},{"title":"DRF-序列化与反序列化","slug":"DRF-序列化与反序列化","date":"2020-07-08T02:26:57.000Z","updated":"2021-01-25T14:15:59.000Z","comments":true,"path":"2020/07/08/drf-xu-lie-hua-yu-fan-xu-lie-hua/","link":"","permalink":"https://www.bookandmusic.cn/2020/07/08/drf-xu-lie-hua-yu-fan-xu-lie-hua/","excerpt":"","text":"DRF内置的序列化类，可以对整个模型类进行序列化与反序列化，简化了繁杂的工作。 内置字段序列化模型类123456789101112131415161718192021222324252627282930from django.db import models# Create your models here.class Authors(models.Model): name = models.CharField(max_length=10, verbose_name=&#x27;姓名&#x27;) def __str__(self): return self.name class Meta: db_table = &#x27;db_authors&#x27; verbose_name = &#x27;作者&#x27; verbose_name_plural = &#x27;作者&#x27;class Books(models.Model): title = models.CharField(max_length=10, verbose_name=&#x27;标题&#x27;) price = models.DecimalField(max_digits=7, decimal_places=2, verbose_name=&#x27;单价&#x27;) publish = models.CharField(max_length=20, verbose_name=&#x27;出版社&#x27;) author = models.ForeignKey(Authors, on_delete=models.CASCADE) def __str__(self): return self.title class Meta: db_table = &#x27;db_books&#x27; verbose_name = &#x27;图书&#x27; verbose_name_plural = &#x27;图书&#x27; 序列化类字段默认方式序列化 全部字段都采用 ModelSerializer的默认方式实现序列化与反序列化，外键对应的序列化值是外键id 1234567891011121314151617from rest_framework.serializers import ModelSerializerfrom .models import Books, Authorsclass AuthorsSerializer(ModelSerializer): class Meta: model = Authors fields = &#x27;__all__&#x27; class BooksSerializer(ModelSerializer): class Meta: model = Books fields = &#x27;__all__&#x27; 字段指定方式序列化 对模型类的外键关联字段通过 其他方式，实现序列化，其他字段仍然使用 默认方式实现序列化 外键字段内置方式序列化图书类序列化 1234567891011121314151617181920from rest_framework.serializers import ModelSerializerfrom .models import Books, Authorsfrom rest_framework import serializersclass BooksSerializer(ModelSerializer): # author = serializers.PrimaryKeyRelatedField(read_only=True) # 内置关联字段，默认序列化方式，关联对象的主键 # author = serializers.StringRelatedField(read_only=True) # 内置关联字段，此字段将被序列化为关联对象的字符串表示方式（即__str__方法的返回值） # author = serializers.HyperlinkedRelatedField(view_name=&#x27;authors-detail&#x27;, read_only=True) # 内置关联字段，此字段被序列化为关联对象的路由地址 # author = serializers.SlugRelatedField(read_only=True, slug_field=&#x27;id&#x27;) # 内置关联字段，指定关联对象的字段 # author = serializers.CharField(source=&#x27;author.name&#x27;, read_only=True) # 指定关联对象的字段 author = AuthorsSerializer() # 将关联对象所有字段全部序列化 class Meta: model = Books fields = &#x27;__all__&#x27; 作者类序列化 12345678910111213141516from rest_framework.serializers import ModelSerializerfrom .models import Books, Authorsfrom rest_framework import serializersclass AuthorsSerializer(ModelSerializer): # books_set = serializers.PrimaryKeyRelatedField(read_only=True, many=True) # books_set = serializers.StringRelatedField(read_only=True, many=True) # books_set = serializers.HyperlinkedRelatedField(view_name=&#x27;books-detail&#x27;, read_only=True, many=True) # books_set = BookSerializer(read_only=True, many=True) # books_set = BookRelateField(read_only=True, many=True) # 自定义关联字段 class Meta: model = Authors fields = &#x27;__all__&#x27; 外键字段自定义方式序列化1234567891011121314151617181920212223242526272829from rest_framework.serializers import ModelSerializerfrom .models import Books, Authorsfrom rest_framework import serializersclass BookRelateField(serializers.RelatedField): def to_representation(self, value): return &#x27;Author: &#123;&#125;&#x27;.format(value)class AuthorsSerializer(ModelSerializer): books_set = BookRelateField(read_only=True, many=True) # 自定义关联字段 class Meta: model = Authors fields = &#x27;__all__&#x27;class AuthorRelateField(serializers.RelatedField): def to_representation(self, value): return &#x27;Author: &#123;&#125; &#123;&#125;&#x27;.format(value.id, value.name)class BooksSerializer(ModelSerializer): author = AuthorRelateField(read_only=True) # 自定义关联字段 class Meta: model = Books fields = &#x27;__all__&#x27; 以上序列化方式，任选其一均可，但是注意，此时只能保证序列化成功，不能保证反序列化 自定义字段序列化 通过上面的例子可以看出：将外键字段通过其他方式序列化，可以得到不通类型的数据；但是大多数情况，不能实现反序列化。因此，可以在序列化时，不修改外键字段，而是自己构建新字段。最大好处, 在于将序列化字段与反序列化字段分离，互不影响。 修改模型类需要在模型类中用@property来实现，可插拔 模型类123456789101112131415161718class Books(models.Model): title = models.CharField(max_length=10, verbose_name=&#x27;标题&#x27;) price = models.DecimalField(max_digits=7, decimal_places=2, verbose_name=&#x27;单价&#x27;) publish = models.CharField(max_length=20, verbose_name=&#x27;出版社&#x27;) author = models.ForeignKey(Authors, on_delete=models.CASCADE) @property # 插拔字段 - 默认为read_only(不需要考虑反序列化)，且不能修改 def author_name(self): return self.author.name @property def author_info(self): from .serializers import AuthorsSerializer return AuthorsSerializer(self.author).data def __str__(self): return self.title 序列化类123456789101112class BooksSerializer(ModelSerializer): class Meta: model = Books fields = (&#x27;id&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;author&#x27;, &#x27;author_name&#x27;, &#x27;author_info&#x27;) extra_kwargs = &#123; &#x27;author&#x27;: &#123; &#x27;write_only&#x27;: True &#125; &#125; 修改序列化类 模型类不变，只在序列化器中添加序列化字段 序列化类1234567891011121314151617181920212223class BooksSerializer(ModelSerializer): author_url = serializers.HyperlinkedIdentityField(view_name=&#x27;authors-detail&#x27;, read_only=True) # 内置序列化方式，关联对象的路由地址 author_name = serializers.SerializerMethodField() # author_name 字段在数据库中不能存在，下面写方法的时候前面加 get_ 就可以，这样就得到我们需要的数据了。 @staticmethod def get_author_name(obj): &quot;&quot;&quot; 固定写法,obj代表Books实例对象,模型类配置了反向引用author代表作者对象 &quot;&quot;&quot; return obj.author.id class Meta: model = Books fields = (&#x27;id&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;author&#x27;, &#x27;author_name&#x27;, &#x27;author_url&#x27;) extra_kwargs = &#123; &#x27;author&#x27;: &#123; &#x27;write_only&#x27;: True &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"DRF","slug":"技术/python/DRF","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/DRF/"}],"tags":[{"name":"序列化","slug":"序列化","permalink":"https://www.bookandmusic.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"反序列化","slug":"反序列化","permalink":"https://www.bookandmusic.cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"python递归函数","slug":"python函数-递归函数","date":"2020-06-06T03:16:01.000Z","updated":"2021-01-23T14:59:58.000Z","comments":true,"path":"2020/06/06/python-han-shu-di-gui-han-shu/","link":"","permalink":"https://www.bookandmusic.cn/2020/06/06/python-han-shu-di-gui-han-shu/","excerpt":"","text":"定义函数调用函数自身，这种方式称为递归，这种函数称为递归函数 递归函数使用过程中，需要找到不变的规律和停止递归的边界条件， 因为函数自身调用自身，函数本身的结构不变，只是每次传的参数改变啦 递归实现过程(扩展)：利用栈的思想，先找边界条件，同时将后面的任务存起来，一直到最前面的边界条件，然后回去，每次从栈中取任务，进行计算，一直到最后一个任务取完，结果也计算完毕 递归过程: 递归前进段 递归边界条件 递归返回段 案例讲解递归实现吸烟问题吸烟有危害，不仅仅危害人体健康，还会对社会产生不良的影响。吸烟还很容易引起喉头炎、气管炎，肺气肿等问题； 那么现在假设人一生抽烟10000根达到极限峰值，再抽一根烟就像压倒骆驼的最后一根稻草，会使人体爆发疾病问题； 每天一个人抽烟的个数都比前天多一根（第一天抽一根），且一周只有工作日（周一~周五）会吸烟； 请使用递归的方式求出一个人按照以上方式抽烟达到10000根，爆发疾病需要历经多少天 1234567891011121314151617181920212223def smoker(day, count, amount): &quot;&quot;&quot; 递归解决吸烟问题 :param day: 当前的天数 :param count: 当天的吸烟数量 :param amount: 总计的吸烟数量 :return: 吸到10000根烟的天数 &quot;&quot;&quot; if amount &gt;= 10000: # 如果吸烟总数大于10000， 返回天数 return day else: day += 1 # 每吸一次烟，天数加1 if day % 7 != 6 and day % 7 != 0: # 只有周六，周日不吸烟，判断不是周六，也不是周日 count += 1 # 当天吸烟的数量 amount += count # 目前为止，吸烟的总数量 return smoker(day, count, amount)print(smoker(1, 1, 1)) # 第1天，吸了1根烟，总共吸了1根烟 青蛙跳台阶问题汉诺塔问题青蛙过河问题","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"递归函数","slug":"递归函数","permalink":"https://www.bookandmusic.cn/tags/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"}]},{"title":"python匿名函数","slug":"python函数-匿名函数","date":"2020-06-06T03:14:42.000Z","updated":"2021-01-23T15:01:10.000Z","comments":true,"path":"2020/06/06/python-han-shu-ni-ming-han-shu/","link":"","permalink":"https://www.bookandmusic.cn/2020/06/06/python-han-shu-ni-ming-han-shu/","excerpt":"","text":"语法匿名函数的另一个别称是lambda表达式 lambda表达式的语法： 1lambda argument_list: expression argument_list是参数列表。它的结构与Python中函数(function)的参数列表是一样的。 expression是一个关于参数的表达式。表达式中出现的参数需要在argument_list中有定义，并且表达式只能是单行的。 示例12345678910111213141516# lambda x: x*x# 这个lambda表达式实际等同于：# def f(x):# return x*xIn [15]: f = lambda x: x * xIn [16]: fOut[16]: &lt;function __main__.&lt;lambda&gt;(x)&gt;In [17]: f(5)Out[17]: 25 In [24]: x2 = lambda *args: [x**2 for x in list(args)]In [25]: x2(1, 2, 3, 4, 5, 6, 7)Out[25]: [1, 4, 9, 16, 25, 36, 49] 匿名函数作为参数 123456789In [7]: s = [x for x in range(10)]In [8]: sOut[8]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [9]: s.sort(key=lambda x : abs(x-5))In [10]: sOut[10]: [5, 4, 6, 3, 7, 2, 8, 1, 9, 0] 123456789101112131415161718192021In [32]: stus = [...: &#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18&#125;,...: &#123;&quot;name&quot;: &quot;lisi&quot;, &quot;age&quot;: 19&#125;,...: &#123;&quot;name&quot;: &quot;wangwu&quot;, &quot;age&quot;: 17&#125;...: ]In [33]: stus.sort(key=lambda x : x[&quot;name&quot;])In [34]: stusOut[34]:[&#123;&#x27;name&#x27;: &#x27;lisi&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 17&#125;, &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 18&#125;]In [35]: stus.sort(key=lambda x : x[&quot;age&quot;])In [36]: stusOut[36]:[&#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 17&#125;, &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;lisi&#x27;, &#x27;age&#x27;: 19&#125;]","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"https://www.bookandmusic.cn/tags/lambda/"},{"name":"匿名函数","slug":"匿名函数","permalink":"https://www.bookandmusic.cn/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"}]},{"title":"python高阶函数","slug":"python函数-高阶函数","date":"2020-06-06T03:13:12.000Z","updated":"2021-01-23T14:59:48.000Z","comments":true,"path":"2020/06/06/python-han-shu-gao-jie-han-shu/","link":"","permalink":"https://www.bookandmusic.cn/2020/06/06/python-han-shu-gao-jie-han-shu/","excerpt":"","text":"高阶函数介绍定义当一个函数 接收 另一个函数作为参数， 它就是 高阶函数 示例1234567def func(a, x, y): a(x, y) # a就是传递的 函数参数f， 执行 a 相当于 执行 fdef f(x, y): print(x + y)func(f, 1, 2) # 3， 在函数f执行过程中，输出 3 四大高阶函数map(func, iterable) 将 可迭代对象 中的每个值 按照 第一个参数( 函数)的 规则 依次 处理， 得到一个 新的 迭代器 对象 12345678910111213141516def func(alist): &quot;&quot;&quot; :param alist: 接收列表作为参数 :return: 将列表中每个数字，求平方之后，返回一个新列表 &quot;&quot;&quot; def sqr(x): return x * x r = map(sqr, alist) # r是迭代器对象 return list(r) # 将迭代器对象转换为列表r = func([11, 22, 33, 44, 55])print(r) 1234567891011# 定义函数， 接收 列表 作为参数 ， 返回一个 包含 绝对值 的新列表# abs()：python内置函数，求一个数的绝对值def func(alist): # map 高阶函数需要的参数，不用管是内置的，还是自定义的 r = map(abs, alist) return list(r)r = func([-12, 34, 56, -98])print(r) # [12, 34, 56, 98] 123456789101112131415161718192021# 定义函数，接收 一个 包含 单词的字符串， 返回 一个 每个单词 首字母大写 的字符串def func(astr): # 将字符串切分为单词列表 wlist = astr.split() def toUpper(x): return x.title() r = map(toUpper, wlist) # 将单词拼接为字符串 s = &quot; &quot;.join(r) return sr = func(&quot;a good fruit apple&quot;)print(r) # &quot; A Good Fruit Apple&quot;# 提示： 可以考虑 将 字符串按照 单词 切分， map处理之后， 再 重新拼接为字符串 reduce(func, iterable) 将可迭代对象中所有的元素，按照第一个 函数的规则， 连续操作，得到一个 具体的数据 123456789101112131415from functools import reduce# 自定义一个Mysum()函数，接收一个列表作为参数， 返回列表中所有元素之和def mysum(alist): def add(x, y): return x + y r = reduce(add, alist) # reduce 的结果是一个具体的值 return rr = mysum([1, 2, 3, 4, 5])print(r) # 15 filter(func, iterable) 按照第一个 函数的 返回值 对 可迭代对象 中 所有的数据 进行 过滤， 得到一个 包含过滤后结果的 迭代器对象 123456789101112131415# 自定义一个filterNumber()函数，接收一个列表作为参数， 返回一个 包含偶数 的列表def filterNumber(alist): def is_even(x): &quot;&quot;&quot;如果函数的返回结果为True, 对应的元素可以得到&quot;&quot;&quot; if x % 2 == 0: return True r = filter(is_even, alist) # r也是迭代器对象 return list(r) # 通过类型转换，将迭代器中数据取出r = filterNumber([1, 2, 3, 4, 5, 6])print(r) # [2, 4, 6]] 1234567891011121314# 自定义一个函数 sevenNumber()函数，接收一个列表作为参数， 返回一个 包含 &quot;逢7必过&quot; 数字的新列表def sevenNumber(alist): def f(x): # 判断为7的倍数，返回True if x % 7 == 0 or &#x27;7&#x27; in str(x): return True r = filter(f, alist) # r是迭代器对象 return list(r)r = sevenNumber(range(1, 101))print(r) sorted(iterable, key=func, reverse=False) 默认将列表 按照 升序 排序 1234567891011121314151617alist = [21, 14, -67, -34, 19]# 按照 数字大小 升序 排序r = sorted(alist)print(r) # [-67, -34, 14, 19, 21]# 按照 数字大小 降序 排序r = sorted(alist, reverse=True)print(r) # [21, 19, 14, -34, -67]# 按照每 个数字的绝对值 升序 排序r = sorted(alist, key=abs)print(r) # [14, 19, 21, -34, -67]# 按照 每个数字的绝对值 降序 排序r = sorted(alist, key=abs, reverse=True)print(r) # [-67, -34, 21, 19, 14]","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"高阶函数","slug":"高阶函数","permalink":"https://www.bookandmusic.cn/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"name":"sorted","slug":"sorted","permalink":"https://www.bookandmusic.cn/tags/sorted/"},{"name":"map","slug":"map","permalink":"https://www.bookandmusic.cn/tags/map/"},{"name":"reduce","slug":"reduce","permalink":"https://www.bookandmusic.cn/tags/reduce/"},{"name":"filter","slug":"filter","permalink":"https://www.bookandmusic.cn/tags/filter/"}]},{"title":"python变量作用域","slug":"python函数-变量解析","date":"2020-06-06T03:10:17.000Z","updated":"2021-01-23T14:58:34.000Z","comments":true,"path":"2020/06/06/python-han-shu-bian-liang-jie-xi/","link":"","permalink":"https://www.bookandmusic.cn/2020/06/06/python-han-shu-bian-liang-jie-xi/","excerpt":"","text":"变量的作用域 在Python程序中创建、改变、查找变量名时，都是在一个保存变量名的空间中进行，我们称之为命名空间，也被称之为作用域。 Python的作用域是静态的，在源代码中变量名被赋值的位置决定了该变量能被访问的范围。即Python变量的作用域由变量所在源代码中的位置决定。 作用域的产生 只有当变量在Module(模块)、Class(类)、def(函数)中定义的时候，才会有作用域的概念。 在作用域中定义的变量，一般只在该作用域中有效。 在if-elif-else、for-else、while、try-except/try-finally等关键字的语句块中并不会产生作用域 代码分析11234def func(): variable = 100 print(variable)print(variable) 代码执行到第二个print(variable)时会报错 NameError: name &#39;variable&#39; is not defined 变量variable只在函数func()的定义域内有效！ 代码分析212345if True: variable = 100 print(variable)print(&quot;******&quot;)print(variable) 输出结果为： 123100 ******100 程序没有报错，因为if语句不产生作用域 变量作用域的类型 L(local)局部作用域 √ 函数内的命名空间 E(enclosing)嵌套作用域 √ 外部嵌套函数的命名空间 G(global)全局作用域 √ 所在模块（文件）的命名空间 B(built-in)内置作用域 √ Python内置模块的命名空间 实例解析123456789101112globalVar = 100 # 全局作用域 def test_scope(): enclosingVar = 200 # 嵌套作用域 def func(): localVar = enclosingVar + 1 # 局部作用域 print(localVar)print(__name__) # 内置作用域 变量名解析LEGB法则当在函数中使用未确定的变量名时，Python会按照优先级依次搜索4个作用域，以此来确定该变量名的意义。 首先搜索局部作用域(L)， 之后是上一层嵌套结构中def或lambda函数的嵌套作用域(E)， 之后是全局作用域(G)， 最后是内置作用域(B)。 按这个查找原则，在第一处找到的地方停止。如果没有找到，则会出发NameError错误。 搜索变量名的优先级： 局部作用域 &gt; 嵌套作用域 &gt; 全局作用域 &gt; 内置作用域 实例11234567def func(): variable = 300 print(variable) #打印局部作用域的variablevariable = 100func()print(variable) #打印全局作用域的variable 运行结果： 12300100 实例2123456789def test_scopt(): variable = 200 print(variable) def func(): print(variable) #此处打印的是上层嵌套函数 func() #test_scopt()中的variablevariable = 100test_scopt()print(variable) 运行结果： 123200200100 实例31234567variable = 300def test_scopt(): print(variable) #此处的变量variable绑定的是下一行 variable = 200 #语句中所声明的局部变量，但未被赋值所以报错test_scopt()print(variable) 运行结果： 1UnboundLocalError: local variable &#x27;variable&#x27; referenced before assignment 实例41234567variable = 300def test_scopt(): print(variable) #此处打印的是全局变量variable #variable = 200 #如果这行未被注释，那么上一句print打印的应是 #此处定义的局部变量 test_scopt()print(variable) 运行结果： 12300300 仔细体会实例4和实例3的区别！ global与nonlocal关键字 global适用于函数内部修改全局变量的值 nonlocal适用于嵌套函数中内部函数修改外部变量的值 实例1（global关键字）123456789spam = 99 # &lt;--def tester(): def nested(): global spam #绑定到了第一行定义的spam print(&#x27;current=&#x27;,spam) spam = 200 return nestedtester()()print(spam) 运行结果： 12current= 99200 实例2（nonlocal关键字）123456789def outer(): count = 10 # &lt;-- def inner(): nonlocal count #绑定到了第二行定义的count count = 20 print(count) inner() print(count)outer() 运行结果： 122020","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"LEGB","slug":"LEGB","permalink":"https://www.bookandmusic.cn/tags/LEGB/"},{"name":"作用域","slug":"作用域","permalink":"https://www.bookandmusic.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"global","slug":"global","permalink":"https://www.bookandmusic.cn/tags/global/"},{"name":"nonlocal","slug":"nonlocal","permalink":"https://www.bookandmusic.cn/tags/nonlocal/"}]},{"title":"XSS攻击和CSRF攻击","slug":"web-xss 攻击和 csrf 攻击","date":"2020-05-24T12:38:26.000Z","updated":"2021-01-23T15:09:41.000Z","comments":true,"path":"2020/05/24/web-xss-gong-ji-he-csrf-gong-ji/","link":"","permalink":"https://www.bookandmusic.cn/2020/05/24/web-xss-gong-ji-he-csrf-gong-ji/","excerpt":"","text":"CSRF1. CSRF 的基本概念、缩写、全称CSRF（Cross-site request forgery）：跨站请求伪造。 2. CSRF 的攻击原理 用户是网站 A 的注册用户，且登录进去，于是网站 A 就给用户下发 cookie。 从上图可以看出，要完成一次 CSRF 攻击，受害者必须满足两个必要的条件： （1）登录受信任网站 A，并在本地生成 Cookie。（如果用户没有登录网站 A，那么网站 B 在诱导的时候，请求网站 A 的 api 接口时，会提示你登录） （2）在不登出 A 的情况下，访问危险网站 B（其实是利用了网站 A 的漏洞）。 我们在讲 CSRF 时，一定要把上面的两点说清楚。 温馨提示一下，cookie 保证了用户可以处于登录状态，但网站 B 其实拿不到 cookie。 3. CSRF的防范措施1、判断请求头中的 Referer这个字段记录的是请求的来源。比如前端Vue页面 http://localhost:8080/#/showbooks上调用了服务端Django的接口 http://127.0.0.1:8000/books/?page=2&amp;page_size=10， 那么在服务端，就可以通过 Referer 判断这个请求是来自哪里。 在实际应用中，这些跟业务逻辑无关的操作往往会放在拦截器中（或者说过滤器，不同技术使用的名词可能不同）。意思是说，在进入到业务逻辑之前，就应该要根据 Referer 的值来决定这个请求能不能处理。 用Flask 的话可以使用装饰器；在Django 中是叫中间件。每种技术它走的流程其实都一样。 而在 Django 可以通过以下代码获取对应信息 123request.META[&#x27;HTTP_REFERER&#x27;] # 来路request.META.get(&quot;HTTP_USER_AGENT&quot;) # 请求头 在Flask中，则获取方式不同。 123request.referrer # 来路request.headers.get(&#x27;User-Agent&#x27;) # 请求头 但要注意的是，Referer 是浏览器设置的，在浏览器兼容性大不相同的时代中，如果存在某种浏览器允许用户修改这个值，那么 CSRF 漏洞依然存在。 2、在请求参数中加入 csrf token讨论 GET 和 POST 两种请求，对于 GET，其实也没什么需要防范的。为什么？ 因为 GET 在 “约定” 当中，被认为是查询操作，查询的意思就是，你查一次，查两次，无数次，结果都不会改变（用户得到的数据可能会变），这不会对数据库造成任何影响，所以不需要加其他额外的参数。 所以这里要提醒各位的是，尽量遵从这些约定，不要在 GET 请求中出现 /delete, /update, /edit 这种单词。把 “写” 操作放到 POST 中。 对于 POST，服务端在创建表单的时候可以加一个隐藏字段，也是通过某种加密算法得到的。在处理请求时，验证这个字段是否合法，如果合法就继续处理，否则就认为是恶意操作。 1234&lt;form method=&quot;post&quot; action=&quot;/delete&quot;&gt; &lt;!-- 其他字段 --&gt; &lt;input type=&quot;hidden&quot; /&gt;&lt;/form&gt; 这个 html 片段由服务端生成。 这的确是一个很好的防范措施，再增加一些处理的话，还能防止表单重复提交。 可是对于一些新兴网站，很多都采用了 “前后端分离开发” 的设计，或者退一步，无论是不是前后端分离，它的 HTML 可能是由 JavaScript 拼接而成，并且表单也都是异步提交。所以这个办法有它的应用场景，也有局限性。 3、新增 HTTP Header方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。 把 token 隐藏在 http 的 head 头中。 服务端可以像获取 Referer 一样获取这个请求头，不同的是，这个 token 是由服务端生成的，所以攻击者他没办法猜。 另一篇文章讲解的——JWT——就是基于这个方式。抛开 JWT 不谈，它的工作原理是这样的: 解释一下这四个请求，类型都是 POST 。 通过 /login 接口，用户登录，服务端传回一个 access_token，前端把它保存起来，可以是内存当中，如果你希望用来模拟 session 的话。也可以保存到 localStorage 中，这样可以实现自动登录。 调用 /delete 接口，参数是某样商品的 id。仔细看，在这个请求中，多了一个名为 Authoriaztion 的 header，它的值是之前从服务端传回来的 access_token，在前面加了一个 “Bearer”（这是和服务端的约定，约定就是说，说好了加就一起加，不加就都不加……） 调用 /logout 接口，同样把 access_token 加在 header 中传过去。成功之后，服务端和前端都会把这个 token 置为失效，或直接删除。 再调用 /delete 接口，由于此时已经没有 access_token 了，所以服务端判断该请求没权限，返回 401 。 从头至尾，整个过程没有涉及 cookie，所以 CSRF 是不可能发生的！ XSS1. XSS 的基本概念XSS（Cross Site Scripting）：跨域脚本攻击。 2. XSS 的攻击原理XSS 攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入），向你的页面注入脚本（可能是 js、hmtl 代码块等）。 最后导致的结果可能是： 盗用 Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss 攻击 3. XSS 的攻击方式1、反射型发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。 2、存储型存储型 XSS 和反射型 XSS 的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交 XSS 代码。 4. XSS 的防范措施XSS 的防范措施主要有三个： 1、编码对用户输入的数据进行HTML Entity 编码。 比如说这段代码： 1&lt;script&gt;alert(1)&lt;/script&gt; 若不进行任何处理，则浏览器会执行 alert 的 js 操作，实现 XSS 注入。 进行编码处理之后，在浏览器中的显示结果就是 &lt;script&gt;alert(1)&lt;/script&gt;，实现了将 $var 作为纯文本进行输出，且不引起 JavaScript 的执行。 2、过滤移除用户输入的和事件相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等。（总而言是，过滤掉一些不安全的内容）移除用户输入的 Style 节点、Script 节点、Iframe 节点。（尤其是 Script 节点，它可是支持跨域的，一定要移除）。 3、校正避免直接对 HTML Entity 进行解码。使用 DOM Parse 转换，校正不配对的 DOM 标签。备注：我们应该去了解一下DOM Parse这个概念，它的作用是把文本解析成 DOM 结构。 比较常用的做法是，通过第一步的编码转成文本，然后第三步转成 DOM 对象，然后经过第二步的过滤。 CSRF 和 XSS 的区别区别一： CSRF：需要用户先登录网站 A，获取 cookie。 XSS：不需要登录。 区别二：（原理的区别） CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api。 XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"web","slug":"技术/python/web","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/web/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://www.bookandmusic.cn/tags/CSRF/"}]},{"title":"HTTP状态码","slug":"web-HTTP 协议之 http 状态码详解","date":"2020-05-24T12:38:26.000Z","updated":"2021-01-23T15:17:00.000Z","comments":true,"path":"2020/05/24/web-http-xie-yi-zhi-http-zhuang-tai-ma-xiang-jie/","link":"","permalink":"https://www.bookandmusic.cn/2020/05/24/web-http-xie-yi-zhi-http-zhuang-tai-ma-xiang-jie/","excerpt":"","text":"HTTP 协议之 http 状态码详解HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。 它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。 HTTP 状态码被分为五大类， 目前我们使用的 HTTP 协议版本是 1.1， 支持以下的状态码。随着协议的发展，HTTP 规范中会定义更多的状态码。 1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明 100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功） 表示成功处理了请求的状态代码。 代码 说明 200 （成功） 服务器已成功处理了请求，该操作是幂等的（Idempotent）。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。即请求已经进入后台排队（异步任务） 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 代码 说明 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"web","slug":"技术/python/web","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/web/"}],"tags":[{"name":"状态码","slug":"状态码","permalink":"https://www.bookandmusic.cn/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.bookandmusic.cn/tags/HTTP/"}]},{"title":"Django基础(五)-ORM模型类","slug":"Django-5-ORM模型类","date":"2020-05-24T12:38:26.000Z","updated":"2021-06-12T06:31:28.561Z","comments":true,"path":"2020/05/24/django-5-orm-mo-xing-lei/","link":"","permalink":"https://www.bookandmusic.cn/2020/05/24/django-5-orm-mo-xing-lei/","excerpt":"","text":"ORM介绍什么是 ORM ORM 全拼Object-Relation Mapping 中文意为 对象-关系映射 在MVC/MVT设计模式中的Model模块中都包括ORM ORM 优势（1）只需要面向对象编程, 不需要面向数据库编写代码. 对数据库的操作都转化成对类属性和方法的操作. 不用编写各种数据库的 sql 语句. （2）实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异. 不在关注用的是mysql、oracle… 等. 通过简单的配置就可以轻松更换数据库, 而不需要修改代码. ORM 劣势 相比较直接使用 SQL 语句操作数据库, 有性能损失. 根据对象的操作转换成 SQL 语句, 根据查询的结果转化成对象, 在映射过程中有性能损失. ORM 和数据库关系：在 Django 中 model 是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表. 基本情况： 每个模型都是一个 Python 类，它是 django.db.models.Model 的子类。 模型的每个属性都代表一个数据库字段。 综上所述，Django 为您提供了一个自动生成的数据库访问 API。 Django配置使用mysql数据库settings.py配置DATABASES默认:&#123;&#125;(空字典) 一个字典，包含Django使用的所有数据库的设置。它是一个嵌套的字典，其内容将数据库别名映射到包含单个数据库选项的字典。 数据库设置必须配置一个默认数据库;还可以指定任意数量的其他数据库。 最简单的设置文件是针对使用SQLite的单数据库设置的。这可以配置使用以下: 123456DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;, &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;), &#125;&#125; 当连接到其他数据库后端(如MySQL、Oracle或PostgreSQL)时，需要额外的连接参数。有关如何指定其他数据库类型，请参阅下面的引擎设置。这个例子是为MySQL: 12345678910DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;django_test&#x27;, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;PASSWORD&#x27;: &#x27;mysqlroot&#x27;, &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;, &#x27;PORT&#x27;: 3306 &#125;&#125; MySQL连接工具 需要安装pymysql模块 1pip install pymysql 在项目的__init__.py初始化文件,添加如下信息: 12import pymysqlpymysql.install_as_MySQLdb() 在django最新版本中，提示”Django需要mysqlclient 1.3.13或更高版本”。要么在报错时，将抛出版本异常的代码注释掉,仍然使用pymysql；要么直接使用mysqlclient,不建议直接pip命令安装，可以使用conda创建虚拟环境，使用conda安装mysqlclient。 字段属性和选项模型类属性命名限制 不能是python的保留关键字。 不允许使用连续的下划线，这是由django的查询方式决定的。 定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下： 1属性名=models.字段类型(选项) 字段类型 整数AutoField根据可用id自动递增的一个32位(4 byte)的整数(Integer)字段,它的适用范围为:1到2147483647之间。 你通常不需要直接使用它;如果不进行其他指定，主键字段将自动添加到模型中。 默认情况下， Django 会给每一个模型添加下面的字段： 1id = models.AutoField(primary_key=True) 这是一个自增的主键。 如果你想自己指定主键， 在你想要设置为主键的字段上设置参数 primary_key=True。如果 Django 看到你显式地设置了 Field.primary_key，将不会自动在表（模型）中添加 id 列。 每个模型都需要拥有一个设置了 primary_key=True 的字段（无论是显式的设置还是 Django 自动设置） BigAutoField一个64位(8 byte)的整数，类似于AutoField，除了它的适用范围为:1到9223372036854775807之间。 IntegerField一个32位(4 byte)的整数。在Django支持的所有数据库中，-2147483648到2147483647之间的值都是安全的。 BigIntegerField一个64位(8 byte)的整数，类似于IntegerField，除了它保证适合从-9223372036854775808到9223372036854775807的数字。 SmallIntegerField一个8位(2 byte)的整数，类似于IntegerField,在Django支持的所有数据库中，-32768到32767之间的值都是安全的。 PositiveIntegerField一个32位(4 byte)的整数，类似于IntegerField，但必须是正数或零(0)。在Django支持的所有数据库中，0到2147483647之间的值都是安全的。由于向后兼容的原因，接受值0。 PositiveSmallIntegerField一个8位(2 byte)的整数，类似于PositiveIntegerField，在Django支持的所有数据库中，0到32767之间的值都是安全的 小数FloatField在Python中由 float 实例表示的浮点数。 DecimalField一种固定精度的十进制数，在Python中用Decimal实例表示。它使用DecimalValidator验证输入。 有两个必要的参数: DecimalField.max_digits数字中允许的最大位数。注意，这个数字必须大于或等于decimal_places。 DecimalField.decimal_places要与该数字一起存储的小数位数。 例如，要存储分辨率为两位小数的999以内的数字，需要使用 1models.DecimalField(..., max_digits=5, decimal_places=2) FloatField vs. DecimalField FloatField类有时会与DecimalField类混在一起。虽然它们都表示实数，但它们表示的是不同的数。FloatField在内部使用Python的float类型，而DecimalField使用Python的Decimal类型。有关两者之间差异的信息，请参阅Python的 decimal 模块文档。 布尔BooleanField一个true/false字段。 当Field.default未定义时，BooleanField的默认值为None Django 2.1:在旧版本中，这个字段不允许null=True，因此必须使用NullBooleanField。现在不建议使用后者，因为在Django的未来版本中可能会弃用它。 在较早的版本中，该字段隐式地具有blank=True。您可以通过设置blank=True来恢复前面的行为。 NullBooleanField类似BooleanField的null=True。使用BooleanField这个字段而不是NullBooleanField这个字段，因为在Django的未来版本中NullBooleanField可能会被弃用 字符CharField字符串字段，用于小型到大型字符串。CharField有一个额外的必要参数: CharField.max_length字段的最大长度(以字符为单位)。max_length在数据库标准和Django的验证中使用MaxLengthValidator执行。 对于大量文本，使用TextField。 TextField一个大的文本字段。这个字段的默认表单小部件是一个Textarea。 如果指定max_length属性，它将反映在自动生成表单字段的Textarea小部件中。然而，它并没有在模型或数据库级别强制执行。 URLField一个有关URL的CharField，由URLValidator验证该值是否为有效的URL地址。 与所有CharField子类一样，URLField接受可选的max_length参数。如果不指定max_length，则使用默认值200。 EmailField一个有关Email的CharField,由EmailValidator验证该值是否为有效的电子邮件地址。 与所有CharField子类一样，EmailField接受可选的max_length参数。如果不指定max_length，则使用默认值254。 UUIDField用于存储通用唯一标识符的字段。使用Python的UUID类。当在PostgreSQL上使用时，它以uuid数据类型存储，否则以char(32)存储。 全局惟一标识符是primary_key的AutoField的一个很好的替代方案。数据库不会为你生成UUID，建议使用默认: 123456import uuidfrom django.db import modelsclass MyUUIDModel(models.Model): id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False) # other fields 注意，一个回调函数(省略括号)被传递到default，而不是UUID的一个实例。 文件FileField一个文件上传字段。有两个可选参数: FileField.upload_to这个属性提供了一种设置上传目录和文件名的方法，可以通过两种方式进行设置。在这两种情况下，值都被传递到Storage.save()方法。 如果您指定一个字符串值，它可能包含strftime()格式，它将被文件上传的日期/时间所取代(这样上传的文件就不会填满给定的目录)。例如: 123456class MyModel(models.Model): # 文件将被上传至 MEDIA_ROOT/uploads upload = models.FileField(upload_to=&#x27;uploads/&#x27;) # or... # 文件将被上传至 MEDIA_ROOT/uploads/2015/01/30 upload = models.FileField(upload_to=&#x27;uploads/%Y/%m/%d/&#x27;) 如果使用默认的FileSystemStorage，字符串值将追加到MEDIA_ROOT路径，以形成本地文件系统上的位置，上传的文件将存储在此位置。如果使用不同的存储，请检查该存储的文档，以了解它如何处理upload_to。 upload_to也可以是一个可调用的函数。这个函数将被调用以获得上传路径，包括文件名。这个可调用函数必须接受两个参数，并返回一个unix风格的路径(带有斜杠)，以便传递给存储系统。这两个参数是: 参数 描述 instance 定义FileField的模型的一个实例。更具体地说，这是附加当前文件的特定实例。在大多数情况下，这个对象还没有保存到数据库中，所以如果它使用默认的AutoField，那么它的主键字段可能还没有值。 filename 原给定给该文件的文件名。在确定最终目的地路径时，可能会考虑这一点，也可能不考虑这一点。 例子: 123456def user_directory_path(instance, filename): # file will be uploaded to MEDIA_ROOT/user_&lt;id&gt;/&lt;filename&gt; return &#x27;user_&#123;0&#125;/&#123;1&#125;&#x27;.format(instance.user.id, filename)class MyModel(models.Model): upload = models.FileField(upload_to=user_directory_path) FileField.storage一个存储对象，它处理文件的存储和检索。有关如何提供此对象的详细信息，请参见 管理文件 。 在模型中使用FileField或ImageField需要几个步骤: 在设置文件中，需要将MEDIA_ROOT定义为一个目录的完整路径，您希望Django在这个目录中存储上传的文件。(为了提高性能，这些文件不存储在数据库中。)将MEDIA_URL定义为该目录的基本公共URL。确保此目录可由Web服务器的用户帐户写入。 将FileField或ImageField添加到模型中，定义upload_to选项，以指定MEDIA_ROOT的子目录，用于上传文件。 所有将存储在数据库中的内容都是文件的路径(相对于MEDIA_ROOT)。您很可能希望使用Django提供的便利url属性。例如，如果 ImageField被称为 mug_shot ，可以获取模板中图像的绝对路径 &#123;&#123; object.mug_shot.url &#125;&#125; 例如，假设MEDIA_ROOT设置为&#39;/home/media&#39;， upload_to设置为&#39;photos/%Y/%m/%d&#39;。upload_to的&#39;%Y/%m/%d&#39;部分是strftime()格式;&#39;%Y&#39;是四位数的年份，&#39;%m&#39;是两位数的月份，&#39;%d&#39;是两位数的日期。如果你在2007年1月15日上传了一个文件，它将被保存在/home/media/photos/2007/01/15目录下。 如果要检索上传文件的磁盘上文件名或文件大小，可以分别使用名称 和大小 属性;有关可用属性和方法的更多信息，请参见 文件类引用和 管理文件主题指南。 文件作为模型保存在数据库中的一部分保存，因此在保存模型之前，不能依赖于磁盘上使用的实际文件名。 请注意，无论何时处理上传的文件，都应该密切注意上传文件的位置和文件类型，以避免安全漏洞。验证所有上传的文件，以确保这些文件是您所认为的。例如，如果您盲目地让某人在未经验证的情况下将文件上传到Web服务器的文档根目录中，那么某人就可以上传一个CGI或PHP脚本，并通过访问该脚本在您的站点上的URL来执行该脚本。不要允许这样的操作。 还要注意，即使是上传的HTML文件，由于它可以由浏览器执行(但不能由服务器执行)，也会造成相当于XSS或请注意，无论何时处理上传的文件，都应该密切注意上传文件的位置和文件类型，以避免安全漏洞。验证所有上传的文件，以确保这些文件是您所认为的。例如，如果您盲目地让某人在未经验证的情况下将文件上传到Web服务器的文档根目录中，那么某人就可以上传到CGI或PHP脚本，并通过访问该脚本在您的站点上的URL来执行该脚本。不要允许这样的操作。 还要注意，即使是上传的HTML文件，由于它可以由浏览器执行(但不能由服务器执行)，也会造成相当于XSS或CSRF攻击的安全威胁。攻击的安全威胁。 FileField实例在数据库中创建为varchar列，默认最大长度为100个字符。与其他字段一样，可以使用max_length参数更改最大长度。 ImageField从FileField继承所有属性和方法，但也验证上传的对象是有效的图像。 除了可用于FileField的特殊属性之外，ImageField还具有高度和宽度属性。 为了方便查询这些属性，ImageField有两个额外的可选参数: ImageField.height_field一个模型字段的名称，该字段将在每次保存模型实例时自动填充映像的高度。 ImageField.width_field一个模型字段的名称，该字段将在每次保存模型实例时自动填充图像的宽度。 需要 Pillow 库。 ImageField实例在数据库中创建为varchar列，默认最大长度为100个字符。与其他字段一样，可以使用max_length参数更改最大长度。 FilePathField一个CharField，它的选择仅限于文件系统上某个目录中的文件名。有三个特殊的参数，其中第一个是必需的: FilePathField.path必需的。这个FilePathField应该从中获得其选择的目录的绝对文件系统路径。例如:&quot;/ home /images&quot;。 FilePathField.match可选的。一个正则表达式，作为一个字符串，FilePathField将使用它来过滤文件名。注意，正则表达式将应用于基本文件名，而不是完整路径。示例:foo.*\\.txt$。它将匹配一个名为foo23.txt的文件，但不匹配bar.txt或foo23.png。 FilePathField.recursive可选的。非真即假。默认是假的。指定是否应该包括path的所有子目录 FilePathField.allow_files可选的。非真即假。默认是正确的。指定是否应包括位于指定位置的文件。这个或allow_folders必须为真。 FilePathField.allow_folders可选的。非真即假。默认是假的。指定是否应包括指定位置的文件夹。这个或allow_files必须为真。 当然，这些参数可以一起使用。 一个潜在的问题是，match应用于基本文件名，而不是完整路径。所以,这个例子: 1FilePathField(path=&quot;/home/images&quot;, match=&quot;foo.*&quot;, recursive=True) 将匹配/home/images/foo.png，但不匹配/home/images/foo/bar.png，因为匹配应用于基本文件名(foo.png和bar.png)。 FilePathField实例在数据库中创建为varchar列，默认最大长度为100个字符。与其他字段一样，可以使用max_length参数更改最大长度。 BinaryField存储原始二进制数据的字段。可以为它分配字节、字节数组或内存视图。 默认情况下，BinaryField将editable设置为False，在这种情况下，它不能包含在ModelForm中。 BinaryField有一个额外的可选参数: BinaryField.max_length字段的最大长度(以字符为单位)。最大长度在Django的验证中使用MaxLengthValidator实现。 Django 2.1:旧版本不允许将editable设置为True。 时间DateField日期，在Python中用datetime.date实例表示。有一些额外的，可选的参数: DateField.auto_now每次保存对象时自动将字段值设置为当前时间，用于“最后修改”时间戳。 该字段只在调用Model.save()时自动更新。当以其他方式(如QuerySet.update())更新其他字段时，该字段不会更新，不过可以在这样的更新中为该字段指定自定义值。 DateField.auto_now_add在第一次创建对象时自动将字段设置为当前时间。用于创建时间戳。 即使在创建对象时为这个字段设置了值，它也会被忽略。如果您希望能够修改该字段，请将auto_now_add=True设置为以下内容: For DateField: default=date.today - from datetime.date.today() For DateTimeField: default=timezone.now - from django.utils.timezone.now() auto_now_add、auto_now和default选项是互斥的。这些选项的任何组合都将导致错误。 DateTimeField日期和时间，在Python中用datetime.datetime实例表示。接受与DateField相同的额外参数。 TimeField时间，在Python中用datetime.time实例表示。接受与DateField相同的额外参数。 字段选项 以下参数对所有字段类型均有效，且是可选的。 null如果设置为 True， 当该字段为空时，Django 会将数据库中该字段设置为 NULL，默认为 False。 避免在基于字符串的字段（例如 CharField和 TextField）上使用 null。如果字符串字段的 null=True，那意味着对于“无数据”有两个可能的值：NULL 和空字符串。在大多数情况下，对于“无数据”声明两个值是赘余的，Django 的惯例是使用空字符串而不是 NULL。 一个例外是当 CharField同时具有 unique=True 和 blank=True 时。 在这种情况下，需要设置 null=True，以便在使用空白值保存多个对象时避免唯一的约束违规。 对于基于字符串和非基于字符串的字段，如果希望在表单中允许空值，还需要设置blank=True，因为null参数只影响数据库存储(参见blank)。 blank如果设置为 True ，该字段允许为空。默认为 False 。 注意，这与null不同。null纯粹是与数据库相关的，而blank则是与验证相关的。如果字段为blank=True，表单验证将允许输入空值。 blank和null的用法区别 null纯粹是与数据库相关的，而blank则是与表单验证相关的。 避免在基于字符串的字段（例如 CharField和 TextField）上使用 null。如果字符串字段的 null=True，那意味着对于“无数据”有两个可能的值：NULL 和空字符串。在大多数情况下，对于“无数据”声明两个值是赘余的，Django 的惯例是使用空字符串而不是 NULL。 一个例外是当 CharField同时具有 unique=True 和 blank=True 时。 在这种情况下，需要设置 null=True，以便在使用空白值保存多个对象时避免唯一的约束违规。 当存在两个参数时，总共会有四种设定组合 blank=True、null=True。统一的表明了该字段（列）是可以为空的。 blank=False、null=False。统一的表面了该字段（列）不可以为空。 blank=True、null=False。这个设定的意义在于，某些字段并不希望用户在表单中创建，而是通过在save方法中根据其他字段生成。 blank=False、null=True。这个设定不允许表单中该字段为空，但是允许在更新时或者通过shell等非表单方式插入数据该字段为空。 只设定了blank=True而没有设定null=True的时候，通过Admin站点表单创建模型实例并且表单在该字段上没有值时数据库不报错呢？？？ 当没有设定null=True时，该列在数据库中就存在NOT NULL的约束，如果插入数据时这一列没有值，按理说数据库应该会报错才对 出现这种情况的原因在于，django在处理某些在数据库中实际的存储值为字符串的Field时（如CharField, TextField, ImageField（图片文件的路径）），永远不会向数据库中填入空值。如果表单中某个CharField或者TextField字段为空，那么django会在数据库中填入&quot;&quot;，而不是null. choices一个序列，它由两个元素(例如[(A, B)， (A, B)…])的迭代组成，作为这个字段的选择。如果提供了选择，则通过模型验证强制执行，默认的表单小部件将是一个包含这些选择的选择框，而不是标准的文本字段。 每个元组中的第一个元素是要在模型上设置的实际值，第二个元素是人类可读的名称。例如: 123456YEAR_IN_SCHOOL_CHOICES = [ (&#x27;FR&#x27;, &#x27;Freshman&#x27;), (&#x27;SO&#x27;, &#x27;Sophomore&#x27;), (&#x27;JR&#x27;, &#x27;Junior&#x27;), (&#x27;SR&#x27;, &#x27;Senior&#x27;),] 通常，最好在模型类中定义选项，并为每个值定义一个适当命名的常量: 123456789101112131415161718192021from django.db import modelsclass Student(models.Model): FRESHMAN = &#x27;FR&#x27; SOPHOMORE = &#x27;SO&#x27; JUNIOR = &#x27;JR&#x27; SENIOR = &#x27;SR&#x27; YEAR_IN_SCHOOL_CHOICES = [ (FRESHMAN, &#x27;Freshman&#x27;), (SOPHOMORE, &#x27;Sophomore&#x27;), (JUNIOR, &#x27;Junior&#x27;), (SENIOR, &#x27;Senior&#x27;), ] year_in_school = models.CharField( max_length=2, choices=YEAR_IN_SCHOOL_CHOICES, default=FRESHMAN, ) def is_upperclass(self): return self.year_in_school in (self.JUNIOR, self.SENIOR) 虽然您可以在模型类的外部定义一个选择列表，然后引用它，但是在模型类内部定义每个选择的选择和名称，可以将所有信息与使用它的类一起保存，并使选择易于引用(例如：Student.SOPHOMORE 可以在导入Student模型类的任何地方使用)。 您还可以将可用的选项收集到指定的组中，这些组可用于组织目的: 1234567891011121314151617181920212223from django.db import modelsclass Media(models.Model): MEDIA_CHOICES = [ (&#x27;Audio&#x27;, ( (&#x27;vinyl&#x27;, &#x27;Vinyl&#x27;), (&#x27;cd&#x27;, &#x27;CD&#x27;), ) ), (&#x27;Video&#x27;, ( (&#x27;vhs&#x27;, &#x27;VHS Tape&#x27;), (&#x27;dvd&#x27;, &#x27;DVD&#x27;), ) ), (&#x27;unknown&#x27;, &#x27;Unknown&#x27;), ] media = models.CharField( max_length=10, choices=MEDIA_CHOICES, default=&#x27;cd&#x27; ) 每个元组中的第一个元素是应用于组的名称。第二个元素是二元组的迭代，每个二元组包含一个值和一个可读的选项名。分组选项可以与单个列表中的未分组选项组合在一起(例如本例中的未知选项)。 注意，选择可以是任何序列对象–不一定是列表或元组。这允许您动态地构造选择。但是，如果您发现自己的选择是动态的，那么最好使用一个带有 ForeignKey的数据库表。但是静态数据不会有太大的变化。 对于每个设置了选项的字段，对象都有一个get_FOO_display()方法，其中FOO是字段的名称。该方法返回字段的”人易读”值。 例子: 12345678910from django.db import modelsclass Person(models.Model): SHIRT_SIZES = ( (&#x27;S&#x27;, &#x27;Small&#x27;), (&#x27;M&#x27;, &#x27;Medium&#x27;), (&#x27;L&#x27;, &#x27;Large&#x27;), ) name = models.CharField(max_length=60) shirt_size = models.CharField(max_length=2, choices=SHIRT_SIZES) 123456&gt;&gt;&gt; p = Person(name=&quot;Fred Flintstone&quot;, shirt_size=&quot;L&quot;)&gt;&gt;&gt; p.save()&gt;&gt;&gt; p.shirt_size&#x27;L&#x27;&gt;&gt;&gt; p.get_shirt_size_display()&#x27;Large&#x27; db_column要用于此字段的数据库列的名称。如果没有给出，Django将使用字段的名称。 db_index如果为真，将为此字段创建一个数据库索引。 default该字段的默认值。可以是一个值或者是个可调用的对象，如果是个可调用对象，每次实例化模型时都会调用该对象。 默认值不能是一个可变的对象(模型实例、列表、集合等)，因为对该对象的同一个实例的引用将被用作所有模型实例的默认值。反而，可以在回调函数中打包处理所需的默认值。例如，如果要为JSONField指定默认dict，可以使用一个函数: 1234def contact_default(): return &#123;&quot;email&quot;: &quot;to1@example.com&quot;&#125;contact_info = JSONField(&quot;ContactInfo&quot;, default=contact_default) lambda表达式不能用于像default这样的字段选项，因为它们不能被迁移序列化。 对于像映射模型实例的ForeignKey这样的字段，默认值应该是它们引用的字段的值(pk，除非设置to_field)，而不是模型实例。 当创建新的模型实例并且没有为字段提供值时，将使用默认值。当字段是主键时，当字段设置为None时也会使用默认值。 help_text额外的“帮助”文本，随表单控件一同显示。即便你的字段未用于表单，它对于生成文档也是很有用的。 注意，这个值不会在自动生成的表单中进行html转义的。如果您愿意，可以在help_text中包含HTML。例如: 1help_text=&quot;Please use the following format: &lt;em&gt;YYYY-MM-DD&lt;/em&gt;.&quot; 或者，您可以使用纯文本和django.utils.html.escape()来转义任何HTML特殊字符。确保转义任何来自不可信用户的帮助文本，以避免跨站点脚本攻击。 primary_key如果设置为 True ，将该字段设置为该模型的主键。 如果您没有为模型中的任何字段指定primary_key=True, Django将自动添加一个AutoField来保存主键，所以您不需要在任何字段上设置primary_key=True，除非您想覆盖默认的主键行为。 primary_key=True意味着null=False和unique=True。对象上只允许有一个主键。 主键字段是只读的。如果更改现有对象上的主键值并保存它，则将在旧对象旁边创建一个新对象。 unique如果设置为 True，这个字段必须在整个表中保持值唯一。 这是在数据库级和通过模型验证实现的。如果试图在惟一字段中保存具有重复值的模型，则模型的save()方法会产生一个django.db.IntegrityError。 这个选项对除了ManyToManyField和OneToOneField以外的所有字段类型都有效。 注意，当unique为真时，不需要指定db_index，因为unique意味着创建索引。 verbose_name字段的可读名称。如果没有给出详细的名称，Django将使用字段的属性名自动创建它，将下划线转换为空格。 除了 ForeignKey， ManyToManyField 和 OneToOneField，任何字段类型都接收一个可选位置的参数 verbose_name，如果未指定该参数值， Django 会自动使用字段的属性名作为该参数值，并且把下划线转换为空格。 在该例中：备注名为 &quot;person&#39;s first name&quot;: 1first_name = models.CharField(&quot;person&#x27;s first name&quot;, max_length=30) 在该例中：备注名为 &quot;first name&quot;: 1first_name = models.CharField(max_length=30) ForeignKey， ManyToManyField 和 OneToOneField接收的第一个参数为模型的类名，后面可以添加一个 verbose_name参数： 1234567891011poll = models.ForeignKey( Poll, on_delete=models.CASCADE, verbose_name=&quot;the related poll&quot;,)sites = models.ManyToManyField(Site, verbose_name=&quot;list of sites&quot;)place = models.OneToOneField( Place, on_delete=models.CASCADE, verbose_name=&quot;related place&quot;,) 惯例是不将verbose_name 的首字母大写，必要时 Djanog 会自动把首字母转换为大写。 validators要为此字段运行的验证器列表。 编写验证器validator是一个可调用的函数，它接受一个值，如果它不满足某些条件，就会引发ValidationError。验证器对于在不同类型的字段之间重用验证逻辑非常有用。 例如，这里有一个验证器，它只允许偶数: 123456789from django.core.exceptions import ValidationErrorfrom django.utils.translation import gettext_lazy as _def validate_even(value): if value % 2 != 0: raise ValidationError( _(&#x27;%(value)s is not an even number&#x27;), params=&#123;&#x27;value&#x27;: value&#125;, ) 您可以通过字段的validators参数将其添加到模型字段: 1234from django.db import modelsclass MyModel(models.Model): even_field = models.IntegerField(validators=[validate_even]) 因为值在运行验证器之前就转换成了Python，你甚至可以对表单使用相同的验证器: 1234from django import formsclass MyForm(forms.Form): even_field = forms.IntegerField(validators=[validate_even]) 对于更复杂或可配置的验证器，您还可以使用带有__call__()方法的类。例如， RegexValidator这类验证器。如果在validators model字段选项中使用基于类的验证器,应该添加deconstruct()装饰器和 __eq__() 方法让它可以被迁移框架序列化。 django.core.validators模块包含一组可调用的验证器，用于模型和表单字段，可以在内部使用它们。 Meta 选项使用内部 Meta类 来给模型赋予元数据，就像： 12345678from django.db import modelsclass Ox(models.Model): horn_length = models.IntegerField() class Meta: ordering = [&quot;horn_length&quot;] verbose_name_plural = &quot;oxen&quot; abstract抽象基类在你要将公共信息放入很多模型时会很有用。编写你的基类，并在 Meta 类中填入 abstract=True。该模型将不会创建任何数据表。当其用作其它模型类的基类时，它的字段会自动添加至子类。 一个例子: 1234567891011from django.db import modelsclass CommonInfo(models.Model): name = models.CharField(max_length=100) age = models.PositiveIntegerField() class Meta: abstract = Trueclass Student(CommonInfo): home_group = models.CharField(max_length=5) Student 模型拥有3个字段： name， age 和 home_group。 CommonInfo 模型不能用作普通的 Django 模型，因为它是一个抽象基类。它不会生成数据表，也没有管理器，也不能被实例化和保存。 从抽象基类继承来的字段可被其它字段或值重写，或用 None 删除。 对很多用户来说，这种继承可能就是你想要的。它提供了一种在 Python 级抽出公共信息的方法，但仍会在子类模型中创建数据表。 app_label如果一个模型是在INSTALLED_APPS中注册的APP外部定义的，它必须声明它属于哪个应用程序: 1app_label = &#x27;myapp&#x27; db_table要用于模型的数据库表的名称: 1db_table = &#x27;music_album&#x27; 为了节省时间，Django自动从模型类和包含它的应用程序的名称派生数据库表的名称。模型的数据库表名是通过将模型的“app label”(您在manage.py startapp中使用的名称)与模型的类名连接在一起，并在它们之间加一个下划线来构造的。 例如，如果您有一个应用bookstore(由 manage.py startapp bookstore创建)，定义为Book的模型类将有一个名为bookstore_book的数据库表。 要覆盖数据库表名，请使用类元中的db_table参数。 强烈建议在通过db_table覆盖表名时使用小写的表名，特别是在使用MySQL后端时。 ordering对象的默认顺序，用于获取对象列表: 1ordering = [&#x27;-order_date&#x27;] 这是一个 包含由字符串和/或构成的查询表达式的元组或列表。每个字符串都是一个带有可选&quot;-&quot;前缀的字段名，表示按降序排列。没有前缀&quot;-&quot;的字段将按升序排列。使用字符串&quot;?&quot;随机排序。 例如，要按pub_date字段升序排序，可以使用以下命令: 1ordering = [&#x27;pub_date&#x27;] 要按pub_date降序排列，请使用以下命令: 1ordering = [&#x27;-pub_date&#x27;] 按pub_date降序排列，然后按author升序排列，使用以下命令: 1ordering = [&#x27;-pub_date&#x27;, &#x27;author&#x27;] 您还可以使用查询表达式。要按作者升序排序并使空值排序持续，请使用以下命令: 123from django.db.models import Fordering = [F(&#x27;author&#x27;).asc(nulls_last=True)] permissions创建此对象时进入权限表的额外权限。为每个模型自动创建添加、更改、删除和视图权限。这个例子指定了一个额外的权限can_deliver_pizzas: 1permissions = [(&#x27;can_deliver_pizzas&#x27;, &#x27;Can deliver pizzas&#x27;)] 这是一个格式为(permission_code, human_readable_permission_name)的二元列表或元组。 indexes要在模型上定义的索引列表: 1234567891011from django.db import modelsclass Customer(models.Model): first_name = models.CharField(max_length=100) last_name = models.CharField(max_length=100) class Meta: indexes = [ models.Index(fields=[&#x27;last_name&#x27;, &#x27;first_name&#x27;]), models.Index(fields=[&#x27;first_name&#x27;], name=&#x27;first_name_idx&#x27;), ] verbose_name模型对象的人类可读的单数名称: 1verbose_name = &quot;pizza&quot; 如果没有给出这个值，Django将使用类名的一个简化版本:CamelCase变成camel case。 verbose_name_plural对象的复数名称: 1verbose_name_plural = &quot;stories&quot; 如果没有给出，Django将使用 verbose_name+ &quot;s&quot; 关联关系显然，关系型数据库的强大之处在于各表之间的关联关系。 Django 提供了定义三种最常见的数据库关联关系的方法：多对一，多对多，一对一。 ForeignKey(多对一)定义一个多对一的关联关系，使用 django.db.models.ForeignKey 类。就和其它 Field字段类型一样，只需要在你模型中添加一个值为该类的属性。 ForeignKey 类需要添加一个位置参数，即你想要关联的模型类名。 123# 关键字ForeignKeypublish = models.ForeignKey(to=&#x27;Publish&#x27;) # to用来指代跟哪张表有关系 默认关联的就是表的主键字段# 外键字段名在创建时会自动加上_id后缀 字段参数 to:设置要关联的表 to_field:设置要关联的表的字段(一般不设置，默认使用主键id关联) related_name:反向操作时，使用的字段名，用于代替原反向查询时的&#39;表名_set&#39; related_query_name:反向查询操作时，使用的连接前缀，用于替换表名 db_constraint:是否在数据库中创建外键约束，默认为True。 on_delete:当删除关联表中的数据时，当前表与其关联的行的行为。 models.CASCADE:删除关联数据，与之关联的数据也删联(on_delete=models.CASCADE) 抛出异常(错误) models.DO_NOTHING:删除关联数据，引发错误IntegrityError models.PROTECT删除关联数据，引发错误ProtectedError models.SET_NULL:删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空） models.SET_DEFAULT:删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值） models.SET:删除关联数据 与之关联的值设置为指定值，设置：models.SET(值) 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象) OneToOneField(一对一) 外键字段创建在任意一张表都可以，建议外键添加在查询频率较高的一方 12# 关键字OneToOneFieldauthor_detail = models.OneToOneField(to=&#x27;Author_detail&#x27;) # 外键本质fk + unique 字段参数 to :设置要关联的表。 to_field:设置要关联的字段。 on_delete:同ForeignKey字段。 ManyToManyField(多对多) 用于表示多对多的关联关系。在数据库中通过第三张表来建立关联关系。 123# 关键字ManyToManyFieldauthor = models.ManyToManyField(to=&#x27;Author&#x27;) # django orm会自动帮你创建第三张关系表，表名为两个关联的表名用_连接 字段参数 to:设置要关联的表 related_name:同ForeignKey字段(反向操作时，使用的字段名，用于代替原反向查询时的&#39;表名_set&#39;) related_query_name:同ForeignKey字段(反向查询操作时，使用的连接前缀，用于替换表名) symmetric:仅用于多对多自关联时，指定内部是否创建反向操作的字段。默认为True。 123456789class Person(models.Model): name = models.CharField(max_length=16) friends = models.ManyToManyField(&quot;self&quot;) # 此时，person对象就没有person_set属性。 class Person(models.Model): name = models.CharField(max_length=16) friends = models.ManyToManyField(&quot;self&quot;,symmetrical=False) # 此时，person对象现在就可以使用person_set属性进行反向查询。 through:在使用ManyToManyField字段时，Django将自动生成一张表 来管理多对多的关联关系。但我们也可以手动创建第三张表来管理多对多关系，此时就需要通过through来指定第三张表的表名。 through_fields:设置关联的字段。 db_table:默认创建第三张表时，数据库中表的名称。 多对多的三种创建方式 自己建立第三张关系表，外键分别关联两个表 优点:可以扩充第三张关系标的字段 缺点:自己做连表查询 建表例子 123456789101112class Book(models.Model): title = models.CharField(max_length=12) class Author(models.Model): name = models.CharField(max_length=12) # 1. 多对多第一种创建方式：自己创建第三张关系表 class Author2Book(models.Model): id = models.AutoField(primary_key=True) author_id = models.ForeignKey(to=&#x27;Author&#x27;) book_id = models.ForeignKey(to=&#x27;Book&#x27;) price = models.IntegerField() # 可以自己扩充需要的字段 通过ORM内置的ManyToManyField，自动创建第三张关系表 优点:提供了很多连表操作的快捷方法,all(), add(), set(), clear(), remove() 缺点:无法扩展第三张关系表 建表例子 1234567class Book(models.Model): title = models.CharField(max_length=12) class Author(models.Model): name = models.CharField(max_length=12) books = models.ManyToManyField(to=&#x27;Book&#x27;) # 字段就这些，无法扩充其他字段 自己创建第三张关系表，通过ManyToManyField关联 优点： 既能够使用多对多查询的快捷方法all()(只能用all，不能使用add,set等) 还能够自己扩展第三张关系表的字段 建表例子 12345678910111213141516171819class Book(models.Model): title = models.CharField(max_length=12)class Author(models.Model): name = models.CharField(max_length=12) # 告诉ManyToManyField通过(through)Author2Book这张表进行关联，不使用ORM自动创建的第三张表，而是使用我自己创建的表 # through_fields告诉ORM通过哪几个字段进行多对多关联 books = models.ManyToManyField(to=&#x27;Book&#x27;, through=&#x27;Author2Book&#x27;, through_fields=(&#x27;author&#x27;, &#x27;book&#x27;)) # 1. 多对多第三种创建方式：自己创建第三张关系表，此时外键不需要添加_id了，因为ORM会默认帮你在外键后面加_id class Author2Book(models.Model): id = models.AutoField(primary_key=True) author = models.ForeignKey(to=&#x27;Author&#x27;) book = models.ForeignKey(to=&#x27;Book&#x27;) price = models.IntegerField(null=True) # author_id和book_id要联合唯一 class Meta: unique_together = ((&#x27;author&#x27;, &#x27;book&#x27;),) 操作例子 12345678# 多对多的第三张方式也支持all查询author_obj = Author.objects.first()# 第一个作者的所有书籍ret = author_obj.books.all() # 给第一个作者添加一本书# author_obj.books.add(4) # 报错Author2Book.objects.create(author_id=1, book_id=4)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"django基础","slug":"django基础","permalink":"https://www.bookandmusic.cn/tags/django%E5%9F%BA%E7%A1%80/"},{"name":"ORM模型类","slug":"ORM模型类","permalink":"https://www.bookandmusic.cn/tags/ORM%E6%A8%A1%E5%9E%8B%E7%B1%BB/"}]},{"title":"Redis命令","slug":"数据库-Redis命令","date":"2020-05-23T12:54:16.000Z","updated":"2021-01-21T07:06:30.000Z","comments":true,"path":"2020/05/23/shu-ju-ku-redis-ming-ling/","link":"","permalink":"https://www.bookandmusic.cn/2020/05/23/shu-ju-ku-redis-ming-ling/","excerpt":"简单对redis 命令进行总结、归纳。","text":"简单对redis 命令进行总结、归纳。 键 String List Hash Set Zset 更多命令参考Redis教程","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"数据库","slug":"技术/数据库","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"技术/数据库/redis","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"}],"tags":[{"name":"redis命令","slug":"redis命令","permalink":"https://www.bookandmusic.cn/tags/redis%E5%91%BD%E4%BB%A4/"}]},{"title":"清除office最近文件","slug":"系统-Mac-清除office最近文件","date":"2020-05-23T10:20:35.000Z","updated":"2021-01-25T02:59:43.000Z","comments":true,"path":"2020/05/23/xi-tong-mac-qing-chu-office-zui-jin-wen-jian/","link":"","permalink":"https://www.bookandmusic.cn/2020/05/23/xi-tong-mac-qing-chu-office-zui-jin-wen-jian/","excerpt":"","text":"批量删除Mac系统下office最近文件 12345rm -rf ~/Library/Containers/com.microsoft.Word/Data/Library/Preferences/com.microsoft.Word.securebookmarks.plistrm -rf ~/Library/Containers/com.microsoft.Excel/Data/Library/Preferences/com.microsoft.Excel.securebookmarks.plistrm -rf ~/Library/Containers/com.microsoft.Powerpoint/Data/Library/Preferences/com.microsoft.Powerpoint.securebookmarks.plist","categories":[{"name":"系统","slug":"系统","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"Mac","slug":"系统/Mac","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/Mac/"}],"tags":[{"name":"office","slug":"office","permalink":"https://www.bookandmusic.cn/tags/office/"}]},{"title":"Vue事件绑定以及事件修饰符","slug":"Vue-事件绑定以及事件修饰符","date":"2020-05-16T04:50:50.000Z","updated":"2020-12-01T14:23:48.000Z","comments":true,"path":"2020/05/16/vue-shi-jian-bang-ding-yi-ji-shi-jian-xiu-shi-fu/","link":"","permalink":"https://www.bookandmusic.cn/2020/05/16/vue-shi-jian-bang-ding-yi-ji-shi-jian-xiu-shi-fu/","excerpt":"","text":"事件要理解事件绑定，就得先了解事件。 浏览器是事件驱动型的，根据用户的行为触发不同的事件，根据事件执行相应的操作。我们较为熟悉的事件有三大类型： 鼠标键盘事件 鼠标键盘事件 事件介绍 onclick 鼠标点击某个对象 ondbclick 鼠标双击某个对象 onmousedown 某个鼠标按键被按下 onmouseup 某个鼠标按键被松开 onmousemove 鼠标被移动 onmouseover 鼠标被移到某元素之上 onmouseout 鼠标从某元素移开 onkeypress 某个键盘的键被按下或按住 onkeydown 某个键盘的键被按下 onkeyup 某个键盘的键被松开 页面事件 页面事件 事件介绍 onload 某个页面或图像被完成加载 onunload 用户退出页面 onresize 窗口或框架被调整尺寸 onerror 当加载文档或图像时发生某个错误 onabort 图像加载被中断 表单相关事件 表单相关事件 事件介绍 onblur 元素失去焦点 onfocus 元素获得焦点 onchange 用户改变域的内容 onreset 重置按钮被点击 onsubmit 提交按钮被点击 onselect 文本被选定 需要注意的是事件处理程序中的变量event保留着事件对象的信息，包括比如click事件，事件属性里有点击位置相对于浏览器，以及页面的坐标信息，事件的类型（click）,触发事件的DOM节点信息等;可以将evenet作为参数传递，在函数内部获取具体的evenet对象信息。 事件绑定 在Vue.js中v-on指令用来监听DOM事件，并在触发事件时运行一些JavaScript代码;当然v-on也可以简写为@ 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;事件绑定&lt;/title&gt; &lt;script src=&#x27;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&#x27;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&#x27;app&#x27;&gt; &lt;button v-on:click=&#x27;func&#x27;&gt; 显示 &lt;/button&gt; &lt;h1&gt; &#123;&#123;msg&#125;&#125; &lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123; msg: &#x27;&#x27;, &#125; &#125;, methods: &#123; func() &#123; this.msg = &#x27;这是一个大大的H1&#x27; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件修饰符 Vue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节;Vue.js通过由点(.)表示的指令后缀来调用修饰符。 事件修饰符分类Vue.js提供的事件修饰符主要针对两类情况: 冒泡机制修饰符 .stop .capture .self 事件本身修饰符 .prevent .once 冒泡机制修饰符事件冒泡DOM中，树状结构决定了子元素肯定在父元素里，所以点击子元素，就同时点击了子元素和父元素，以及父元素的父元素，以此类推，当然最终的根节点都是文档，以及window。 试想，当一个子元素被点击的时候，不仅仅这个元素本身被点击了，因为这个元素也在其上一级父元素中(属于父级元素的地盘)，所以相当于其父元素也被点击了，以此类推，一层一层往外推，最终整个文档也是被点击了，如果每个层级的节点元素都绑定了click事件，那么每个节点的click事件函数都会被执行。举个形象的例子，一个村里的人被打了（click），首先就要按照村里的规矩处理，同时这个村属于某个乡镇，当然也是相当于这个乡镇的人被打了，那么也要按照这个乡镇的规矩处理，以此一层一层往上报。这个例子不准确的地方就是，现实中一个人因为一个事件只会被处理一次，不会因为同一件事情多次处理。 冒泡带来的烦恼当上层（以及上上层，直至body元素）父级有子元素同样的方法，但你子元素的事件后，所有父级元素的同名函数也会从下到上，由里往外，挨个执行，但是大多数情况下，我们只希望子当事元素事件执行，不希望层层执行，这就要想办法阻止这种冒泡的情况发生。比如我们点击Child Span的时候只显示 Child Span的内容。结合刚刚的例子就是，村里发生了打人事件，在村里解决了，就没必要一层一层往上报，在层层处理了。 事件修饰符在Vue.js中针对Js事件本身的冒泡机制提供一些事件修饰符以便使用 .stop: 阻止冒泡事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;冒泡机制&lt;/title&gt; &lt;script src=&#x27;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&#x27;&gt;&lt;/script&gt; &lt;style&gt; #outer &#123; width: 400px; height: 200px; background-color: aqua; position: absolute; &#125; #inner &#123; width: 200px; height: 100px; background-color: darkcyan; margin: 50px auto; &#125; #btn &#123; width: 40px; height: 30px; background-color: gold; margin: 35px 80px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&#x27;app&#x27;&gt; &lt;div id=&quot;outer&quot; @click=&#x27;outer&#x27;&gt; &lt;div id=&quot;inner&quot; @click=&#x27;inner&#x27;&gt; &lt;button id=&quot;btn&quot; @click.stop=&#x27;btn&#x27;&gt;按钮 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; inner() &#123; console.log(&quot;inner触发了&quot;) &#125;, outer() &#123; console.log(&quot;outer触发了&quot;) &#125;, btn() &#123; console.log(&quot;btn触发了&quot;) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当点击按钮时，只会触发button本身的click事件,不会继续传递 .self: 只当事件在该元素本身（而不是子元素）触发时触发回调函数 12345&lt;div id=&quot;outer&quot; @click=&#x27;outer&#x27;&gt; &lt;div id=&quot;inner&quot; @click.self=&#x27;inner&#x27;&gt; &lt;button id=&quot;btn&quot; @click=&#x27;btn&#x27;&gt;按钮 &lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 当点击按钮时, 继续触发冒泡机制，因此outter盒子同样会触发对应的回调函数,但是inner盒子并不会触发回调函数，只有点击inner本身时，才会正常执行回调函数 .capture: 添加事件侦听器时使用事件捕获模式,即拥有该事件修饰符的元素会优先触发对应事件 12345&lt;div id=&quot;outer&quot; @click.capture=&#x27;outer&#x27;&gt; &lt;div id=&quot;inner&quot; @click=&#x27;inner&#x27;&gt; &lt;button id=&quot;btn&quot; @click=&#x27;btn&#x27;&gt;按钮 &lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 当点击按钮时, 继续触发冒泡机制，但是会优先触发outer的回调函数,其次，按照正常的冒泡顺序，由内向外 事件本身修饰符 .prevent:阻止默认行为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;VueDemo&lt;/title&gt; &lt;script src=&#x27;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&#x27;&gt;&lt;/script&gt; &lt;style&gt; form &#123; width: 210px; height: 300px; position: relative; margin: 0 auto; &#125; .user &#123; width: 200px; height: 20px; display: block; margin: 5px auto; &#125; #btn &#123; width: 70px; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&#x27;app&#x27;&gt; &lt;form action=&quot;/userinfo&quot; method=&quot;POST&quot; v-on:submit.prevent=&#x27;onsubmit&#x27;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; class=&quot;user&quot; v-model=&#x27;user.name&#x27; placeholder=&quot;请输入用户名。。。&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;user&quot; class=&quot;user&quot; v-model=&#x27;user.pwd&#x27; placeholder=&quot;请输入密码。。。&quot;&gt; &lt;input type=&quot;submit&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123; user: &#123; name: &quot;&quot;, pwd: &quot;&quot; &#125; &#125; &#125;, methods: &#123; onsubmit() &#123; console.log(`表单信息:$&#123;this.user.name&#125;和$&#123;this.user.pwd&#125;提交`) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 表单本身的提交行为会进行页面跳转，现在使用.prevent修饰符之后，只执行绑定的方法，不跳转页面;类似的还有超链接等的默认行为都可以使用该修饰符阻止 .once: 事件只能触发一次 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;VueDemo&lt;/title&gt; &lt;script src=&#x27;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&#x27;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&#x27;app&#x27;&gt; &lt;button @click.once=&#x27;btn&#x27;&gt; 你只能评论一次 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; btn() &#123; alert(&quot;已评论&quot;) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.bookandmusic.cn/tags/vue/"},{"name":"v-on","slug":"v-on","permalink":"https://www.bookandmusic.cn/tags/v-on/"},{"name":"Js事件","slug":"Js事件","permalink":"https://www.bookandmusic.cn/tags/Js%E4%BA%8B%E4%BB%B6/"},{"name":"事件修饰符","slug":"事件修饰符","permalink":"https://www.bookandmusic.cn/tags/%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"事件绑定","slug":"事件绑定","permalink":"https://www.bookandmusic.cn/tags/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"}]},{"title":"Mysql常见错误","slug":"数据库-Mysql常见错误","date":"2020-04-21T14:27:42.000Z","updated":"2021-01-23T15:14:24.000Z","comments":true,"path":"2020/04/21/shu-ju-ku-mysql-chang-jian-cuo-wu/","link":"","permalink":"https://www.bookandmusic.cn/2020/04/21/shu-ju-ku-mysql-chang-jian-cuo-wu/","excerpt":"","text":"简单对常见错误进行总结、归纳。 Ubuntu系统1698 只能root用户登录Mysql一、问题描述如果mysql安装时，没有提示输入密码，则会随机分配密码，直接mysql -u root -p则无法登录，报错： 1ERROR 1698 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost 二、解决方案 用管理员权限进入数据库 1sudo mysql -uroot -p 修改加密方式和密码 1alter user &#x27;username&#x27;@&#x27;host&#x27; identified with mysql_native_password BY &#x27;password&#x27;; 刷新 1flush privileges; 最后重启终端，就可通过 mysql -u root -p 免sudo登录mysql啦！ Windows系统1042服务启动异常一、问题描述mysql已经发展到了8.0阶段，但是很多人在下载了安装了mysql8.0后，在快接近完成的阶段下出现了异常： 1error 1042：Unable to connect to any of the specified MySQL hosts 上述异常直接导致mysql无法正常Finish，如图所示： 二、解决方案 windows端使用Win+R –&gt; 运行 &quot;services.msc&quot; –&gt; 打开service服务管理器，找到刚才安装mysql的服务名称 右键 –&gt; 属性 –&gt; 登录，更改成”本地系统账户” –&gt; 确定 回到安装程序，在次点击Execute，会发现已经可以成功到Finish界面 1045用户密码错误一、问题描述在数据库安装之后，使用mysql -uroot -p链接数据库时，出现以下异常: 11045 Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password:YES) 这个意思是说：用户“root”@本地主机的访问被拒绝 那为什么会出现这种错误呢？ 答案是这样：这种问题的本质是用户密码出现错误。 二、解决方案 打开命令窗口cmd，停止MySQL服务，输入命令： 1net stop mysql 开启跳过密码验证登录的MySQL服务,输入命令 1mysqld --console --skip-grant-tables --shared-memory 再打开一个新的cmd，无密码登录MySQL，输入登录命令 1mysql -u root -p 重置用户名对应的密码，命令如下： 12345use mysql; update user set authentication_string=&#x27;&#x27; where user=&#x27;root&#x27;; --修改密码为空 flush privileges; --刷新权限 退出mysql 关闭以--console --skip-grant-tables --shared-memory 启动的MySQL服务， 打开命令框，启动MySQL服务。输入 1net start mysql 再次登录无密码登录： 1mysql -u root -p 正确修改root密码 123alter user &#x27;root&#x27;@&#x27;host&#x27; identified with mysql_native_password BY &#x27;mysql&#x27;;flush privileges; 退出，再次成功登录，到此，重置密码结束。 Mysql数据库初始化当Mysql数据库链接失败， 跳过用户名验证也失败， 需要先删除 安装目录下的data文件夹, 然后重新初始化,生成初始化密码 以管理员的身份打开cmd窗口跳转路径到X:\\xxx\\mysql-8.0.11-winx64\\bin 1mysqld --initialize --user=mysql --console 按照上面的流程，就可以跳过用户名验证，重新设置mysql密码","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"数据库","slug":"技术/数据库","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"技术/数据库/mysql","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[{"name":"错误说明","slug":"错误说明","permalink":"https://www.bookandmusic.cn/tags/%E9%94%99%E8%AF%AF%E8%AF%B4%E6%98%8E/"}]},{"title":"vue-router","slug":"Vue-router","date":"2020-04-14T13:44:51.000Z","updated":"2021-06-12T06:38:12.390Z","comments":true,"path":"2020/04/14/vue-router/","link":"","permalink":"https://www.bookandmusic.cn/2020/04/14/vue-router/","excerpt":"","text":"Vue.js官方提供了一套专用的路由工具库 Vue Router,其使用和配置都非常简单。 安装路由可以使用npm包的方式来安装路由 1cnpm install vue-router --save 其实通过Vue-cli脚手架快速搭建项目时，命令行会询问是否安装路由功能，从而并不需要额外安装路由功能 通过Vue-cli脚手架搭建的项目，在src/router文件夹内部有index.js文件，打开index.js文件会看到以下引用。 1234import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;Vue.use(Router) 在入口文件src/main.js中导入src/router/index.js文件，即可使用路由配置的信息 123import router from &#x27;./router&#x27;//等效于//import router from &#x27;./router/index.js&#x27; 建立路由模块先建立一个路由器模块,主要用来配置和绑定相关信息。 在src/router/index.js文件中使用new Router命令创建一个路由,一个路由是一个对象。 一条路由的实现需要三部分:name 、path和component。name是命名,path是路径,component是组件 123456789101112131415161718192021222324// src/router/index.jsimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import HelloWorld from &#x27;@/components/HelloWorld&#x27;// 把对应的组件或页面引入进来import Login from &#x27;@/pages/login&#x27; // @指src根路径Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, // 这里默认是跳转到HelloWorld 组件， 后期会改为项目首页 name: &#x27;HelloWorld&#x27;, component: HelloWorld &#125;, &#123; path:&#x27;/login&#x27;, name: &#x27;Login&#x27;, component: Login // 后续如果还有页面要跳转，就按照这样的格式继续书写 &#125; ]&#125;) 导入HelloWorld组件的时候，实际上导入的是src/components/HelloWorld.vue.因为在Webpack中配置了，所以可以省略vue后缀。*.vue文件是Vue的单文件组件格式，可以同时包括模板定义、样式定义和组件模块定义。 启动路由器 在main.js入口文件中启用该路由器。 main.js作为入口文件，使用import可以把所有要用到的包都导入到这里，然后在Vue项目中去运用它们。 创建和挂载根实例，通过router配置参数注入路由，从而让整个应用都有路由功能 123456789101112// src/main.js import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27; new Vue(&#123;el: &#x27;#app&#x27;,router,components: &#123; App &#125;,template: &#x27;&lt;App/&gt;&#x27;&#125;) 浅析 导包方式 这个不是vue的规定而是node加载模块的方式,当require(‘./router’)(import会被转为require),node是这样的寻找目标的: 首先寻找目录下有没有router.js或者router.node,如果有就导入 如果没有看是否有router目录,如果没有就require失败,抛出异常”Cannot find module ‘./router’” 如果有router目录会在其下寻找package.json文件,如果有则按照package的配置来导入 如果没有package.json,看是否有index.js或者index.node,如果有就导入没有就失败 详细见node文档：https://nodejs.org/api/modules.html#modules_folders_as_module 配置之后，路由匹配到的组件将会渲染到App.vue的＜router-view&gt;&lt;/router-view&gt; 1234567// src/App.vue &lt;template&gt;&lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt;&lt;/div&gt;&lt;/template&gt; 最后App.vue 会渲染到index.html 123&lt;body&gt;&lt;div id=”app”&gt;&lt;/div&gt;&lt;/body&gt; 这样就会把渲染出来的页面挂载到id为app的div里了 路由重定向 项目应用通常都会有一个首页，默认首先打开的是首页，要跳转到哪个页面都可以设置路由路径发生跳转。重定向也是通过routes配置来完成的 12345678910111213141516171819202122232425262728293031routes: [ &#123; path: &#x27;/index&#x27;, name: &#x27;index&#x27;, component: HelloWorld &#125;, // 从&quot;/&quot;重定向到&quot;/index&quot; &#123; path:&quot;/&quot;, redirect:&#x27;/index&#x27; &#125;, // 重定向的目标也可以是一个命名的路由 &#123; path:&quot;/p1&quot;, redirect: &#123; name:&quot;index&quot; &#125; &#125;, // 重定向的目标甚至可以是一个方法，动态返回重定向目标 &#123; path:&quot;/p2&quot;, redirect:to=&gt;&#123; // 方法接收 &quot;目标路由&quot; 作为参数 // return 重定向的 &quot;字符串路径／路径对象&quot; // return &#x27;/index&#x27; return &#123;name: &#x27;index&#x27;&#125; &#125; &#125;] &lt;router-link&gt; &lt;router-link＞组件支持用户在具有路由功能的应用中单击导航。 通过to属性可以指定目标地址,默认渲染成带有正确链接的＜a＞标签,通过配置tag属性可以生成别的标签。 另外,当目标路由成功激活时,链接元素会自动设置一个表示激活的css类名。 1234567891011121314&lt;!-- 直接给to指定属性值, 不提倡使用，尽量使用属性绑定 --&gt;&lt;router-link to=&#x27;/goods&#x27;&gt;商品&lt;/router-link&gt; &lt;!-- 使用v-bind 绑定 JS表达式--&gt;&lt;router-link :to=&quot;&#x27;/goods&#x27;&quot;&gt;商品&lt;/router-link&gt; &lt;!-- 绑定data中的变量path --&gt;&lt;router-link :to=&#x27;path&#x27;&gt;商品&lt;/router-link&gt; &lt;!-- 绑定对象，自定义网址，携带查询参数 ==&gt; /goods?id=1 --&gt;&lt;router-link :to=&quot;&#123;&#x27;path&#x27;:&#x27;/goods&#x27;, , query:&#123;&#x27;id&#x27;:1&#125;&#125;&#125;&quot;&gt;商品&lt;/router-link&gt; &lt;!-- 绑定 对象，命名路由，携带params参数 ==&gt; /goods/1 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;goods&#x27;, params:&#123;&#x27;id&#x27;:1&#125;&#125;&quot;&gt;商品&lt;/router-link&gt; 路由对象属性 route和router区别:vue-router中经常会操作的两个对象router和route两个 route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等 下面列出了常用的路由信息对象属性 $route.path: 字符串，对应当前路由的路径，总是解析为绝对路径,如&quot;/goods&quot; $route.params: 一个key/value对象, 包含了动态片段和全匹配片段，如果没有路由参数，就为空对象。 $route.query: 一个key/value对象, 表示URL查询参数。例如: 对于路径/goods?cate_id=1,则有$route.query.cate_id == 1；如果没有查询参数,则为空对象 $route.hash: 当前路由的hash值(不带#)，如果没有hash值，则为空字符串。 $route.ful1Path: 完成解析后的URL，包含查询参数和hash的完整路径。 $route.matched: 一个数组，包含当前路由的所有嵌套路径片段的路由记录。路由记录就是routes配置数组中的对象副本(还有一些在children数组)。 router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。 下面列出了常用的路由信息对象方法 router.push(location): 要导航到不同的URL，则使用router.push方法。该方法会向history栈添加一个新的记录，当用户单击浏览器的后退按钮时，回到之前的URL。 12345678router.push(&#x27;/goods&#x27;) // 字符串router.push(&#123;path: &#x27;/goods&#x27;&#125;) // 对象 // 自定义网址，携带查询参数router.push(&#123; path: &quot;/goods&quot;, query: &#123; id: 1 &#125; &#125;) // -&gt; /goods?id=1 // 命名路由，携带params参数router.push(&#123; name: &quot;goods&quot;, params: &#123; id: 1 &#125; &#125;) // -&gt; /goods/1 由一个页面跳转到另一个页面时，需要携带一些数据，这时就需要用到这种带参数的路由跳转方式了。 当单击＜router-link＞时，会在内部调用router.push(...)方法，所以说单击＜router-link:to＝&quot;...&quot;&gt;等同于调用router.push(...)。 1234567891011121314151617181920212223242526// 当跳转之前，两种方式可以携带params参数// &lt;router-link :to=&quot;&#123;name:&#x27;goods&#x27;, params:&#123;&#x27;id&#x27;:1&#125;&#125;&quot;&gt;商品&lt;/router-link&gt;// router.push(&#123; name: &quot;goods&quot;, params: &#123; id: 1 &#125; &#125;) // 对应的路由配置有两种方式:// 1. 将参数获取直接体现在网址上routes: [ &#123; path: &#x27;/goods/:id&#x27;, name: &#x27;goods&#x27;, component: goods &#125;]// 此时会导致之前的params参数拼接在网址上， 为&quot;/goods/1&quot;，刷新不丢失数据 // 2. 不在网址上体现routes: [ &#123; path: &#x27;/goods&#x27;, name: &#x27;goods&#x27;, component: goods &#125;]// 此时会导致之前的参数不能表现出来，网址仍为&quot;/goods&quot;，刷新之后，参数丢失 // 但是不管怎么配置路由，参数获取方式相同 router.replace(location): router.replace与router.push很像，唯一的不同是它不会向history栈添加新记录，而是跟它的方法名一样只替换掉当前的history 记录。router.replace(...)等价于＜router-link :to＝&quot;...&quot; replace＞ router.go(n): 参数是一个整数，表示在history记录中向前进多少步或向后退多少步 123456789// 在浏览器记录中前进一步，等同于history.forward()router.go(1)// 后退一步，等同于history.back()router.go(-1)// 前进三步router.go(3)// 如果history记录不够，就会失败router.go(-100)router.go(100)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.bookandmusic.cn/tags/Vue/"},{"name":"router","slug":"router","permalink":"https://www.bookandmusic.cn/tags/router/"}]},{"title":"ES6语法","slug":"Js-ES6语法","date":"2020-04-12T15:13:05.000Z","updated":"2021-06-12T06:36:46.447Z","comments":true,"path":"2020/04/12/js-es6-yu-fa/","link":"","permalink":"https://www.bookandmusic.cn/2020/04/12/js-es6-yu-fa/","excerpt":"","text":"变量声明1. let let作用域只局限于当前代码块 1234567&#123; var a = 10 let b = 20&#125;console.log(a) // 输出 10console.log(b) // 报错 b is not defined 使用let声明的变量作用域不会提前 12345console.log(a) // 输出 undefinedconsole.log(b) // 报错 Cannot access &#x27;b&#x27; before initializationvar a = 10let b = 20 在相同的作用域下不能声明相同的变量 1234 &#123; let a = 10&#125;let a = 20 12var a = 10let a = 20 // 报错 Identifier &#x27;a&#x27; has already been declared 2. const 声明一个只读的常量。一旦声明，常量的值就不能改变 const只声明，不赋值，就会报错，这意味着const一旦声明常量，就必须立即初始化 const作用域与let相同，只在所在的块级作用域内有效 const声明的常量不支持提升，和let一样，只能在声明后使用 const声明的常量，也与let一样， 不可重复声明 const实际保证的并不是常量的值不变，而是常量指向的内存地址不得改变 对于简单的数据类型(数字、字符串、布尔值),值就保存在常量指向的地址，因此等同常量 对于复合类型的数据(数组、对象)，常量指向的内存地址保存的只是一个指针，const只能保证指针是固定的，但是指针指向的数据结构是不是可变的，并不能保证 123456789101112const a = 5// a = 10 // 报错 Assignment to constant variableconst obj = &#123;&#125;obj.a = 20 // 可执行console.log(obj) // 可执行 &#123;a: 20&#125;// obj = &#123;&#125; // 报错const arry = []arry.push(1) // 可执行arry.length = 0 // 可执行// arry = [] // 报错 Assignment to constant variable 3. 实例演示 使用var声明循环变量，会导致全局共用一个变量 12345678910111213141516171819202122&lt;button&gt;按钮&lt;/button&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;script&gt; var btns = document.querySelectorAll(&#x27;button&#x27;) for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function () &#123; console.log(`这是第$&#123;i&#125;个按钮`) &#125; &#125; // 此时点击任何按钮，输出都是&quot;这是第5个按钮&quot; for (let j = 0; j &lt; btns.length; j++) &#123; btns[j].onclick = function () &#123; console.log(`这是第$&#123;j&#125;个按钮`) &#125; &#125; // 把循环中的var改为let,则为正确的结果，即输出对应的按钮序号&lt;/script&gt; 下面的例子也是for循环中全局共用同一变量的弊端 12345678910111213for(var i=1;i&lt;10;i++)&#123; setTimeout(()=&gt;&#123; console.log(i) // 输出 10个9 &#125;, 100)&#125;console.log(i) // 9for(let j=1;j&lt;10;j++)&#123; setTimeout(()=&gt;&#123; console.log(j) // 输出 0-9 &#125;, 100)&#125;console.log(j) // 报错 j is not defined 解释 var是全局作用域，有变量提升的作用，所以在for中定义一个变量，全局可以使用，循环中的每一次给变量i赋值都是给全局变量i赋值。 let是块级作用域,只能在代码块中起作用，在js中一个{}中的语句我们也称为叫一个代码块，每次循环会产生一个代码块，每个代码块中的都是一个新的变量j 4. 小结 let、const使用场景 const一般用在需要一个模块时使用或者定义一些全局常量时使用 let限制了变量的作用域，保证变量不会影响全局变量，所以尽量将var改为let 箭头函数1. 箭头函数ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 为什么叫Arrow Function？因为它的定义用的就是一个箭头 1x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式。一种像上面的，只包含一个表达式，连&#123; ... &#125;和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略&#123; ... &#125;和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来： 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 12// SyntaxError:x =&gt; &#123; foo: x &#125; 因为和函数体的{ … }有语法冲突，所以要改为： 12// ok:x =&gt; (&#123; foo: x &#125;) 2. 箭头函数与匿名函数异同箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别: 箭头函数的提出，主要是为了解决多层函数嵌套中this指代混乱的问题；箭头函数内部的this是词法作用域，由上下文确定。 使用普通函数嵌套会产生this指代混乱的问题 1234567891011var person = &#123; age: 18, getBirth: function () &#123; var bth = function () &#123; // 多层嵌套函数中，this优先寻找父级作用域对象，不存在，即指向全局window对象 return new Date().getFullYear() - this.age // this.age undefined &#125; return bth() &#125;&#125;console.log(person.getBirth()) // NaN 使用箭头函数即可解决问题 1234567891011var person = &#123; age: 18, getBirth: function () &#123; var bth = ()=&gt;&#123; // 在箭头函数中 this会寻找父级作用域的对象，找到为止 return new Date().getFullYear() - this.age // this.age 18 &#125; return bth() &#125;&#125;console.log(person.getBirth()) // 2002 3. 箭头函数不适用的场景 作为对象的属性 12345var obj = &#123; a: () =&gt; &#123; console.log(this); // window &#125;&#125;; 作为对象的属性时，this的指向则不再是对象本身了，这就造成了意想不到的结果 不可以作为构造函数来使用 12345var Person = (name) =&gt; &#123; // Uncaught TypeError: Person is not a constructor this.name = name;&#125;var person = new Person(&#x27;Jack&#x27;); 这个特性很容易测试，如果上一条明白的话也很容易理解： 箭头函数压根就没有this，当然不能作为构造函数（如果明白构造函数new的过程的话，插一句： new的过程其实就是创建一个对象，将this指向该对象，然后执行代码初始化这个对象，最后返回） 不可以作为原型方法 同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误 1234567891011function Cat(name) &#123; this.name = name;&#125;Cat.prototype.sayCatName = () =&gt; &#123; console.log(this === window); // =&gt; true return this.name;&#125;;const cat = new Cat(&#x27;Mew&#x27;);cat.sayCatName(); // =&gt; undefined 使用传统的函数表达式就能解决问题： 1234567891011function Cat(name) &#123; this.name = name;&#125;Cat.prototype.sayCatName = function () &#123; console.log(this === cat); // =&gt; true return this.name;&#125;;const cat = new Cat(&#x27;Mew&#x27;);cat.sayCatName(); // =&gt; &#x27;Mew&#x27; sayCatName 变成普通函数之后，被调用时的执行上下文就会指向新创建的 cat 实例。 不绑定arguments（如果有要使用arguments的时候可以使用rest参数代替） 1234var foo = (val) =&gt; &#123; console.log(arguments); // Uncaught ReferenceError: arguments is not defined&#125;;foo(); 这个特性也很好测试，但是实在要使用arguments对象要怎么办呢？我们可以使用es6的另一个新特性rest参数，完美替代 1234var foo = (...args) =&gt; &#123; console.log(args); // [1, 2, 3]&#125;;foo(1, 2, 3); JS对象嵌套函数 在 js 的语法规则中，如果一个对象内存在方法，则该方法 this 指向当前对象。如下所示： 1234567let obj = &#123; age: 10, getAge: function () &#123; console.log(this.age) &#125;&#125;obj.getAge();// 10 若方法中再次包含函数方法，则该嵌套函数指向全局。不能获取到本对象中的属性。如下所示： 1234567let obj = &#123; age: 10, getAge: function () &#123; setTimeout(function()&#123; alert(this.age)&#125;, 1000) &#125;&#125;obj.getAge();// undefined 可以通过如下几种办法来解决此问题：（1）定义变量，保存对象 this 1234getAge: function () &#123; let self = this; setTimeout(function()&#123; alert(self.age)&#125;, 1000) &#125; (2) 通过箭头函数的方式 由于箭头函数具有默认指向父级调用对象 obj 的特点，因此也可以解决本问题 123getAge: function () &#123; setTimeout(() =&gt; &#123; alert(this.age)&#125;, 1000)&#125; 解构赋值什么是解构赋值？解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。 通常来说，你很可能这样访问数组中的前三个元素： 123var first = someArray[0];var second = someArray[1];var third = someArray[2]; 如果使用解构赋值的特性，将会使等效的代码变得更加简洁并且可读性更高： 1var [first, second, third] = someArray; SpiderMonkey（Firefox 的 JavaScript 引擎）已经支持解构的大部分功能，但是仍不健全。你可以通过 bug 694100 跟踪解构和其它 ES6 特性在 SpiderMonkey 中的支持情况。 数组与迭代器的解构以上是数组解构赋值的一个简单示例，其语法的一般形式为： 1[ variable1, variable2, ..., variableN ] = array; 这将为 variable1 到 variableN 的变量赋予数组中相应元素项的值。如果你想在赋值的同时声明变量，可在赋值语句前加入var、let或const关键字，例如： 123var [ variable1, variable2, ..., variableN ] = array;let [ variable1, variable2, ..., variableN ] = array;const [ variable1, variable2, ..., variableN ] = array; 事实上，用变量来描述并不恰当，因为你可以对任意深度的嵌套数组进行解构： 1234var [foo, [[bar], baz]] = [1, [[2], 3]];console.log(foo); // 1console.log(bar); // 2console.log(baz); // 3 此外，你可以在对应位留空来跳过被解构数组中的某些元素： 12var [,,third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];console.log(third); // &quot;baz&quot; 而且你还可以通过 “不定参数” 模式捕获数组中的所有尾随元素： 12var [head, ...tail] = [1, 2, 3, 4];console.log(tail); // [2, 3, 4] 当访问空数组或越界访问数组时，对其解构与对其索引的行为一致，最终得到的结果都是：undefined。 123console.log([][0]); // undefinedvar [missing] = [];console.log(missing); // undefined 请注意，数组解构赋值的模式同样适用于任意迭代器： 12345678910function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();console.log(sixth); // 5 对象的解构通过解构对象，你可以把它的每个属性与不同的变量绑定，首先指定被绑定的属性，然后紧跟一个要解构的变量。 1234567var robotA = &#123; name: &quot;Bender&quot; &#125;;var robotB = &#123; name: &quot;Flexo&quot; &#125;;var &#123; name: nameA &#125; = robotA;var &#123; name: nameB &#125; = robotB;console.log(nameA); // &quot;Bender&quot;console.log(nameB); // &quot;Flexo&quot; 当属性名与变量名一致时，可以通过一种实用的句法简写： 1234var &#123; foo, bar &#125; = &#123; foo: &quot;lorem&quot;, bar: &quot;ipsum&quot; &#125;;console.log(foo); // &quot;lorem&quot;console.log(bar); // &quot;ipsum&quot; 与数组解构一样，你可以随意嵌套并进一步组合对象解构： 1234567891011var complicatedObj = &#123; arrayProp: [ &quot;Zapp&quot;, &#123; second: &quot;Brannigan&quot; &#125; ]&#125;;var &#123; arrayProp: [first, &#123; second &#125;] &#125; = complicatedObj;console.log(first);// &quot;Zapp&quot;console.log(second);// &quot;Brannigan&quot; 当你解构一个未定义的属性时，得到的值为undefined： 123var &#123; missing &#125; = &#123;&#125;;console.log(missing);// undefined 请注意，当你解构对象并赋值给变量时，如果你已经声明或不打算声明这些变量（亦即赋值语句前没有let、const或var关键字），你应该注意这样一个潜在的语法错误： 12&#123; blowUp &#125; = &#123; blowUp: 10 &#125;;// Syntax error 语法错误 为什么会出错？这是因为 JavaScript 语法通知解析引擎将任何以 {开始的语句解析为一个块语句（例如，&#123;console&#125;是一个合法块语句）。解决方案是将整个表达式用一对小括号包裹： 12(&#123; safe &#125; = &#123;&#125;);// No errors 没有语法错误 解构值不是对象、数组或迭代器当你尝试解构null或undefined时，你会得到一个类型错误： 12var &#123;blowUp&#125; = null;// TypeError: null has no properties（null没有属性） 然而，你可以解构其它原始类型，例如：布尔值、数值、字符串，但是你将得到undefined： 123var &#123;wtf&#125; = NaN;console.log(wtf);// undefined 你可能对此感到意外，但经过进一步审查你就会发现，原因其实非常简单。当使用对象赋值模式时，被解构的值需要被强制转换为对象。大多数类型都可以被转换为对象，但null和undefined却无法进行转换。当使用数组赋值模式时，被解构的值一定要包含一个迭代器。 默认值当你要解构的属性未定义时你可以提供一个默认值： 123456789var [missing = true] = [];console.log(missing);// truevar &#123; message: msg = &quot;Something went wrong&quot; &#125; = &#123;&#125;;console.log(msg);// &quot;Something went wrong&quot;var &#123; x = 3 &#125; = &#123;&#125;;console.log(x);// 3","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"JS","slug":"技术/JS","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/JS/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.bookandmusic.cn/tags/ES6/"},{"name":"var","slug":"var","permalink":"https://www.bookandmusic.cn/tags/var/"},{"name":"let","slug":"let","permalink":"https://www.bookandmusic.cn/tags/let/"},{"name":"const","slug":"const","permalink":"https://www.bookandmusic.cn/tags/const/"},{"name":"箭头函数","slug":"箭头函数","permalink":"https://www.bookandmusic.cn/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}]},{"title":"python环境配置","slug":"工具-Python环境配置","date":"2020-04-10T16:00:27.000Z","updated":"2021-01-25T02:57:01.000Z","comments":true,"path":"2020/04/11/gong-ju-python-huan-jing-pei-zhi/","link":"","permalink":"https://www.bookandmusic.cn/2020/04/11/gong-ju-python-huan-jing-pei-zhi/","excerpt":"","text":"本篇文章将介绍如何在本地搭建Python开发环境。 Python可应用于多平台包括 Linux 和 Mac OS X。 你可以通过终端窗口输入 “python” 命令来查看本地是否已经安装Python以及Python的安装版本。 Python环境配置12345678910111213141516# ubuntusudo apt-get install python3-pipsudo apt-get install python-pip# windowspython3 -m pip install --upgrade pip --force-reinstallpython2 -m pip install --upgrade pip --force-reinstall# macbrew install python # 这一步安装了python3和pip3brew install python@2 # 这一步安装了python2和pip2# ipython2pip install ipython # ipython3pip3 install ipython pip镜像源镜像源 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 文件修改Linux/Mac修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加.，表示是隐藏文件夹) 内容如下 1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com windows直接在 user 目录中创建一个 pip 目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。 终端修改12pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ # 终端使用命令设置pip镜像pip install pip -U # 升级pip包管理工具 虚拟环境之pipenv 安装pipenv 1pip install pipenv 使用pipenv创建虚拟环境 12# 尽量在一个项目目录下创建虚拟环境pip install 激活虚拟环境 12# 在创建虚拟环境的位置运行命令pipenv shell 修改虚拟环境的镜像源 打开虚拟环境下的配置文件: Pipfile 1234567891011[[source]]name = &quot;pypi&quot;url = &quot;https://pypi.org/simple&quot;verify_ssl = true [dev-packages] [packages] [requires]python_version = &quot;3.7&quot; 修改url为国内镜像源: 清华: https://pypi.tuna.tsinghua.edu.cn/simple 阿里云: http://mirrors.aliyun.com/pypi/simple/ 中国科技大学: https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学: http://pypi.hustunique.com/ 山东理工大学: http://pypi.sdutlinux.org/ 豆瓣: http://pypi.douban.com/simple/ 在虚拟环境安装第三方包 1pipenv install django 使用pipenv卸载第三方模块 1pipev uninstall django 查看依赖 1pipenv graph 将安装的模块打包到一个文件内 1pip freeze &gt; requirements.txt 将一个文件内的第三方扩展安装到虚拟环境中 1pip install -r requirements.txt 退出虚拟环境 1exit 删除虚拟环境 1pipenv --rm 不激活虚拟环境，直接运行命令 1pipenv run django-amdin start project djangodemo 虚拟环境之virtualenv 安装virtualenv 123pip install virtualenv # 虚拟环境pip install virtualenvwrappern # mac/linux系统pip install virtualenvwrapper-win # windows系统 创建虚拟环境 1mkvirtualenv django 激活虚拟环境 123# 在创建虚拟环境后会默认激活workon django # 激活django虚拟环境workon # 查看所有虚拟环境 修改虚拟环境的镜像源 12pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ # 终端使用命令设置pip镜像pip install pip -U # 升级pip包管理工具 在虚拟环境安装第三方包 1pip install django # 先激活虚拟环境 卸载第三方模块 1pip uninstall django # 先激活虚拟环境 将安装的模块打包到一个文件内 1pip freeze &gt; requirements.txt 将一个文件内的第三方扩展安装到虚拟环境中 1pip install -r requirements.txt 退出虚拟环境 1exit 删除虚拟环境 1rmvirtualenv django 虚拟环境之conda 1. Anaconda简介 Anaconda是一个方便的python包管理和环境管理软件，一般用来配置不同的项目环境。 Anaconda通过管理工具包、开发环境、Python版本，大大简化了你的工作流程。不仅可以方便地安装、更新、卸载工具包，而且安装时能自动安装相应的依赖包，同时还能使用不同的虚拟环境隔离不同要求的项目。 Anaconda 镜像使用帮助 Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算、数据分析的 Python 包。 Anaconda 安装包可以到 https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 下载。 Miniconda 镜像使用帮助 Miniconda 是一个 Anaconda 的轻量级替代，默认只包含了 python 和 conda，但是可以通过 pip 和 conda 来安装所需要的包。 Miniconda 安装包可以到 https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/ 下载。 2. Anaconda安装 Windows安装 点击安装文件Anaconda3-2019.07-Windows-x86_64.exe,选择安装路径,如D:\\python\\Anaconda,然后一直next即可。 配置环境变量: 将安装的根路径,如D:\\python\\Anaconda和scripts文件夹路径D:\\python\\Anaconda\\scripts添加到电脑环境变量之中 Linux/Mac安装 将安装文件Anaconda3-2019.07-Linux-x86_64.sh移动到用户家目录 在用户家目录,打开终端,执行./Anaconda3-2019.07-Linux-x86_64.sh,然后输入yes,一路回车即可。 配置环境变量: 打开.bashrc 文件,在终端执行如下命令: 1vi ~/.bashrc 输入G，跳转到文件末尾,在文件最后一行新增环境变量 1export PATH=~/anaconda3/bin:$PATH 修改完成,先按esc键进入命令行模式，然后按shift+：进入末行模式，输入wq,保存退出 在终端执行如下命令,使其立即生效 1source ~/.bashrc 注意：在Mac中，修改文件.bash_profile,其余和Linux操作一样 3. 修改Anaconda镜像源 Anaconda默认访问国外服务器，网速较慢，故需要修改默认镜像 TUNA 还提供了 Anaconda 仓库与第三方源（conda-forge、msys2、pytorch等，查看完整列表）的镜像，各系统都可以通过修改用户目录下的 .condarc 文件: 1234567891011121314151617channels: - defaultsshow_channel_urls: truechannel_alias: https://mirrors.tuna.tsinghua.edu.cn/anacondadefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 即可添加 Anaconda Python 免费仓库。Windows 用户无法直接创建名为 .condarc 的文件，可先执行 conda config --set show_channel_urls yes 生成该文件之后再修改。 4. Anconda基本使用管理环境 检查conda版本 1conda --version 升级当前版本conda 1conda update conda 管理（虚拟）环境 12345678910111213141516171819202122232425# 创建一个名为python37的环境，指定Python版本是3.7（不用管是3.7.x，conda会为我们自动寻找3.7.x中的最新版本）conda create --name python37 python=3.7# 安装好后，使用activate激活某个环境activate python37 # for Windowssource activate python37 # for Linux &amp; Mac# 激活后，会发现terminal输入的地方多了python37的字样# 如果想返回默认的python环境，运行deactivate python37 # for Windowssource deactivate python37 # for Linux &amp; Mac# 删除一个已有的环境conda remove --name python37 --all# 另外，我们可以使用conda命令替换source命令用来激活和关闭环境conda activate python37conda deactivate# 取消每次打开终端，默认激活bash环境conda config --set auto_activate_base false# 重新激活每次打开终端，默认进入base环境conda config --set auto_activate_base true 新的开发环境会被默认安装在你conda目录下的envs文件目录下。 如果我们没有指定安装python的版本，conda会安装我们最初安装conda时所装的那个版本的python。 列出所有环境 12conda info -econda info –-envs 注意:conda会对当前活动的环境追加星号标记。 123456macdeMacBook-Pro:~ mac$ conda info -e# conda environments:#base * /Users/mac/anaconda3myenv /Users/mac/anaconda3/envs/myenvpy3 /Users/mac/anaconda3/envs/py3 复制一个环境通过克隆来复制一个环境。这儿将通过克隆py3来创建一个称为py32的副本。 1conda create -n py32 --clone py3 通过 1conda info –-envs 来检查环境。 重命名env conda是没有重命名环境的功能的, 要实现这个基本需求, 只能通过愚蠢的克隆-删除的过程。 切记不要直接mv移动环境的文件夹来重命名, 会导致一系列无法想象的错误的发生! 12conda create --name newname --clone oldname # 克隆环境conda remove --name oldname --all # 彻底删除旧环境 分享环境 如果你想把你当前的环境配置与别人分享，这样ta可以快速建立一个与你一模一样的环境（同一个版本的python及各种包）来共同开发/进行新的实验。 一个分享环境的快速方法就是给ta一个你的环境的.yml文件。 首先通过activate target_env要分享的环境target_env，然后输入下面的命令会在当前工作目录下生成一个environment.yml文件 1conda env export &gt; environment.yml 小伙伴拿到environment.yml文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境 1conda env create -f environment.yml 管理包 conda安装和管理python包非常方便，可以在指定的python环境中安装包，且自动安装所需要的依赖包，避免了很多拓展包冲突兼容问题。 不建议使用easy_install安装包。大部分包都可以使用conda安装，无法使用conda和anaconda.org安装的包可以通过pip命令安装 使用合适的源可以提升安装的速度 查看已安装包 1conda list 使用这条命令来查看哪个版本的python或其他程序安装在了该环境中，或者确保某些包已经被安装了或被删除了。 向指定环境安装包我们在指定环境中安装requests包，有两种方式: 直接通过-n选项指定安装环境的名字 1conda install --name py3 requests 提示：你必须告诉conda你要安装环境的名字（-n py3）否则它将会被安装到当前环境中。 激活py3环境，再使用conda install命令。 12conda activate py3conda install requests 通过pip命令 对于那些无法通过conda安装或者从Anaconda.org获得的包，我们通常可以用pip命令来安装包。 可以上pypi网站查询要安装的包，查好以后输入pip install命令就可以安装这个包了。 我们激活想要放置程序的python环境，然后通过pip安装一个叫“PyMysql”的包。 1234567# Linux, OS Xsource activate bunnies# Windowsactivate py3# 安装pip install pymysql pip只是一个包管理器，所以它不能为你管理环境。pip甚至不能升级python，因为它不像conda一样把python当做包来处理。但是它可以安装一些conda安装不了的包。 小技巧：在任何时候你可以通过在命令后边跟上-help来获得该命令的完整文档。很多跟在–后边常用的命令选项，可以被略写为一个短线加命令首字母。所以–name选项和-n的作用是一样的。通过conda -h或conda –-help来看大量的缩写。 移除包、环境、或者conda 移除包 假设你决定不再使用包pymysql。你可以在py3环境中移除它。 1conda remove -n py3 pymysql 移除环境 我们不再需要snakes环境了，可以输入以下命令： 1conda remove -n myenv --all 删除conda Linux/OS X： 移除Anaconda 或 Miniconda 安装文件夹 123rm -rf ~/miniconda# ORrm -rf ~/anaconda Windows：去控制面板，点击“添加或删除程序”，选择“Python2.7/3.6（Anaconda）”或“Python2.7/3.6（Miniconda）”并点击删除程序。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"工具/python","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/python/"}],"tags":[{"name":"virtualenv","slug":"virtualenv","permalink":"https://www.bookandmusic.cn/tags/virtualenv/"},{"name":"pipenv","slug":"pipenv","permalink":"https://www.bookandmusic.cn/tags/pipenv/"},{"name":"conda","slug":"conda","permalink":"https://www.bookandmusic.cn/tags/conda/"},{"name":"虚拟环境","slug":"虚拟环境","permalink":"https://www.bookandmusic.cn/tags/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"name":"pip","slug":"pip","permalink":"https://www.bookandmusic.cn/tags/pip/"}]},{"title":"DRF-后端跨域","slug":"DRF-后端跨域","date":"2020-03-17T10:19:28.000Z","updated":"2021-01-23T14:47:34.000Z","comments":true,"path":"2020/03/17/drf-hou-duan-kua-yu/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/17/drf-hou-duan-kua-yu/","excerpt":"","text":"前后端分离开发时，经常会遇到一个问题，那就是跨域问题,因为这时候前端和后端的代码是在不同机器上运行的，两个地址不在一个域名下，这个时候前端脚本在进行ajax访问的时候浏览器就会报跨域相关的错误。 原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。 为了解决这个问题，在前端和后台配置均可，此时，以后台django配置为例 1. 安装插件1pip install django-cors-headers 2. 注册应用12345INSTALLED_APPS = [ ... &#x27;corsheaders&#x27;, ...] 3. 中间件设置1234567MIDDLEWARE = [ ... &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, &#x27;corsheaders.middleware.CorsMiddleware&#x27;, # 注意，位置有限制 &#x27;django.middleware.common.CommonMiddleware&#x27;, ...] 4. 配置跨域参数123456789CORS_ORIGIN_ALLOW_ALL = True # 允许所有host访问# 添加白名单CORS_ORIGIN_WHITELIST = ( &#x27;127.0.0.1:8080&#x27;, &#x27;localhost:8080&#x27;,)# 以上配置二选一即可CORS_ALLOW_CREDENTIALS = True # 允许携带cookie,不需要可以不设置","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"DRF","slug":"技术/python/DRF","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/DRF/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://www.bookandmusic.cn/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"DRF-数据分页","slug":"DRF-数据分页","date":"2020-03-16T12:23:36.000Z","updated":"2021-01-23T14:47:39.000Z","comments":true,"path":"2020/03/16/drf-shu-ju-fen-ye/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/16/drf-shu-ju-fen-ye/","excerpt":"","text":"当需要展示的数据过多时，就需要将全部数据分批显示，这就需要用到 分页 功能 Django内置分页在DRF提供的API视图中，并不支持 pagination_class 分页属性，因此，需要分页，只能使用django内置的分页器 Paginator 。 Paginator 类的作用是将我们需要分页的数据分割成若干份。当我们实现化一个 Paginator 类的实例时，需要给 Paginator 传入两个参数。第一个参数是数据源，可以是一个列表、元组、以及查询结果集 QuerySet。第二个参数需要传入一个整数，表示每页显示数据条数。具体用法如下： 导入分页模块1from django.core.paginator import Paginator 获取queryset对象1goods_list = Goods.objects.all().order_by(&#x27;id&#x27;) 实例化分页类对象1paginator = Paginator(goods_list, 2) Paginator类对象的属性 序号 属性名 说明 1 num_pages 返回分页之后的总页数 2 page_range 返回分页后的页码列表 3 count 需要分页的总记录数 Paginator类对象的方法 序号 方法名 说明 1 get_page(self, number) 返回第number页的page类实例对象 Page实例对象的属性 序号 属性名 说明 1 number 返回当前页的页码 2 object_list 返回当前页的数据查询集 3 paginator 返回对应的Paginator类对象 page实例对象的方法 序号 方法名 说明 1 has_previous 判断当前页是否有前一页 2 has_next 判断当前页是否有下一页 3 previous_page_number 返回前一页的页码 4 next_page_number 返回下一页的页码 分页功能实现12345678910111213141516171819202122from rest_framework.response import Responsefrom rest_framework.views import APIViewfrom school.serializers import *class StudentsAPIView(APIView): def get(self, request): page_number = request.GET.get(&#x27;page&#x27;, 1) # 获取客户端发送的页码，默认为1 page_size = request.GET.get(&#x27;page_size&#x27;, 2) # 获取客户端发送的每页数量，默认为1 try: page_number = int(page_number) # 处理页码， 过滤无效的数据 except: page_number = 1 goods_set = Student.objects.all().order_by(&#x27;id&#x27;) paginator = Paginator(goods_set, page_size) # 得到分页器对象 page = paginator.get_page(page_number) # 得到当前页码对象 ser = StudentSerializer(page.object_list, many=True) return Response(ser.data) DRF 分页 REST框架包括对可定制的分页样式的支持。 分页类PageNumberPagination：可以进行直接的页码处理，返回某一页分页数据 12http://127.0.0.1:8000/user/?page=2# page：当前的页码 除了默认的分页样式之外，还可以通过继承分页类的方式重写分页样式 12345678from rest_framework.pagination import PageNumberPaginationclass class PagerPagination(PageNumberPagination): max_page_size = 3 # 每页最大数目 page_size = 1 # 默认每页数目 page_query_param = &#x27;page&#x27; # 页码关键字名， 默认为&quot;page&quot; page_size_query_param = &#x27;size&#x27; # 每页数目关键字名, ，默认为None LimitOffsetPagination可以通过连接可选的参数进行分页单页数量大小的控制，分页数据偏移的选择 123http://127.0.0.1:8000/path/?limit=2&amp;offset=2# limit：每页的数据大小# offset：从某一个数据位置开始偏移 除了默认的分页样式之外，还可以通过继承分页类的方式重写分页样式 1234567from rest_framework.pagination import LimitOffsetPaginationclass LimitPagination(LimitOffsetPagination): max_limit = 2 # 最大limit限制，默认None default_limit = 1 # 默认限制，和page_size作用一样 limit_query_param = &#x27;limit&#x27; # 参数名，默认limit offset_query_param = &#x27;offset&#x27; # 参数名，默认offset 自定义分页类 可以继承父类，并重写响应对象 12345678910111213141516171819202122from collections import OrderedDictfrom rest_framework.pagination import PageNumberPaginationfrom rest_framework.response import Responsefrom rest_framework.utils.urls import replace_query_paramclass Pagination(PageNumberPagination): def get_num_pages_link(self): url = self.request.build_absolute_uri() num_pages = self.page.paginator.num_pages return [replace_query_param(url, self.page_query_param, page) for page in range(1, num_pages + 1)] def get_paginated_response(self, data): return Response(OrderedDict([ (&#x27;count&#x27;, self.page.paginator.count), (&#x27;num_pages&#x27;, self.page.paginator.num_pages), # 分页的总页码 (&#x27;next&#x27;, self.get_next_link()), (&#x27;previous&#x27;, self.get_previous_link()), (&#x27;pages&#x27;, self.get_num_pages_link()), # 所有分页的链接 (&#x27;results&#x27;, data) ])) 分页应用全局分页 注意：需要修改Django的全局配置文件 settings.py 分页样式可以使用DEFAULT_PAGINATION_CLASS和PAGE_SIZE设置键进行全局设置。 例如，要使用内置的限制/偏移分页，可以执行以下操作： 12345678REST_FRAMEWORK = &#123; &#x27;DEFAULT_PAGINATION_CLASS&#x27;: &#x27;rest_framework.pagination.LimitOffsetPagination&#x27;, # 指明分页类 # &#x27;rest_framework.pagination.PageNumberPagination&#x27;, # &#x27;utils.pagination.Pagination&#x27;, # 自定义分页类 &#x27;PAGE_SIZE&#x27;: 2 # 每页数目&#125; 请注意，您需要同时设置分页类和应使用的页面大小。 局部分页您还可以使用pagination_class属性在单个视图上设置分页类。配置完了，如果不想用，那么就直接在视图类下使用如下属性关闭全局分页功能 12345678from rest_framework.generics import ListCreateAPIViewfrom .serializer import BookSerializerfrom .models import BookModelclass BookListView(ListCreateAPIView): serializer_class = BookSerializer queryset = BookModel.objects.all() pagination_class = None # 指定分页类，为None，即当前视图不分页","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"DRF","slug":"技术/python/DRF","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/DRF/"}],"tags":[{"name":"分页","slug":"分页","permalink":"https://www.bookandmusic.cn/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"Django-图片上传","slug":"Django-图片上传","date":"2020-03-16T12:23:16.000Z","updated":"2021-06-12T06:32:20.465Z","comments":true,"path":"2020/03/16/django-tu-pian-shang-chuan/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/16/django-tu-pian-shang-chuan/","excerpt":"","text":"图片上传static 和 media 都是存放文件的地方，但是又有区别，以下是两个文件夹的区别和用法 static定义static 是静态文件，主要存的是 CSS, JavaScript, 网站 logo 等不变的文件。 配置配置 settings.py 12345STATIC_URL = &#x27;/static/&#x27; # 静态文件别名（相对路径） 和 绝对路径STATICFILES_DIRS = [ os.path.join(BASE_DIR, &#x27;app01/static&#x27;),]# STATIC_ROOT 配置部署的时候才用 使用在项目中将模板层用到的静态文件都放入该文件夹中 media定义media 主要用来保存用户上传的文件，例如图片等 配置配置 settings.py 1234MEDIA_URL = &quot;/media/&quot; # 媒体文件别名(相对路径) 和 绝对路径MEDIA_ROOT = [ os.path.join(BASE_DIR, &#x27;app01/media&#x27;)] 配置路由 在子应用正常配置路由 12345678from django.urls import pathfrom app01.views import *app_name = &#x27;goods&#x27;urlpatterns = [ path(&#x27;goods/&#x27;, GoodsCreateView.as_view(), name=&#x27;create&#x27;), path(&#x27;&#x27;, IndexView.as_view(), name=&#x27;index&#x27;),] 在项目的主路由中对图片上传的路径信息进行配置 12345678910from django.conf.urls.static import staticfrom django.contrib import adminfrom django.urls import path, includefrom django01 import settingsurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;&#x27;, include(&#x27;app01.urls&#x27;)),] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)# 对外展示图片的地址信息 模型类 定义包含图片字段的模型类 12345678910111213class Goods(models.Model): name = models.CharField(max_length=20, verbose_name=&quot;名称&quot;) price = models.DecimalField(max_digits=7, decimal_places=2, verbose_name=&quot;单价&quot;) nums = models.IntegerField(verbose_name=&quot;数量&quot;) img = models.ImageField(upload_to=&#x27;img&#x27;, verbose_name=&quot;图片&quot;) class Meta: db_table = &quot;tb_goods&quot; verbose_name = &quot;商品&quot; verbose_name_plural = verbose_name def __str__(self): return self.name 模板添加页面123456789&lt;form action=&quot;&#123;% url &#x27;goods:create&#x27; %&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &#123;% csrf_token %&#125; 名称:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br&gt; 价格:&lt;input type=&quot;text&quot; name=&quot;price&quot;&gt; &lt;br&gt; 数量:&lt;input type=&quot;text&quot; name=&quot;nums&quot;&gt; &lt;br&gt; 图片:&lt;input type=&quot;file&quot; name=&quot;img&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 展示页面12345678910111213&lt;table&gt; &#123;% for good in goods %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; good.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; good.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; good.price &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; good.nums &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;/media/&#123;&#123; good.img &#125;&#125;&quot; alt=&quot;&quot; style=&quot;width: 300px;height: 200px&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125;&lt;/table&gt; 视图添加商品12345678910111213141516171819202122232425from django.shortcuts import render, redirectfrom django.views import Viewfrom app01.models import Goods# Create your views here.class GoodsCreateView(View): def get(self, request): return render(request, &#x27;goods.html&#x27;) def post(self, request): name = request.POST.get(&#x27;name&#x27;) price = request.POST.get(&#x27;price&#x27;) nums = request.POST.get(&#x27;nums&#x27;) img = request.FILES.get(&#x27;img&#x27;) if not all([name, price, nums, img]): return redirect(&#x27;goods:create&#x27;) try: Goods.objects.create(name=name, price=price, nums=nums, img=img) except Exception as e: print(e) return redirect(&#x27;goods:create&#x27;) return redirect(&#x27;goods:index&#x27;) 展示商品12345class IndexView(View): def get(self, request): goods = Goods.objects.all() return render(request, &#x27;index.html&#x27;, context=&#123;&#x27;goods&#x27;: goods&#125;)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"图片上传","slug":"图片上传","permalink":"https://www.bookandmusic.cn/tags/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"}]},{"title":"DRF-JWT认证、权限、限流","slug":"DRF-JWT认证、权限、限流","date":"2020-03-15T15:22:25.000Z","updated":"2021-06-10T14:41:54.089Z","comments":true,"path":"2020/03/15/drf-jwt-ren-zheng-quan-xian-xian-liu/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/15/drf-jwt-ren-zheng-quan-xian-xian-liu/","excerpt":"","text":"DRF框架的一系列功能：认证、权限、限流，都是依赖于JWT。 整个流程就是这样的: 客户端发送用户名和密码到服务端， 验证通过，生成JWT 返回JWT给客户端 下次，客户端发送请求时，携带JWT，一般是在请求头里加入Authorization，并加上JWT标注： 1234&#123; headers: &#123; &#x27;Authorization&#x27;: &#x27;JWT &#x27; + token&#125; 服务端会验证 token，如果验证通过就会返回相应的资源 在此基础上，可以实现权限和限流 流程图如下： 而目前，在DRF项目开发过程中，token的生成、认证，主要是通过rest_framework_jwt实行的。而 rest_framework_jwt实质是对 pyjwt的进一步封装，因此，如果需要一些特定功能时，就可以 使用 pyjwt自定义实现。 接下来主要以 Django+DRF + Vue的开发模式，简单介绍以 jwt作为凭证，实现 用户注册、登录、认证、权限等 一系列流程 以 Django 作为服务端准备工作环境搭建1pip install django django-cors-headers djangorestframework djangorestframework-jwt 项目配置信息 djangodemo/settings.py 1234567891011121314151617181920212223242526272829303132333435363738394041INSTALLED_APPS = [ ..., &#x27;rest_framework&#x27;, &#x27;corsheaders&#x27;, &#x27;users&#x27;]MIDDLEWARE = [ ... # &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, # 关闭csrf验证 ...]# 跨域参数,允许所有源访问CORS_ORIGIN_ALLOW_ALL = True# 自定义用户模型类AUTH_USER_MODEL = &#x27;users.UserModel&#x27;# 针对 drf 的配置信息， 全局配置 drf的视图的认证和权限REST_FRAMEWORK = &#123; # 指定视图权限 &#x27;DEFAULT_PERMISSION_CLASSES&#x27;: ( &#x27;rest_framework.permissions.AllowAny&#x27;, # 默认每个视图，允许任何用户访问 ), # 也可以在每个视图中指明权限类 # 指定drf认证机制 &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: ( &#x27;rest_framework_jwt.authentication.JSONWebTokenAuthentication&#x27;, # rest_framework_jwt认证， 也可以在每个视图中指明认证类 )&#125;# 针对 rest_framework_jwt 的配置信息JWT_AUTH = &#123; &#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;: # &#x27;rest_framework_jwt.utils.jwt_response_payload_handler&#x27;, # 默认jwt认证成功返回数据 &#x27;user.utils.jwt_response_payload_handler&#x27;, # 自定义jwt认证成功返回数据 &#x27;JWT_EXPIRATION_DELTA&#x27;: datetime.timedelta(seconds=300), # 指明token的有效期， 默认5分 &#x27;JWT_ALLOW_REFRESH&#x27;: True, # 允许刷新 &#x27;JWT_REFRESH_EXPIRATION_DELTA&#x27;: datetime.timedelta(days=7), # 在多久间隔内可以用旧token来刷新以便获取新的token，默认是7天&#125; 用户模型类 users/models.py 123456789101112131415from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass UserModel(AbstractUser): &quot;&quot;&quot;继承django内置的用户类，并重写，注意：必须在settings.py中指明&quot;&quot;&quot; phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机&#x27;) class Meta: ordering = [&#x27;id&#x27;] db_table = &#x27;db_user&#x27; verbose_name = &#x27;用户&#x27; verbose_name_plural = verbose_name def __str__(self): return self.username 序列化类 users/ser.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from rest_framework import serializersfrom .models import UserModelfrom django.contrib.auth.hashers import make_passwordimport reclass UserSerializer(serializers.ModelSerializer): def create(self, validated_data): return UserModel.objects.create_user(**validated_data) def update(self, instance, validated_data): instance.username = validated_data.get(&#x27;username&#x27;, instance.username) instance.phone = validated_data.get(&#x27;phone&#x27;, instance.phone) instance.email = validated_data.get(&#x27;email&#x27;, instance.email) password = validated_data[&#x27;password&#x27;] if not password: instance.password = make_password(password) instance.save() return instance def validate_password(self, value): &quot;&quot;&quot; 验证密码不能全是小写字母，不能全是大写字母，也不能全是数字 &quot;&quot;&quot; if not re.match(r&#x27;(?!^\\d*$)(?![a-z]$)(?![A-Z]$).&#123;6,&#125;$&#x27;, value): raise serializers.ValidationError(&#x27;密码等级不够&#x27;) return value def validate_phone(self, value): &quot;&quot;&quot; 校验手机号是否合法 &quot;&quot;&quot; if not re.match(r&#x27;1[3-7]\\d&#123;9&#125;$&#x27;, value): raise serializers.ValidationError(&#x27;手机号不合法&#x27;) return value class Meta: model = UserModel fields = (&#x27;id&#x27;, &#x27;username&#x27;, &#x27;phone&#x27;, &#x27;password&#x27;, &#x27;email&#x27;) read_only_fields = (&#x27;id&#x27;,) extra_kwargs = &#123; &#x27;password&#x27;: &#123; &#x27;write_only&#x27;: True &#125; &#125; 注册视图 users/views.py 123456789101112from rest_framework.generics import GenericAPIViewfrom rest_framework.mixins import CreateModelMixinfrom users.ser import UserSerializer, UserModel# 创建注册视图类class RegisterView(GenericAPIView, CreateModelMixin): queryset = UserModel.objects.all() serializer_class = UserSerializer def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) 路由123456from django.urls import pathfrom .views import *urlpatterns = [ path(&#x27;register/&#x27;, RegisterView.as_view()), # 注册路由 ] 登录修改登录验证方式默认django只支持用户名和密码登录，想要支持多种方式登录，必须重写认证类 users/utils.py 12345678910111213141516from .models import UserModelfrom django.contrib.auth.backends import ModelBackendclass UserModelBackend(ModelBackend): &quot;&quot;&quot;user验证&quot;&quot;&quot; def authenticate(self, request, username=None, password=None, **kwargs): try: if re.match(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;, username): user = UserModel.objects.get(phone=username) else: user = UserModel.objects.get(username=username) except UserModel.DoesNotExist: return None if user.check_password(password) and self.user_can_authenticate(user): return user token生成 登录成功，需要生成JWT，返回给客户端，之后的认证通过生成的jwt实现 默认视图登录时，调用 封装好的 obtain_jwt_token，默认返回 &#123;&#39;token&#39;: token&#125;; 如果还想要返回其他数据，需要自定义响应返回事件 视图类12# rest_framework_jwt插件已经内置了登录视图，登录成功，返回JWT,注意，默认登录成功只会返回token，如果想要其他用户信息，必须自定义返回数据rest_framework_jwt.views.obtain_jwt_token 自定义返回数据 users/utils.py 123456789def jwt_response_payload_handler(token, user=None, request=None): &quot;&quot;&quot; 自定义jwt认证成功返回数据 &quot;&quot;&quot; return &#123; &#x27;token&#x27;: token, &#x27;id&#x27;: user.id, &#x27;username&#x27;: user.username &#125; 路由1234567from django.urls import pathfrom rest_framework_jwt.views import obtain_jwt_token, refresh_jwt_tokenurlpatterns = [ path(r&#x27;api-token-auth/&#x27;, obtain_jwt_token), path(r&#x27;api-token-refresh/&#x27;, refresh_jwt_token),] 自定义视图可以调用内置的方法 jwt_payload_handler 和 jwt_encode_handler来产生token， 并且自己构建返回的响应数据 视图类12345678910111213141516171819202122232425262728293031from django.contrib.auth import authenticatefrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework_jwt.settings import api_settingsjwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLERjwt_encode_handler = api_settings.JWT_ENCODE_HANDLER# 自定义登录视图class LoginAPIView(APIView): def post(self, request): # 1. 获取用户信息 username = request.data.get(&#x27;username&#x27;) password = request.data.get(&#x27;password&#x27;) # 2. 认证用户 user = authenticate(request, username=username, password=password) # 3. 判断用户是否认证通过 if user: # 生成jwt payload = jwt_payload_handler(user) token = jwt_encode_handler(payload) return Response(&#123; &#x27;user&#x27;: user.username, &#x27;token&#x27;: token &#125;) else: return Response(&#123;&#x27;msg&#x27;: &#x27;登录失败&#x27;&#125;, status=400) 路由123456from django.urls import pathfrom user.views import LoginAPIViewurlpatterns = [ path(&#x27;login/&#x27;, LoginAPIView.as_view())] token刷新 如果 token过期时间设置太短，用户体验不好，过期时间设置太长，则不安全； 而 建议的做法则是：刷新token 在给用户返回token时, 我们给用户设置了两小时有效期, 还允许 7天之内刷新token，我们就需要返回： token、过期时间、刷新的期限 在Vue中判断 token是否即将过期或已经过期 如果已经过期，则需要用户重新登录 如果即将过期，且刷新的期限未过，则需要 携带现在的token，去django中 刷新token，同时更新所有数据 视图类12# rest_framework_jwt插件已经内置了刷新jwt视图，在 jwt失效之前，返回新的jwtrest_framework_jwt.views.refresh_jwt_token 路由123456from django.urls import pathfrom rest_framework_jwt.views import refresh_jwt_tokenurlpatterns = [path(r&#x27;api-token-refresh/&#x27;, refresh_jwt_token),] 个人中心当客户端请求个人信息时，需要携带上一步生成的token，因此，需要在 服务端验证token，从而判断是否允许进行下一步操作 客户端请求时，需要在请求头中添加参数 ,格式为： &#123;&#39;Authorization&#39; : &#39;JWT&#39; + &#39; &#39; + token&#125; 服务端认证token时，有多种方式可以实现 token的认证： 直接调用rest_framework_jwt内置的 JSONWebTokenAuthentication 认证类即可 继承 rest_framework.authentication.BaseAuthentication 或 rest_framework_jwt.authentication.BaseJSONWebTokenAuthentication, 然后重写认证类，最后用户对象即可 全局认证12345678REST_FRAMEWORK = &#123; # 指定drf认证机制 &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: [ &#x27;rest_framework_jwt.authentication.JSONWebTokenAuthentication&#x27;, # JWT认证 # &#x27;rest_framework.authentication.SessionAuthentication&#x27;, # session认证 # &#x27;rest_framework.authentication.BasicAuthentication&#x27;, # 基本认证 ]&#125; 局部认证可以在具体的视图中通过authentication_classes属性来设置 1234567891011from rest_framework_jwt.authentication import JSONWebTokenAuthentication# 个人信息 class UserInfoAPIView(APIView): authentication_classes = [JSONWebTokenAuthentication] # 指明认证类 def get(self, request): user = request.user # 只要认证成功，请求对象中就会存在 user对象 ser = UserInfoSerializer(user) return Response(ser.data) 访问权限上面的视图，仍然存在一个问题：客户端发送jwt，服务器可以正常解析出登录用户；但是，如果没有发送jwt，再通过request.user获取用户对象，就会出错。因此，需要对该功能进行权限验证，只有登录用户才可以访问，否则，就拒绝访问 总而言之，权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。 在执行视图的dispatch()方法前，会先进行视图访问权限的判断在通过get_object()获取具体对象时，会进行对象访问权限的判断 权限分为四类： AllowAny: 允许所有用户， 默认权限 IsAuthenticated: 仅通过认证的用户 IsAdminUser: 仅管理员用户 IsAuthenticatedOrReadOnly: 认证的用户可以完全操作，否则只能get读取 全局配置可以在项目的配置文件settings.py中设置默认的权限管理类 12345REST_FRAMEWORK = &#123; &#x27;DEFAULT_PERMISSION_CLASSES&#x27;: ( &#x27;rest_framework.permissions.IsAuthenticated&#x27;, )&#125; 如果未指明，则采用如下默认配置 12345REST_FRAMEWORK = &#123; &#x27;DEFAULT_PERMISSION_CLASSES&#x27;: ( &#x27;rest_framework.permissions.AllowAny&#x27;, )&#125; 局部配置可以在具体的视图中通过permission_classes属性来设置 1234567891011121314151617181920# 个人信息 class UserInfoAPIView(APIView): authentication_classes = [JSONWebTokenAuthentication] # 指明认证类 permission_classes = [IsAuthenticated] # 指明只有认证用户可以访问 def get(self, request): user = request.user # 只要认证成功，且权限校验通过，请求对象中就一定会存在 user对象 ser = UserInfoSerializer(user) return Response(ser.data) # 创建允许管理员查询所有用户的视图类class UserView(GenericAPIView, ListModelMixin): &quot;&quot;&quot;查询所有注册用户&quot;&quot;&quot; queryset = UserModel.objects.all() serializer_class = UserSerializer authentication_classes = [JSONWebTokenAuthentication] # 指明认证类 permission_classes = [IsAdminUser] # 指定权限验证,限制管理员才可以查询所有用户 def get(self, request, *args, **kwrags): return self.list(request, *args, **kwrags) 限流Throttling上面的视图可以正常访问用户的个人信息，但是需要对接口访问的频次进行限制，以减轻服务器压力。特别是限制爬虫的抓取。 针对用户进行限制 可以在配置文件中，使用DEFAULT_THROTTLE_CLASSES 和 DEFAULT_THROTTLE_RATES进行全局配置 全局配置12345678910111213REST_FRAMEWORK = &#123; &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: ( # 限制所有匿名未认证用户，使用IP区分用户 &#x27;rest_framework.throttling.AnonRateThrottle&#x27;, # 限制认证用户，使用User id 来区分 &#x27;rest_framework.throttling.UserRateThrottle&#x27; ), &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123; # 可以使用 second, minute, hour 或day来指明周期 &#x27;anon&#x27;: &#x27;3/minute&#x27;, &#x27;user&#x27;: &#x27;5/minute&#x27; &#125;&#125; 局部配置视图中使用throttle_classes属性设置限流用户类型 12345678910111213141516from rest_framework.generics import GenericAPIViewfrom rest_framework.mixins import ListModelMixinfrom rest_framework.throttling import UserRateThrottle, AnonRateThrottlefrom .serializer import UserSerializer, Userclass UserView(GenericAPIView, ListModelMixin): &quot;&quot;&quot;查询所有注册用户&quot;&quot;&quot; queryset = UserModel.objects.all() serializer_class = UserSerializer authentication_classes = [JSONWebTokenAuthentication] permission_classes = [IsAdminUser] throttle_classes = (UserRateThrottle, AnonRateThrottle) def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) 在项目配置文件中针对用户类型设置具体频率 1234567REST_FRAMEWORK = &#123; &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123; # 可以使用 second, minute, hour 或day来指明周期 &#x27;anon&#x27;: &#x27;3/minute&#x27;, &#x27;user&#x27;: &#x27;5/minute&#x27; &#125;&#125; 针对视图限制视图中使用throttle_scope属性设置具体配置信息 12345678910111213from rest_framework.generics import GenericAPIViewfrom rest_framework.mixins import ListModelMixinfrom rest_framework.permissions import IsAuthenticatedfrom .serializer import UserSerializer, Userclass UserView(GenericAPIView, ListModelMixin): queryset = User.objects.all() serializer_class = UserSerializer throttle_scope = &#x27;downloads&#x27; def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) 在项目配置文件中设置具体频率 1234567&#x27;DEFAULT_THROTTLE_CLASSES&#x27;: ( # 限制用户对于每个视图的访问频次，使用ip或user id &#x27;rest_framework.throttling.ScopedRateThrottle&#x27;,),&#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123; &#x27;downloads&#x27;: &#x27;3/minute&#x27;&#125; 以 Vue 作为前端路由前置守卫 router/index.js 1234567891011121314151617181920212223242526272829303132333435import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Login from &#x27;@/components/Login&#x27;import Users from &#x27;@/components/Users&#x27;Vue.use(Router);let router = new Router(&#123; routes: [ &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: Login &#125;, &#123; path: &#x27;/Users&#x27;, name: &#x27;Users&#x27;, component: Users &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; const isLogin = localStorage.getItem(&#x27;token&#x27;) ? true : false; if (to.path == &#x27;/login&#x27; || to.path == &#x27;/register&#x27;) &#123; //&#x27;login&#x27;和&#x27;register&#x27;相当于是路由白名单 localStorage.setItem(&quot;preRoute&quot;, router.currentRoute.fullPath); next(); &#125; else &#123; //如果token存在，就正常跳转，如果不存在，则说明未登陆，则跳转到&#x27;login&#x27; isLogin ? next() : next(&quot;/login&quot;); &#125;&#125;)export default router axios拦截器 main.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;http://127.0.0.1:8000/&#x27;// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前, 添加 token 到请求头 if (localStorage.token) &#123; config.headers[&#x27;Authorization&#x27;] = &#x27;JWT &#x27; + localStorage.getItem(&#x27;token&#x27;); config.headers[&#x27;Accept&#x27;] = &#x27;application/json&#x27;; &#125; return config;&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;);// 自定义的 axios 响应拦截器axios.interceptors.response.use((response) =&gt; &#123; // 判断一下响应中是否有 token，如果有就直接使用此 token 替换掉本地的 token。你可以根据你的业务需求自己编写更新 token 的逻辑 var token = response.data.token; if (token) &#123; localStorage.setItem(&#x27;token&#x27;, token); &#125; return response&#125;, (error) =&gt; &#123; if (error.response) &#123; switch (error.response.status) &#123; case 401: // 这里写清除token的代码 console.log(&quot;401&quot;) localStorage.removeItem(&#x27;token&#x27;); /* 普通401拦截直接返回到登录页面 */ router.push(&#x27;/login&#x27;); &#125; &#125; return Promise.reject(error)&#125;);Vue.prototype.$axios = axios 登录页面1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; 用户名: &lt;input type=&quot;text&quot; v-model=&quot;userInfo.username&quot;/&gt; &lt;br&gt; 密码: &lt;input type=&quot;text&quot; v-model=&quot;userInfo.password&quot;/&gt; &lt;br&gt; &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;login&quot;, data() &#123; return &#123; userInfo: &#123; username: &quot;&quot;, password: &quot;&quot;, &#125;, &#125;; &#125;, methods: &#123; login() &#123; this.$axios .post(&quot;users/login/&quot;, this.userInfo) .then((resp) =&gt; &#123; const curr = localStorage.getItem(&#x27;preRoute&#x27;); if (curr == null) &#123; this.$router.push(&#123;path: &quot;/user_center&quot;&#125;); &#125; else &#123; this.$router.push(&#123;path: curr&#125;); &#125; this.$router.push(&#123;path: decodeURIComponent(url)&#125;); &#125;) .catch((err) =&gt; &#123; &#125;); &#125;, &#125;,&#125;;&lt;/script&gt; 用户个人中心12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; &#123;&#123; user.id &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.username &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.phone &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; user: &quot;&quot; &#125; &#125;, methods: &#123; getData() &#123; this.$axios.get(&#x27;/userinfo/&#x27;) .then(resp =&gt; &#123; console.log(resp.data) this.user = resp.data &#125;) &#125; &#125;, mounted() &#123; this.getData(); &#125;&#125;&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"DRF","slug":"技术/python/DRF","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/DRF/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://www.bookandmusic.cn/tags/JWT/"},{"name":"权限","slug":"权限","permalink":"https://www.bookandmusic.cn/tags/%E6%9D%83%E9%99%90/"},{"name":"认证","slug":"认证","permalink":"https://www.bookandmusic.cn/tags/%E8%AE%A4%E8%AF%81/"},{"name":"限流","slug":"限流","permalink":"https://www.bookandmusic.cn/tags/%E9%99%90%E6%B5%81/"}]},{"title":"Django-用户认证","slug":"Django-用户认证系统","date":"2020-03-10T13:34:46.000Z","updated":"2021-06-12T06:32:29.525Z","comments":true,"path":"2020/03/10/django-yong-hu-ren-zheng-xi-tong/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/10/django-yong-hu-ren-zheng-xi-tong/","excerpt":"","text":"项目框架 项目结构 12345678910111213141516171819202122232425.├── users│ ├── __init__.py│ ├── admin.py│ ├── apps.py│ ├── migrations│ │ └── __init__.py│ ├── models.py│ ├── tests.py│ ├── urls.py│ └── views.py├── db.sqlite3├── manage.py├── django_demo│ ├── __init__.py│ ├── settings.py│ ├── urls.py│ └── wsgi.py└── templates ├── base.html ├── index.html ├── login.html ├── register.html └── user.html 准备工作 创建项目通过终端命令,创建项目 1django_admin startproject django_demo 生成应用通过终端命令,生成users应用 12# 此时在项目文件夹之下执行命令python manage.py startapp users 修改配置信息在settings.py修改配置 1234567891011121314151617181920212223242526272829303132# 注册appINSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;users.apps.UsersConfig&#x27; # 注册users应用]# 配置模板路径TEMPLATES = [ &#123; &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;, &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &quot;templates&quot;)], &#x27;APP_DIRS&#x27;: True, &#x27;OPTIONS&#x27;: &#123; &#x27;context_processors&#x27;: [ &#x27;django.template.context_processors.debug&#x27;, &#x27;django.template.context_processors.request&#x27;, &#x27;django.contrib.auth.context_processors.auth&#x27;, &#x27;django.contrib.messages.context_processors.messages&#x27;, ], &#125;, &#125;,]# 语言设置和时区设置LANGUAGE_CODE = &#x27;zh-hans&#x27;TIME_ZONE = &#x27;Asia/Shanghai&#x27; 拓展User模型类Django 用户认证系统提供了一个内置的 User 对象，用于记录用户的用户名，密码等个人信息。对于 Django 内置的 User 模型， 仅包含以下一些主要的属性： username，即用户名 password，密码 email，邮箱 first_name，名 last_name，姓 对于一些网站来说，用户可能还包含有昵称、头像、个性签名等等其它属性，因此仅仅使用 Django 内置的 User 模型是不够。好在 Django 用户系统遵循可拓展的设计原则，我们可以方便地拓展 User 模型。 继承 AbstractUser 拓展用户模型 这是推荐做法。事实上，查看 User 模型的源码就知道，User 也是继承自 AbstractUser 抽象基类，而且仅仅就是继承了 AbstractUser，没有对 AbstractUser 做任何的拓展。 所以，如果我们继承 AbstractUser，将获得 User 的全部特性，而且还可以根据自己的需求进行拓展。 我们之前新建了一个 users 应用，通常我们把和数据库模型相关的代码写在 models.py 文件里。打开 users/models.py 文件，写上我们自定义的用户模型代码： 1234567891011121314from django.db import modelsfrom django.contrib.auth.models import AbstractUser# Create your models here.class User(AbstractUser): phone = models.CharField(max_length=11, unique=True, verbose_name=&quot;手机号&quot;) class Meta(AbstractUser.Meta): db_table = &#x27;tb_users&#x27; # 指定表名 verbose_name = &#x27;用户&#x27; # 后台显示表名 verbose_name_plural = verbose_name def __str__(self): return self.username 我们给自定义的用户模型新增了一个 phone（手机号）属性，用来记录用户的联系方式，设置 unique=True 的目的是让用户在注册时，一个手机号只能注册一次。根据你的需求可以自己进一步拓展，例如增加用户头像、个性签名等等，添加多少属性字段没有任何限制。 同时，我们继承了 AbstractUser 的内部类属性 Meta 。在这里继承 Meta 的原因是在你的项目中可能需要设置一些 Meta 类的属性值，不要忘记继承 AbstractUser.Meta 中已有的属性。 此外，AbstractUser 类又继承自 AbstractBaseUser，前者在后者的基础上拓展了一套用户权限（Permission）系统。因此如非特殊需要，尽量不要从 AbstractBaseUser 拓展，否则你需要做更多的额外工作。 为了让 Django 用户认证系统使用我们自定义的用户模型，必须在 settings.py 里通过 AUTH_USER_MODEL 指定自定义用户模型所在的位置，即需要如下设置： 12# 配置规则：AUTH_USER_MODEL = &#x27;应用名.模型类名&#x27;AUTH_USER_MODEL = &#x27;users.User&#x27; 设置好自定义用户模型后，生成数据库迁移文件，并且迁移数据库以生成各个应用必要的数据库表。即运行如下两条命令： 12$ python manage.py makemigrations$ python manage.py migrate OK，现在 Django 用户系统使用的用户模型就是自定义的 User 模型了。 注意：一定要在设置好 AUTH_USER_MODEL = &#39;users.User&#39; 后在第一次迁移数据库，即指定好自定义的用户模型后再执行数据库迁移命令。 创建基础模板在项目根路径下,创建templates,在目录下创建base.html文件,以便后面复用 对于一个网站来说，比较好的用户体验是登录、注册和注销后跳转回用户之前访问的页面。否则用户在你的网站东跳转西跳转好不容易找到了想看的内容，结果他已登录给他跳转回了首页，这会使用户非常愤怒。接下来我们看看如何让登录、注册和注销后跳转回用户之前访问的页面。 其实现的原理是，在登录和注销的流程中，始终传递一个 next 参数记录用户之前访问页面的 URL。因此，我们需要做的就是在用户访问登录或者注销的页面时，在 URL 中传递一个 next 参数给视图函数，具体做法如下： 123456789101112131415161718192021222324&#123;% block nav %&#125; &lt;p&gt; &lt;a href=&quot;&#123;% url &#x27;users:index&#x27; %&#125;&quot;&gt;Index&lt;/a&gt; &#123;% if user.is_authenticated %&#125; Hello, &lt;a href=&quot;&#123;% url &#x27;users:user&#x27; %&#125;&quot;&gt;&#123;&#123; user.username &#125;&#125; &lt;/a&gt; . &lt;a href=&quot;&#123;% url &#x27;users:logout&#x27; %&#125;?next=&#123;&#123; request.path &#125;&#125;&quot;&gt;退出&lt;/a&gt; &#123;% else %&#125; &lt;a href=&quot;&#123;% url &#x27;users:register&#x27; %&#125;?next=&#123;&#123; request.path &#125;&#125;&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;&#123;% url &#x27;users:login&#x27; %&#125;?next=&#123;&#123; request.path &#125;&#125;&quot;&gt;登录&lt;/a&gt; &#123;% endif %&#125; &lt;/p&gt;&#123;% endblock %&#125;&#123;% block err %&#125; &#123;% if account_msg %&#125; &lt;p&gt;&#123;&#123;account_msg&#125;&#125;. Please try again.&lt;/p&gt; &#123;% endif %&#125;&#123;% endblock %&#125;&#123;% block body %&#125;&#123;% endblock %&#125; 可以看到，我们在注册、登录和注销的 URL 后加了 next 参数，其值为 &#123;&#123; request.path &#125;&#125;。request.path 是用户当前访问页面的 URL。在 URL 中传递参数的方法就是在要传递的参数前加一个 ？然后写上传递的参数名和参数值，用等号链接。关于在 URL 中传递参数具体请 HTTP 的相关协议。 为了在整个登录流程中记录 next 的值，还需要在表单中增加一个表单控件，用于传递 next 值。 自定义认证后台Django auth 应用默认支持用户名（username）进行登录。但是在实践中，网站可能还需要邮箱、手机号、身份证号等进行登录，这就需要我们自己写一个认证后台，用于验证用户输入的用户信息是否正确，从而对拥有正确凭据的用户进行登录认证。 Django 对用户登录的验证工作均在一个被称作认证后台（Authentication Backend）的类中进行。这个类是一个普通的 Python 类，它有一个 authenticate 方法，接收登录用户提供的凭据（如用户名或者邮箱以及密码）作为参数，并根据这些凭据判断用户是否合法（即是否是已注册用户，密码是否正确等）。 可以定义多个认证后台，Django 内部会逐一调用这些后台的 authenticate 方法来验证用户提供登录凭据的合法性，一旦通过某个后台的验证，表明用户提供的凭据合法，从而允许登录该用户。 自定义Backend123456789101112131415from .models import UserModelfrom django.contrib.auth.backends import ModelBackendclass EmailBackend(ModelBackend): &quot;&quot;&quot;user验证&quot;&quot;&quot; def authenticate(self, request, username=None, password=None, **kwargs): try: user = UserModel.objects.get(email=username) except UserModel.DoesNotExist: return None # 校验用户密码，且用户为激活用户 if user.check_password(password) and self.user_can_authenticate(user): return user 配置 Backend接下来就要告诉 Django，需要使用哪些 Backends 对用户的凭据信息进行验证，这需要在 settings.py 中设置： 1234AUTHENTICATION_BACKENDS = ( &#x27;django.contrib.auth.backends.ModelBackend&#x27;, &#x27;users.backends.EmailBackend&#x27;,) 第一个 Backend 是 Django 内置的 Backend，当用户提供的是用户名和正确的密码时该 Backend 会通过验证；第二个 Backend 是刚刚自定义的 Backend，当用户提供的是 Email 和正确的密码时该 Backend 会通过验证。 注册用户注册就是创建用户对象，将用户的个人信息保存到数据库里。回顾一下 Django 的 MVT 经典开发流程，对用户注册功能来说，首先创建用户模型（M），这一步我们已经完成了。编写注册视图函数（V），并将为视图函数绑定对应的 URL。编写注册模板（T），模板中提供一个注册表单给用户。Django 用户系统内置了登录、修改密码、找回密码等视图，但是唯独用户注册的视图函数没有提供，这一部分需要我们自己来写。 视图首先来分析一下注册函数的逻辑。 首先用户请求注册表单，然后服务器的视图函数给用户提供注册表单； 用户在注册表单里填写注册信息，然后通过表单将这些信息提交给服务器。 视图函数从用户提交的数据提取用户的注册信息，然后验证这些数据的合法性。 如果数据合法，就新建一个用户对象，将用户的数据保存到数据库，否则就将错误信息返回给用户，提示用户对提交的信息进行修改。 注册成功，跳转到登录页面 过程就是这么简单，下面是对应的代码（视图函数的代码通常写在 views.py 文件里）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from django.contrib.auth.hashers import make_passwordfrom django.views import Viewfrom django.shortcuts import render, reverse, redirectfrom django.http import HttpResponseForbiddenfrom .models import Userclass RegisterView(View): def get(self, request): next = request.GET.get(&#x27;next&#x27;) # 判断用户是否登录(属性) user.is_authenticated if request.user.is_authenticated: if next: return redirect(next) else: return redirect(reverse(&#x27;users:index&#x27;)) # 1. 提供注册页面 return render(request, &#x27;register.html&#x27;, context=&#123;&#x27;next&#x27;: next&#125;) def post(self, request): # 2.1 获取用户的注册信息 username = request.POST.get(&quot;username&quot;) password = request.POST.get(&quot;password&quot;) password2 = request.POST.get(&quot;password2&quot;) phone = request.POST.get(&quot;phone&quot;) next = request.POST.get(&#x27;next&#x27;, &#x27;&#x27;) # 2.2 验证数据的合法性 if not all([username, password, password2, phone]): return render(request, &#x27;index.html&#x27;,context=&#123;&#x27;next&#x27;: next, &#x27;err_msg&#x27;: &#x27;缺少必要参数&#x27;&#125;) if password != password2: return render(request, &#x27;index.html&#x27;, context=&#123;&#x27;next&#x27;: next, &#x27;pwd_msg&#x27;: &#x27;密码不一致&#x27;&#125;) if not re.match(&#x27;^(13\\d|14[5|7]|15\\d|166|17[3|6|7]|18\\d)\\d&#123;8&#125;$&#x27;): return render(request, &#x27;index.html&#x27;, context=&#123;&#x27;next&#x27;: next, &#x27;phone_msg&#x27;: &#x27;手机号不合法&#x27;&#125;) # 2.3 新建用户对象 # 此时 手动加密密码 # hash_password = make_password(password) # try: # user = User(username=username, password=hash_password, phone=phone) # user.save() # except Exception as e: # return HttpResponseForbidden(&quot;创建失败&quot;) try: # Django认证系统用户模型类提供的 create_user() 方法创建新的用户。 # create_user() 方法中封装了 set_password() 方法加密密码 user = User.objects.create_user(username=username, password=password, phone=phone) except Exception as e: return render(request, &#x27;index.html&#x27;, context=&#123;&#x27;next&#x27;: next, &#x27;err_msg&#x27;: &#x27;创建失败&#x27;&#125;) # 2.4 注册成功，跳转回注册前页面 if next: return redirect(next) else: return redirect(&#x27;/&#x27;) 模板在表单中增加了一个隐藏的 input 控件，其值为 &#123;&#123; next &#125;&#125;，即之前通过 URL 参数传递给注册视图函数的，然后注册视图函数又将该值传递给了 index.html 模板。这样在整个注册流程中，始终有一个记录着用户在注册前页面 URL 的变量 next 在视图和模板间来回传递，知道用户注册成功后再跳转回 next 记录的页面 URL。 123456789101112131415&#123;% extends &quot;base.html&quot; %&#125;&#123;% block body %&#125; &lt;form action=&quot;&#123;% url &#x27;users:register&#x27; %&#125;&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; 确认密码:&lt;input type=&quot;password&quot; name=&quot;password2&quot;&gt; &#123;&#123;pwd_msg&#125;&#125; &lt;br&gt; 手机号: &lt;input type=&quot;phone&quot; name=&quot;phone&quot;&gt; &#123;&#123;phone_msg&#125;&#125; &lt;br&gt; &lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&#123;&#123; next &#125;&#125;&quot;/&gt; &lt;p&gt; &#123;&#123;err_msg&#125;&#125; &lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&#123;% endblock %&#125; 登录视图123456789101112131415161718192021222324252627282930313233343536373839404142434445class LoginView(View): def get(self, request): next = request.GET.get(&#x27;next&#x27;) # 判断用户是否登录(属性) user.is_authenticated if request.user.is_authenticated: if next: return redirect(next) else: return redirect(reverse(&#x27;users:login&#x27;)) return render(request, &quot;login.html&quot;, context=&#123;&#x27;next&#x27;: next&#125;) def post(self, request): username = request.POST.get(&quot;username&quot;) password = request.POST.get(&quot;password&quot;) remembered = request.POST.get(&quot;remembered&quot;) next = request.POST.get(&#x27;next&#x27;, &#x27;&#x27;) if not all([username, password]): # return JsonResponse(&#123;&quot;account_msg&quot;: &quot;缺少必要参数&quot;, &quot;code&quot;: 403&#125;) return render(request, &#x27;login.html&#x27;, &#123;&#x27;account_msg&#x27;: &#x27;缺少必要参数&#x27;, &quot;next&quot;: next&#125;) # 校验用户信息，成功返回user对象，否则为None user = authenticate(username=username, password=password) if user is None: return render(request, &#x27;login.html&#x27;, &#123;&#x27;account_msg&#x27;: &#x27;用户名或密码错误&#x27;, &quot;next&quot;: next&#125;) # 实现状态保持 login(request, user) # 设置状态保持的周期 if remembered != &#x27;on&#x27;: # 没有记住用户：浏览器会话结束就过期 request.session.set_expiry(0) else: # 记住用户：None表示两周后过期 request.session.set_expiry(None) # 响应登录结果 if next: return redirect(next) else: return redirect(reverse(&#x27;users:index&#x27;)) 模板类似注册流程中，有next变量始终保留跳转前的地址，在模板和视图之间传递 123456789101112131415&#123;% extends &quot;base.html&quot; %&#125;&#123;% block body %&#125; &lt;form method=&quot;post&quot; action=&quot;&#123;% url &#x27;users:login&#x27; %&#125;&quot;&gt; &#123;% csrf_token %&#125; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; 记住登录 &lt;input type=&quot;checkbox&quot; name=&quot;remembered&quot; value=&#x27;on&#x27;&gt; &lt;button name=&quot;submit&quot;&gt;login&lt;/button&gt; &lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&#123;&#123; next &#125;&#125;&quot;/&gt; &lt;/form&gt;&#123;% endblock %&#125; 注销视图12345678910111213141516class LogoutView(View): def get(self, request): index = reverse(&#x27;users:index&#x27;) next = request.GET.get(&#x27;next&#x27;, index) &quot;&quot;&quot;实现退出登录逻辑&quot;&quot;&quot; # 清理session logout(request) # 退出登录，重定向到首页 response = redirect(next) # 退出登录时清除cookie中的username response.delete_cookie(&#x27;username&#x27;) return response 用户信息视图12345678910111213141516171819202122232425262728293031323334353637383940414243class UserView(View): def get(self, requset): # 如果用户没有登陆就访问本应登陆才能访问的页面时会直接跳转到登陆页面 user = requset.user if user.is_authenticated: return render(requset, &#x27;user.html&#x27;, context=&#123;&#x27;user&#x27;: user&#125;) else: return redirect(reverse(&#x27;users:login&#x27;, kwargs=&#123;&quot;next&quot;: request.path&#125;)) def post(self, request): user = requset.user if not user.is_authenticated: return redirect(reverse(&#x27;users:login&#x27;, kwargs=&#123;&quot;next&quot;: request.path&#125;)) old_password = request.POST.get(&quot;old_password&quot;) new_password = request.POST.get(&quot;new_password&quot;) conf_password = request.POST.get(&quot;conf_password&quot;) if not all([old_password, new_password, conf_password]): return render(request, &#x27;user.html&#x27;, &#123;&#x27;user&#x27;: user, &#x27;account_msg&#x27;: &#x27;缺少必要参数&#x27;&#125;) if new_password != conf_password: return render(request, &#x27;user.html&#x27;, &#123;&#x27;user&#x27;: user, &#x27;account_msg&#x27;: &#x27;密码不一致&#x27;&#125;) # 校验密码 check_password() if not request.user.check_password(old_password): return render(request, &#x27;user.html&#x27;, &#123;&#x27;user&#x27;: user, &#x27;account_msg&#x27;: &#x27;密码不正确&#x27;&#125;) user = request.user # 修改密码 user.set_password(new_password) # user.password = make_password(new_password) # 保存修改 user.save() # 状态保持 login(request, user) return render(requset, &#x27;user.html&#x27;, context=&#123;&#x27;user&#x27;: user&#125;) 模板1234567891011121314151617181920&#123;% extends &#x27;base.html&#x27; %&#125;&#123;% block body %&#125; &lt;p&gt; 用户名： &#123;&#123;user.username&#125;&#125; &lt;/p&gt; &lt;p&gt; 邮箱： &#123;&#123;user.email&#125;&#125; &lt;/p&gt; &lt;p&gt; 手机号： &#123;&#123;user.phone&#125;&#125; &lt;/p&gt; &lt;form action=&quot;&#123;% url &#x27;users:user&#x27; %&#125;&quot; method=&quot;post&quot;&gt; 旧密码: &lt;input type=&quot;password&quot; name=&quot;old_password&quot;&gt; 新密码: &lt;input type=&quot;password&quot; name=&quot;new_password&quot;&gt; 确认密码: &lt;input type=&quot;password&quot; name=&quot;conf_password&quot;&gt; &lt;button name=&quot;submit&quot;&gt;确认修改&lt;/button&gt; &lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&#123;% url &#x27;users:index&#x27; %&#125;&quot;/&gt; &lt;/form&gt;&#123;% endblock %&#125; 首页视图1234class IndexView(View):def get(self, request): return render(request, &#x27;index.html&#x27;) 模板12345&#123;% extends &#x27;base.html&#x27; %&#125;&#123;% block body %&#125; &lt;h1&gt;欢迎来到首页&lt;/h1&gt;&#123;% endblock %&#125; 路由django_demo\\urls.py中配置总路由 1234567from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;users/&#x27;, include(&quot;users.urls&quot;,&quot;users&quot;))] users\\urls.py中配置子路由 123456789101112from django.urls import pathfrom .views import RegisterView, LoginView, IndexView, LogoutView, UserViewapp_name = &quot;users&quot;urlpatterns = [ path(&#x27;register/&#x27;, RegisterView.as_view(), name=&quot;register&quot;), path(&#x27;login/&#x27;, LoginView.as_view(), name=&quot;login&quot;), path(&#x27;logout/&#x27;, LogoutView.as_view(), name=&quot;logout&quot;), path(&quot;user/&quot;, UserView.as_view(), name=&#x27;user&#x27;), path(&#x27;&#x27;, IndexView.as_view(), name=&quot;index&quot;)]","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"auth","slug":"auth","permalink":"https://www.bookandmusic.cn/tags/auth/"},{"name":"user","slug":"user","permalink":"https://www.bookandmusic.cn/tags/user/"}]},{"title":"Axios(四):跨域请求","slug":"vue-Axios(四)跨域请求","date":"2020-03-03T09:55:30.000Z","updated":"2020-12-01T14:23:48.000Z","comments":true,"path":"2020/03/03/vue-axios-si-kua-yu-qing-qiu/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/03/vue-axios-si-kua-yu-qing-qiu/","excerpt":"","text":"在前后端开发过程中一直会伴随我们的问题就是跨域问题，因为这时候前端和后端的代码是在不同机器上运行的，两个地址不在一个域名下，这个时候前端脚本在进行axios访问的时候浏览器就会报跨域相关的错误。 原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。 1. 设置代理服务器,实现跨域请求转发方案：采用proxyTable解决。 proxyTable是什么？ vue-cli提供的解决vue开发环境下跨域问题的方法，proxyTable的底层使用了http-proxy-middleware,它是http代理中间件，它依赖node.js，基本原理是用服务端代理解决浏览器跨域 实现的过程就是在我们前端的本地起一个服务，然后我们前端的所有ajax访问首选访问我们本地的服务，本地的服务不会对来的请求做加工处理，只是将请求转发到我们真实的后台服务上去。我们本地的服务其实你就是一个中转站。这种解决方案就是利用后端之间访问是不存在跨域的问题。 具体流程 首先在config/index.js里面找到proxyTable:&#123;&#125;,然后在里面加入 1234567&quot;/api&quot;:&#123; target: &#x27;https://www.runoob.com&#x27;, changeOrigin: true, pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;&#x27; &#125;&#125; 注意: /api: 是自定义的，写成什么都可以。 target: 设置要调用的接口域名和端口号。 ^/api: 代替target里面的地址，后面组件中我们调接口时直接用/api代替 在组件中实现跨域请求 比如要访问&#39;https://www.runoob.com/ajax/json_demo.json&#39;，直接写/api/ajax/json_demo.json即可。 123456789import axios from &#x27;axios&#x27;axios.get(&#x27;/api/ajax/json_demo.json&#x27;) .then(resp=&gt;&#123; console.log(resp.data) &#125;) .cath(err=&gt;&#123; console.log(err) &#125;) 然而我们可以在src/main.js设置一个基础路径，这样你调用接口的时候可以不写api,直接写/ajax/json_demo.json即可。 在src/main.js设置axios.defaults.baseURL=&quot;/api&quot;; 12import axios from &#x27;axios&#x27;axios.defaults.baseURL=&quot;/api&quot;; 在组件中直接调用接口即可。 123456789import axios from &#x27;axios&#x27;axios.get(&#x27;/ajax/json_demo.json&#x27;) .then(resp=&gt;&#123; console.log(resp.data) &#125;) .cath(err=&gt;&#123; console.log(err) &#125;) 2. 在后台django中配置跨域请求允许 但是今天我们这里不讲这种方式，有兴趣的可以在我的另一篇博客看到","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://www.bookandmusic.cn/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"axios","slug":"axios","permalink":"https://www.bookandmusic.cn/tags/axios/"},{"name":"vue","slug":"vue","permalink":"https://www.bookandmusic.cn/tags/vue/"}]},{"title":"Axios(一):axios在vue中的使用教程","slug":"vue-Axios(一)Axios在vue中的使用教程","date":"2020-03-03T09:25:10.000Z","updated":"2021-06-11T15:01:18.800Z","comments":true,"path":"2020/03/03/vue-axios-yi-axios-zai-vue-zhong-de-shi-yong-jiao-cheng/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/03/vue-axios-yi-axios-zai-vue-zhong-de-shi-yong-jiao-cheng/","excerpt":"","text":"在 vue项目中使用axios分为局部使用和全局使用 在vue中局部使用123456789import axios from &#x27;axios&#x27;axios.get(&#x27;/api/goods/add_info/?ID=12345&amp;firstName=Fred&amp;lastName=Flintstone&#x27;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 在vue中全部使用axios 是一个基于 promise 的 HTTP 库，所以是不能使用vue.use()方法的。那么难道我们要在每个文件都要来引用一次axios吗？多繁琐！！！☞解决方法有很多种： 1.结合 vue-axios使用看了vue-axios的源码，它是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了 首先在主入口文件main.js中引用： 1234import axios from &#x27;axios&#x27;import VueAxios from &#x27;vue-axios&#x27;Vue.use(VueAxios,axios); 之后就可以使用了，在组件文件中的methods里去使用了： 1234567getNewsList()&#123; this.axios.get(&#x27;api/getNewsList&#x27;).then((response)=&gt;&#123; this.newsList=response.data.data; &#125;).catch((response)=&gt;&#123; console.log(response); &#125;)&#125; 2.axios 改写为 Vue 的原型属性（不推荐这样用） 首先在主入口文件main.js中引用，之后挂在vue的原型链上： 12import axios from &#x27;axios&#x27;Vue.prototype.$axios= axios 在组件中使用 123456this.$ajax.get(&#x27;api/getNewsList&#x27;).then((response)=&gt;&#123; this.newsList=response.data.data;&#125;).catch((response)=&gt;&#123; console.log(response);&#125;) 3. 结合Vuex的action 在vuex的仓库文件store.js中引用，使用action添加方法 12345678910111213141516171819202122232425import Vue from &#x27;Vue&#x27;import Vuex from &#x27;vuex&#x27;import axios from &#x27;axios&#x27;Vue.use(Vuex)const store = new Vuex.Store(&#123;// 定义状态state: &#123; user: &#123; name: &#x27;xiaoming&#x27; &#125;&#125;,actions: &#123; // 封装一个 ajax 方法 login (context) &#123; axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user&#x27;, data: context.state.user &#125;) &#125;&#125;&#125;)export default store 在组件中发送请求的时候，需要使用 this.$store.dispatch 12345methods: &#123; submitForm () &#123; this.$store.dispatch(&#x27;login&#x27;) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"}],"tags":[{"name":"axios","slug":"axios","permalink":"https://www.bookandmusic.cn/tags/axios/"},{"name":"vue","slug":"vue","permalink":"https://www.bookandmusic.cn/tags/vue/"}]},{"title":"Axios(三):GET和POST提交数据","slug":"vue-Axios(三)GET和POST提交数据","date":"2020-03-03T09:05:24.000Z","updated":"2021-06-12T06:38:36.900Z","comments":true,"path":"2020/03/03/vue-axios-san-get-he-post-ti-jiao-shu-ju/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/03/vue-axios-san-get-he-post-ti-jiao-shu-ju/","excerpt":"","text":"GET 请求传递参数1、直接在 URL 上添加参数123456789import axios from &#x27;axios&#x27;axios.get(&#x27;/api/goods/add_info/?ID=12345&amp;firstName=Fred&amp;lastName=Flintstone&#x27;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 2、可以通过 params 设置参数123456789101112131415import axios from &#x27;axios&#x27;axios.get(&#x27;/api/goods/add_info/&#x27;, &#123; params: &#123; ID: 12345, firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27;, &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); POST 请求传递参数1、Content-Type: application/json1234567import axios from &#x27;axios&#x27;let data = &#123;&quot;code&quot;:&quot;1234&quot;,&quot;name&quot;:&quot;yyyy&quot;&#125;;axios.post(`$&#123;this.$url&#125;/test/testRequest`,data).then(res=&gt;&#123; console.log(&#x27;res=&gt;&#x27;,res);&#125;) 2、Content-Type: multipart/form-data12345678import axios from &#x27;axios&#x27;let data = new FormData();data.append(&#x27;code&#x27;,&#x27;1234&#x27;);data.append(&#x27;name&#x27;,&#x27;yyyy&#x27;);axios.post(`$&#123;this.$url&#125;/test/testRequest`,data).then(res=&gt;&#123; console.log(&#x27;res=&gt;&#x27;,res);&#125;) 3、Content-Type: application/x-www-form-urlencoded123456789import axios from &#x27;axios&#x27;import qs from &#x27;Qs&#x27;let data = &#123;&quot;code&quot;:&quot;1234&quot;,&quot;name&quot;:&quot;yyyy&quot;&#125;;axios.post(`$&#123;this.$url&#125;/test/testRequest`,qs.stringify(&#123; data&#125;)).then(res=&gt;&#123; console.log(&#x27;res=&gt;&#x27;,res);&#125;) 总结：1、上面三种方式会对应后台的请求方式，这个也要注意，比如django POST参数获取","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"}],"tags":[{"name":"axios","slug":"axios","permalink":"https://www.bookandmusic.cn/tags/axios/"},{"name":"vue","slug":"vue","permalink":"https://www.bookandmusic.cn/tags/vue/"},{"name":"参数发送","slug":"参数发送","permalink":"https://www.bookandmusic.cn/tags/%E5%8F%82%E6%95%B0%E5%8F%91%E9%80%81/"}]},{"title":"Axios(二):API说明","slug":"vue-Axios(二)API说明","date":"2020-03-03T05:30:05.000Z","updated":"2020-12-01T14:23:48.000Z","comments":true,"path":"2020/03/03/vue-axios-er-api-shuo-ming/","link":"","permalink":"https://www.bookandmusic.cn/2020/03/03/vue-axios-er-api-shuo-ming/","excerpt":"","text":"Axios API 可以通过向 axios 传递相关配置来创建请求 axios配置全部参数 1axios(config) 123456789// 发送 POST 请求axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;); axios中指定url和参数配置 1axios(url[, config]) 12// 发送 GET 请求（默认的方法）axios(&#x27;/user/12345&#x27;); 12345678// 发送 POST 请求axios(&#x27;/user/12345&#x27;, &#123; method: &#x27;post&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;); 请求方法的别名 为方便起见，为所有支持的请求方法提供了别名 1234567axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) NOTE:在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 axios请求方法 12345// 发送 POST 请求axios.post(&#x27;/user/12345&#x27;,&#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27;&#125;); 并发 处理并发请求的助手函数 12axios.all(iterable)axios.spread(callback) 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get(&#x27;/user/12345&#x27;);&#125;function getUserPermissions() &#123; return axios.get(&#x27;/user/12345/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成&#125;));","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"}],"tags":[{"name":"axios","slug":"axios","permalink":"https://www.bookandmusic.cn/tags/axios/"},{"name":"vue","slug":"vue","permalink":"https://www.bookandmusic.cn/tags/vue/"},{"name":"API","slug":"API","permalink":"https://www.bookandmusic.cn/tags/API/"}]},{"title":"主键约束和唯一性约束的区别","slug":"数据库-MySQL主键约束和唯一性约束的区别","date":"2020-02-26T00:33:14.000Z","updated":"2020-12-01T14:23:48.000Z","comments":true,"path":"2020/02/26/shu-ju-ku-mysql-zhu-jian-yue-shu-he-wei-yi-xing-yue-shu-de-qu-bie/","link":"","permalink":"https://www.bookandmusic.cn/2020/02/26/shu-ju-ku-mysql-zhu-jian-yue-shu-he-wei-yi-xing-yue-shu-de-qu-bie/","excerpt":"主键必然是唯一且不为空，但是唯一不一定是主键，而且主键只能有一个，但是唯一约束仅仅是为了保持某些列具有唯一性而已。所以可以有多列一张表里只能有一个主键约束，可以有多个唯一约束主键约束的字段不能为null，而唯一约束的字段可以为null值","text":"主键必然是唯一且不为空，但是唯一不一定是主键，而且主键只能有一个，但是唯一约束仅仅是为了保持某些列具有唯一性而已。所以可以有多列一张表里只能有一个主键约束，可以有多个唯一约束主键约束的字段不能为null，而唯一约束的字段可以为null值 主键约束（PRIMARY KEY）1) 主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。2) 是不可能（或很难）更新．3) 主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）．4) 主健可作外健，唯一索引不可； 唯一性约束（UNIQUE）1) 唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段，一个表上可以放置多个唯一性约束．2) 只要唯一就可以更新．3) 即表中任意两行在 指定列上都不允许有相同的值，允许空（NULL）．4) 一个表上可以放置多个唯一性约束","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"数据库","slug":"技术/数据库","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"技术/数据库/mysql","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[{"name":"主键约束","slug":"主键约束","permalink":"https://www.bookandmusic.cn/tags/%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F/"},{"name":"唯一约束","slug":"唯一约束","permalink":"https://www.bookandmusic.cn/tags/%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F/"}]},{"title":"Mysql操作","slug":"数据库-Mysql操作","date":"2019-12-12T00:33:14.000Z","updated":"2021-01-23T15:14:15.000Z","comments":true,"path":"2019/12/12/shu-ju-ku-mysql-cao-zuo/","link":"","permalink":"https://www.bookandmusic.cn/2019/12/12/shu-ju-ku-mysql-cao-zuo/","excerpt":"","text":"介绍如何在 Ubuntu系统上 安装mysql软件、以及如何创建用户信息。 Mysql软件操作以下所有操作以Ubuntu为例 mysql安装1sudo apt install mysql-server # 安装mysql mysql删除123sudo apt remove --upgrade mysql-* -y # 卸载mysqldpkg -l|grep ^rc|awk &#x27;&#123;print$2&#125;&#x27;|sudo xargs dpkg -P #清除配置 mysql服务123service mysql start # 启动服务service mysql stop # 停止服务service mysql restart # 重启服务 mysql用户操作一、创建用户1create user &#x27;username&#x27;@&#x27;host&#x27; identified with mysql_native_password BY &#x27;password&#x27;; username：你将创建的用户名 host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符% password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 mysql_native_password：用户加密方式，该方式为mysql8.0之前的加密方式，如果不写，则是mysql 8.0之后的加密方式caching_sha2_password 二、 修改用户信息1alter user &#x27;username&#x27;@&#x27;host&#x27; identified with mysql_native_password BY &#x27;password&#x27;; 参数同上 三、删除用户1drop user &#x27;username&#x27;@&#x27;host&#x27;; 参数同上 四、授权1grant privileges on databasename.tablename to &#x27;username&#x27;@&#x27;host&#x27;; privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如.* 其余参数同上 五、删除权限1revoke privileges on databasename.tablename to &#x27;username&#x27;@&#x27;host&#x27;; 参数同上 六、演示1234567891011# 创建一个可以从任意远程主机登陆的用户testcreate user &#x27;test&#x27;@&#x27;%&#x27; identified with mysql_native_password BY &#x27;123456&#x27;;# 创建数据库mydatacreate database mydata charset=utf8;# 对用户test授权，只能操作数据库mydatagrant all on mydata.* to &#x27;test&#x27;@&#x27;%&#x27;;# 刷新配置，立即启用修改flush privileges;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"数据库","slug":"技术/数据库","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"技术/数据库/mysql","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[{"name":"用户管理","slug":"用户管理","permalink":"https://www.bookandmusic.cn/tags/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"name":"mysql软件操作","slug":"mysql软件操作","permalink":"https://www.bookandmusic.cn/tags/mysql%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]},{"title":"Json模块","slug":"python模块-Json模块","date":"2019-11-25T06:30:27.000Z","updated":"2021-01-23T15:07:46.000Z","comments":true,"path":"2019/11/25/python-mo-kuai-json-mo-kuai/","link":"","permalink":"https://www.bookandmusic.cn/2019/11/25/python-mo-kuai-json-mo-kuai/","excerpt":"","text":"JSON介绍JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON 语法规则JSON是一个标记符的序列。JSON是一个序列化的对象或数组。 JSON 与 JS 对象的关系很多人搞不清楚 JSON 和 JS 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。如 123var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JS 对象互转要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法： 1var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;); //结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125; 要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法： 1var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;); //结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; JSON 和 PYTHON 对象互转要实现从JSON字符串转换为Python对象，使用 json.loads() 方法： 1234import jsona_dict = json.loads(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;) //结果是 &#123;&#x27;a&#x27;: &#x27;Hello&#x27;, &#x27;b&#x27;: &#x27;World&#x27;&#125;b_list = json.loads(&#x27;[1, 2, 3, 4]&#x27;) //结果是 [1, 2, 3, 4] 要实现从Python对象转换为JSON字符串，使用 json.dumps() 方法： 1234import jsona_obj = json.dumps(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;) //结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;b_obj = json.dumps([1, 2, 3, &#123;&quot;a&quot;:7&#125;]) //结果是 &#x27;[1, 2, 3, &#123;&quot;a&quot;: 7&#125;]&#x27; 要实现从Python对象转换为JSON字符串，并写入到json文件中，使用 json.dump() 方法： 12345import jsona_obj = &#x27;[12, 34, 56]&#x27;with open(&quot;1.json&quot;, &quot;w&quot;) as f: json.dump(a_obj,f) 要实现从json文件中读取JSON字符串，并转换为Python对象，使用 json.load() 方法： 12345import jsonwith open(&#x27;1.json&#x27;, &quot;r&quot;) as f: a_str = json.load(f) print(a_str)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"模块","slug":"技术/python/模块","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E6%A8%A1%E5%9D%97/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://www.bookandmusic.cn/tags/Json/"}]},{"title":"python面向对象","slug":"python面向对象-基础","date":"2019-11-04T14:36:03.000Z","updated":"2021-01-23T15:10:50.000Z","comments":true,"path":"2019/11/04/python-mian-xiang-dui-xiang-ji-chu/","link":"","permalink":"https://www.bookandmusic.cn/2019/11/04/python-mian-xiang-dui-xiang-ji-chu/","excerpt":"","text":"类与实例面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 仍以Student类为例，在Python中，定义类是通过class关键字： 12class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的： 1234567In [5]: s = Student()In [6]: sOut[6]: &lt;__main__.Student at 0x107615860&gt;In [7]: StudentOut[7]: &lt;class &#x27;__main__.Student&#x27;&gt; 可以看到，变量s指向的就是一个Student的实例，后面的0x107615860是内存地址，每个object的地址都不一样，而Student本身则是一个类。 可以自由地给一个实例变量绑定属性，比如，给实例s绑定一个name属性： 1234In [9]: s.name = &#x27;Bart Simpson&#x27;In [10]: s.nameOut[10]: &#x27;Bart Simpson&#x27; 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去： 12345class Student(object): def __init__(self, name, score): self.name = name self.score = score 注意：特殊方法“init”前后分别有两个下划线！！！ 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： 1234567891011121314In [14]: class Student(object): ...: ...: def __init__(self, name, score): ...: self.name = name ...: self.score = score ...:In [15]: s = Student(&#x27;Bart Simpson&#x27;, 59)In [16]: s.nameOut[16]: &#x27;Bart Simpson&#x27;In [17]: s.scoreOut[17]: 59 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 数据封装面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩： 123456In [19]: def print_score(std): ...: print(&#x27;%s: %s&#x27; % (std.name, std.score)) ...:In [20]: print_score(s)Bart Simpson: 59 但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法： 123456789In [23]: class Student(object): ...: ...: def __init__(self, name, score): ...: self.name = name ...: self.score = score ...: ...: def print_score(self): ...: print(&#x27;%s: %s&#x27; % (self.name, self.score)) ...: 要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入： 1234In [24]: s = Student(&#x27;Bart Simpson&#x27;, 59)In [25]: s.print_score()Bart Simpson: 59 这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。 封装的另一个好处是可以给Student类增加新的方法，比如get_grade： 12345678910111213class Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt;= 90: return &#x27;A&#x27; elif self.score &gt;= 60: return &#x27;B&#x27; else: return &#x27;C&#x27; 同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节 1234lisa = Student(&#x27;Lisa&#x27;, 99)bart = Student(&#x27;Bart&#x27;, 59)print(lisa.name, lisa.get_grade())print(bart.name, bart.get_grade()) 继承 在程序中，继承描述的是多个类之间的所属关系。 如果一个类A里面的属性和方法可以复用，则可以通过继承的方式，传递到类B里。那么类A就是基类，也叫做父类；类B就是派生类，也叫做子类。 1. 单继承 子类A只继承了一个父类B, 那么此时两者之间的关系就是单继承 单继承，子类直接继承父类的__init__方法 12345678910class User(object): # 创建用户类 def __init__(self, name): # 给用户添加属性：name self.name = nameclass VipUser(User): # 子类继承父类的__init__方法，添加name属性 passvip = VipUser(&quot;xw&quot;) # vip初始化时，自己本身没有实现__init__方法,而是直接调用继承自User的__init__方法，vip有name属性print(vip.name) 单继承，子类自己实现__init__方法 1234567891011class User(): # 创建用户类 def __init__(self, name): # 给用户添加属性：name self.name = nameclass VipUser(User): # 子类自己实现__init__方法，并没有直接使用继承父类的__init__方法 def __init__(self, name): # 给vip用户添加属性：name self.name = namevip = VipUser(&quot;xw&quot;) # vip初始化时，自己本身没有实现__init__方法,而是直接调用继承自User的__init__方法，vip有name属性print(vip.name) 单继承，子类在自己实现的__init__方法中，还调用了父类的__init__方法 12345678910111213141516# 对象初始化，__init__方法只会执行一次class User(): # 创建用户类 def __init__(self, name): # 给用户添加属性：name self.name = nameclass VipUser(User): def __init__(self, name, money): # self.name = name # User.__init__(self) # 通过父类名直接调用父类的__init__方法实现name属性的添加 super().__init__(name) # 通过super()调用父类的__init__方法添加name属性 self.money = money # 自己添加money属性vip = VipUser(&quot;xw&quot;, 300) # vip初始化时，__init__方法执行一次print(vip.name, vip.money) 2. 多继承 多继承可以继承多个父类，也继承了所有父类的属性和方法 如果多个父类中有同名的 属性和方法，则默认使用第一个父类的属性和方法（根据类的魔法属性__mro__的顺序来查找） 多个父类中，不重名的属性和方法，不会有任何影响。 1234567891011121314class A(): def __init__(self): self.name = &quot;A&quot;class B(): def __init__(self): self.name = &quot;B&quot;class C(A, B): passc = C()print(C.mro()) # [&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]print(c.name) # A 3. 多层继承 多层继承主要说的是super的搜索顺序,而搜索顺序主要是根据类的魔法属性__mro__的顺序来查找 super()调用方法顺序示例 12345678910111213141516171819202122class A(): def run(self): print(&quot;&gt;&gt;&gt;A&lt;&lt;&lt;&quot;)class B1(A): def run(self): print(&quot;&gt;&gt;&gt;B1&lt;&lt;&lt;&quot;) super().run() class B2(A): def run(self): print(&quot;&gt;&gt;&gt;B2&lt;&lt;&lt;&quot;) super().run() class C(B1, B2): def run(self): print(&quot;&gt;&gt;&gt;C&lt;&lt;&lt;&quot;) super().run() c= C()print(C.mro())c.run() 程序运行结果： 12345[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.B1&#x27;&gt;, &lt;class &#x27;__main__.B2&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]&gt;&gt;&gt;C&lt;&lt;&lt;&gt;&gt;&gt;B1&lt;&lt;&lt;&gt;&gt;&gt;B2&lt;&lt;&lt;&gt;&gt;&gt;A&lt;&lt;&lt; 参数传递示例 1234567891011121314151617181920212223242526272829class Father(object): def __init__(self, name): print(&#x27;father&#x27;) self.name = nameclass Son1(Father): def __init__(self, name, age, *args): print(&#x27;Son1&#x27;) self.age = age super().__init__(name, *args)class Son2(Father): def __init__(self, name, gender): print(&#x27;Son2&#x27;) self.gender = gender super().__init__(name)class Grandson(Son1, Son2): def __init__(self, name, age, gender): print(&quot;Grandson&quot;) super().__init__(name, age, gender)print(Grandson.mro())print(&quot;+&quot; * 30)grand_son = Grandson(&#x27;王明&#x27;, 14, &#x27;男&#x27;)print(&quot;+&quot; * 30)print(grand_son.name, grand_son.age, grand_son.gender) 程序运行结果： 1234567++++++++++++++++++++++++++++++GrandsonSon1Son2father++++++++++++++++++++++++++++++王明 14 男 多态 1. 多态所谓的多态就是同一类事物有不同的形态,(一个抽象类有多个子类，因而多态的概念依赖于继承) 序列类型有多种形态：字符串，列表，元组 动物有多种形态：猫，狗 12345678910111213141516171819202122232425262728293031323334# 多态：同一种事物的多种形态，动物分为猫类，狗类（在定义角度）class Animal(): def __init__(self, name, foods): self.name = name self.foods = foods def eat(self): print(&quot;%s的食物是%s&quot; % (self.name, self.foods)) def run(self): print(&quot;%s跑的很快&quot; % self.name) def call(self): passclass Dog(Animal): def call(self): print(&quot;%s:汪汪大叫&quot; % self.name)class Cat(Animal): def call(self): print(&quot;%s:喵喵大叫&quot; % self.name)dog = Dog(&quot;哈士奇&quot;, &quot;狗粮&quot;)dog.eat()dog.call()cat = Cat(&quot;九命妖猫&quot;, &quot;仙露&quot;)cat.eat()cat.run() 2. 多态性 什么是多态性（注意：多态与多态性是两种概念） 多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。 在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。 也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。 12345678# 多态性依赖于：继承##多态性：定义统一的接口，#多态性：一种调用方式，不同的执行效果（多态性）def func(obj): # obj这个参数没有类型限制，可以传入不同类型的值 obj.eat() #调用的逻辑都一样，执行的结果却不一样func(dog)func(cat) 为什么要用多态性（多态性的好处） 其实大家从上面多态性的例子可以看出，我们并没有增加上面新的知识，也就是说Python本身就是支持多态性的，这么做的好处是什么呢？ 增加了程序的灵活性以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal) 增加了程序额可扩展性通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用 多态：同一种事物的多种形态，动物分为猫类，狗类（在定义角度） 多态性：一种调用方式，不同的执行效果（多态性） 类型判断访问权限实例属性与类属性实例方法、静态方法与类方法1. 方法分类先看语法，python 类语法中有三种方法，实例方法，静态方法，类方法。 python中self，cls的区别: 普通实例方法，第一个参数需要是self，它表示一个具体的实例本身。 如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。 而对于classmethod，它的第一个参数不是self，是cls，它表示这个类本身。 123456789101112131415161718192021222324# coding:utf-8class Foo(object): &quot;&quot;&quot;类三种方法语法形式&quot;&quot;&quot; def instance_method(self): print(&quot;是类&#123;&#125;的实例方法，只能被实例对象调用&quot;.format(Foo)) @staticmethod def static_method(): print(&quot;是静态方法&quot;) @classmethod def class_method(cls): print(&quot;是类方法&quot;)foo = Foo()foo.instance_method()foo.static_method()foo.class_method()print(&#x27;----------------&#x27;)Foo.static_method()Foo.class_method() 运行结果： 123456是类&lt;class &#x27;__main__.Foo&#x27;&gt;的实例方法，只能被实例对象调用是静态方法是类方法----------------是静态方法是类方法 说明 调用 实例方法只能被实例对象调用 静态方法(由@staticmethod装饰的方法)、类方法(由@classmethod装饰的方法)，可以被类或类的实例对象调用。 参数 实例方法，第一个参数必须要默认传实例对象，一般习惯用self。 静态方法，参数没有要求。 类方法，第一个参数必须要默认传类，一般习惯用cls。 2. 方法调用 静态方法调用另一个静态方法，如果改用类方法调用静态方法，可以让cls代替类，让代码看起来精简一些。也防止类名修改了，不用在类定义中修改原来的类名。 12345678910111213141516171819202122# coding:utf-8class Foo(object): X = 1 Y = 2 @staticmethod def averag(*mixes): return sum(mixes) / len(mixes) @staticmethod def static_method(): # 在静态方法中调用静态方法 print(&quot;在静态方法中调用静态方法&quot;) return Foo.averag(Foo.X, Foo.Y) @classmethod def class_method(cls): # 在类方法中使用静态方法 print(&quot;在类方法中使用静态方法&quot;) return cls.averag(cls.X, cls.Y)foo = Foo()print(foo.static_method())print(foo.class_method()) 运行结果： 1234在静态方法中调用静态方法1.5在类方法中使用静态方法1.5 3.继承类中的区别从下面代码可以看出，如果子类继承父类的方法，子类覆盖了父类的静态方法: 子类的实例继承了父类的static_method静态方法，调用该方法，还是调用的父类的方法和类属性。 子类的实例继承了父类的class_method类方法，调用该方法，调用的是子类的方法和子类的类属性。 123456789101112131415161718192021222324252627282930313233343536class Foo(object): X = 1 Y = 14 @staticmethod def averag(*mixes): # &quot;父类中的静态方法&quot; return sum(mixes) / len(mixes) @staticmethod def static_method(): # &quot;父类中的静态方法&quot; print(&quot;父类中的静态方法&quot;) return Foo.averag(Foo.X, Foo.Y) @classmethod def class_method(cls): # 父类中的类方法 print(&quot;父类中的类方法&quot;) return cls.averag(cls.X, cls.Y)class Son(Foo): X = 3 Y = 5 @staticmethod def averag(*mixes): # &quot;子类中重载了父类的静态方法&quot; print(&quot;子类中重载了父类的静态方法&quot;) return sum(mixes) / len(mixes)p = Son()print(&quot;result of p.averag(1,5)&quot;)print(p.averag(1, 5))print(&quot;result of p.static_method()&quot;)print(p.static_method())print(&quot;result of p.class_method()&quot;)print(p.class_method()) 运行结果： 12345678910result of p.averag(1,5)子类中重载了父类的静态方法3.0result of p.static_method()父类中的静态方法7.5result of p.class_method()父类中的类方法子类中重载了父类的静态方法4.0","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://www.bookandmusic.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Mysql中varbinary、binary、char、varchar异同","slug":"数据库-Mysql中varbinary、binary、char、varchar异同","date":"2019-06-01T01:12:16.000Z","updated":"2021-01-23T15:15:10.000Z","comments":true,"path":"2019/06/01/shu-ju-ku-mysql-zhong-varbinary-binary-char-varchar-yi-tong/","link":"","permalink":"https://www.bookandmusic.cn/2019/06/01/shu-ju-ku-mysql-zhong-varbinary-binary-char-varchar-yi-tong/","excerpt":"","text":"binary 与 varbinary 类型和char与varchar类型是相似的，只是他们存储的是二进制数据，也就是说他们是包含字节流而不是字符流，他们有二进制字符的集合和顺序，他们的对比，排序是基于字节的数值进行的 binary与varbinary的最大长度和char与varchar是一样的，只不过他们是定义字节长度，而char和varchar对应的是字符长度。 存储和取出时对尾部空格的处理 char(N)用来存储非二进制字符串，插入时，对于少于N个字符的会自动在尾部加空格，查询时，尾部的空格就会被丢弃掉 vachar(N) 用来存储非二进制字符串，插入时，对于少于N个字符的不填补空格，查询时，尾部的空格不会被丢弃掉 binary(N)存储二进制字符串，插入进，少于N个字节的会自动在尾部加0x00，取出时，所有的字节都保留，返回定义长度的字节长度，在比较的时候，所有的字节都是有效的，并且0x00&lt;space (space对应的是0x20) varbinary在插入不会去填补0x00字节，查询的时候也不会丢弃任何字节，在比较的时候，所有的字节都是有效的，并且0x00&lt;space (space对应的是0x20) 大小比较时char与varchar的字符比较中，是忽略大小写与最后的空格的，如： 12345678mysql&gt; select &#x27;a&#x27;=&#x27;a &#x27; , &#x27;a&#x27;=&#x27;A&#x27; , &#x27;a&#x27;=&#x27;A &#x27;;+----------+---------+----------+| &#x27;a&#x27;=&#x27;a &#x27; | &#x27;a&#x27;=&#x27;A&#x27; | &#x27;a&#x27;=&#x27;A &#x27; |+----------+---------+----------+| 1 | 1 | 1 |+----------+---------+----------+1 row in set (0.00 sec) 而binary及varbinary的字节比较中，所有的信息都不会被忽略，如： 12345678910111213mysql&gt; create table t (c BINARY(3));Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into t set c = &#x27;a&#x27;;Query OK, 1 row affected (0.01 sec)mysql&gt; select hex(c), c = &#x27;a&#x27;, c = &#x27;a\\0\\0&#x27; from t;+--------+---------+-------------+| HEX(c) | c = &#x27;a&#x27; | c = &#x27;a\\0\\0&#x27; |+--------+---------+-------------+| 610000 | 0 | 1 |+--------+---------+-------------+1 row in set (0.08 sec)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"数据库","slug":"技术/数据库","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"技术/数据库/mysql","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[{"name":"varbinary","slug":"varbinary","permalink":"https://www.bookandmusic.cn/tags/varbinary/"},{"name":"binary","slug":"binary","permalink":"https://www.bookandmusic.cn/tags/binary/"},{"name":"char","slug":"char","permalink":"https://www.bookandmusic.cn/tags/char/"},{"name":"varchar","slug":"varchar","permalink":"https://www.bookandmusic.cn/tags/varchar/"}]},{"title":"Mysql中的Decimal类型说明","slug":"数据库-Mysql中的Decimal类型说明","date":"2019-06-01T00:50:26.000Z","updated":"2021-01-23T15:14:51.000Z","comments":true,"path":"2019/06/01/shu-ju-ku-mysql-zhong-de-decimal-lei-xing-shuo-ming/","link":"","permalink":"https://www.bookandmusic.cn/2019/06/01/shu-ju-ku-mysql-zhong-de-decimal-lei-xing-shuo-ming/","excerpt":"","text":"我们在Mysql中存字段的时候，比如，一些与金钱有关的数据。这个时候就会对精确到的要求非常高。那么这个时候，就会发现我们之前所学的八大基本类型不再能够满足需求，无论是整形还是浮点型，有人会说存整形有什么不可，但是你要知道不是每个人的金额都是整数的；这样不行的话，存浮点型的就可以了嘛，对于银行存钱来说，一个小数点的问题都会将一笔钱的金额变得很大或者很小……So，这个时候你可以尝试一下Decimal类型，你会发现能够很好地解决你的问题。 decimal详细介绍：decimal(a,b) 参数说明： a:指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度为38. b:指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从0~a之间的值，默认小数位数是0. 举例说明，11615.23653234568这个数存你说的三个格式 decimal：11615 decimal(3)：999 decdimal(3,2)：9.99 decimal(10,5)11615.23653 超出精度范围的数会被强制进位并只显示数据类型定义的格式 备注： decimal数据类型用于要求非常高的精确计算中，这些类型允许指定数值的精确度和计算方法作为选择参数。精确度在这里指为这个值保存的有效数字的总个数。而计数方法指的是小数点后数字的个数。例如：decimal(5,2)规定了存储的值将不会超过五位数字 ，而且小数点后面有两位数字。 实例1：12345678910111213141516mysql&gt; create table t1(c1 float(10,2), c3decimal(10,2));Query OK, 0 rows affected (0.02 sec)mysql&gt; insert into t1 values(9876543.21, 9876543.12);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+------------+------------+| c1 | c3 |+------------+------------+| 9876543.00 | 9876543.12 |+------------+------------+1 row in set (0.00 sec) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会发现，flocat类型的字段会自动将值四舍五入，而decimal类型的不会，如果用flocat类型的去存与金额有关的数据的时候就会出现问题，而decimal类型的就不会。 实例2：decimal(5,2)1234567891011121314mysql&gt; create table t1(id1 float(5,2) default null,id2 double(5,2) default null,id3 decimal(5,2) default null );Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into t1 values(1.2345,1.2345,1.2345);Query OK, 1 row affected, 1 warning (0.04 sec)mysql&gt; show warnings;+-------+------+------------------------------------------+| Level | Code | Message |+-------+------+------------------------------------------+| Note | 1265 | Data truncated for column &#x27;id3&#x27; at row 1 |+-------+------+------------------------------------------+1 row in set (0.00 sec) 1.2345 — 小数点后最多2位，所以保存可以，自动四舍五入数据截断,但会报waning 12.34 — OK 1234.5 — 因为小数部分未满2位，要补0.所以保存应该1234.50。所以整个位数超出了5，保存报错。 1.2 — 小数未满部分补0。按照1.20保存。 默认状态比较： 浮点数 如果不写精度和标度，会按照实际精度值保存 如果有精度和标度，则会自动将四舍五入后的结果插入，系统不会报错 定点数 如果不写精度和标度，则按照默认值decimal(10,0)来操作 如果数据超过了精度和标度值，系统会报错","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"数据库","slug":"技术/数据库","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"技术/数据库/mysql","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[{"name":"float","slug":"float","permalink":"https://www.bookandmusic.cn/tags/float/"},{"name":"decimal","slug":"decimal","permalink":"https://www.bookandmusic.cn/tags/decimal/"}]},{"title":"数据库笔记","slug":"数据库-MySQL笔记","date":"2019-05-27T13:23:45.000Z","updated":"2021-01-23T15:14:19.000Z","comments":true,"path":"2019/05/27/shu-ju-ku-mysql-bi-ji/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/27/shu-ju-ku-mysql-bi-ji/","excerpt":"","text":"学习数据库安装后，最重要的就是学习SQL语句。 1. 数据语句操作类型SQL是操作数据库的核心， 结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 SQL是最重要的关系数据库操作语言，并且它的影响已经超出数据库领域，得到其他领域的重视和采用，如人工智能领域的数据检索等。 SQL是关系模型的数据库应用语言，由IBM在20世纪70年代为其关系型数据库 System R 所开发。 SQL 是1986年10 月由美国国家标准局（ANSI）通过的数据库语言美国标准，接着，国际标准化组织（ISO）颁布了SQL正式国际标准。1989年4月，ISO提出了具有完整性特征的SQL89标准，1992年11月又公布了SQL92标准。 虽然各个数据库系统略有不同，但是他们基本均遵循SQL 92标准。或者在SQL 92上做了一些简单的扩展和变化。 学好了MySQL 的SQL 语法，其他的SQL语法学习起来均是万变不离其中。 SQL语句按照其功能范围不同可分为3个类别： 数据定义语言(DDL ，Data Defintion Language)语句：数据定义语句，用于定义不同的数据段、数据库、表、列、索引等。常用的语句关键字包括create、drop、alter等。 数据操作语言(DML ， Data Manipulation Language)语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据的完整性。常用的语句关键字主要包括insert、delete、update和select等。 数据控制语言(DCL， Data Control Language)语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括grant、revoke等。 2. 管理数据库命令元数据以下命令语句可以在 MySQL 的命令提示符使用，获取服务器元数据 命令 描述 select version( ) 服务器版本信息 select database( ) 当前数据库名 (或者返回空) select user( ) 当前用户名 show status 服务器状态 show variables 服务器配置变量 创建数据库 create database 数据库名:创建数据库 12mysql&gt; create database data_test;Query OK, 1 row affected (0.01 sec) 删除数据库 drop database 数据库名:删除数据库 12mysql&gt; drop database data_test;Query OK, 0 rows affected (0.01 sec) 展示所有数据库 show databases:列出 MySQL 数据库管理系统的数据库列表。 1234567891011mysql&gt; show databases;+--------------------+| Database |+--------------------+| data_test || information_schema || mysql || performance_schema || sys |+--------------------+5 rows in set (0.01 sec) 改变数据库 use 数据库名 :选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。 12mysql&gt; use data_test;Database changed 展示当前数据库中所有的表 show tables:显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。 123456789101112mysql&gt; show tables;+---------------------+| Tables_in_data_test |+---------------------+| customers || orderitems || orders || productnotes || products || vendors |+---------------------+6 rows in set (0.00 sec) 展示特定表中每列的信息 show columns from 数据表(desc 数据表):显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 123456789101112131415mysql&gt; show columns from customers;+--------------+-----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------------+-----------+------+-----+---------+----------------+| cust_id | int(11) | NO | PRI | NULL | auto_increment || cust_name | char(50) | NO | | NULL | || cust_address | char(50) | YES | | NULL | || cust_city | char(50) | YES | | NULL | || cust_state | char(5) | YES | | NULL | || cust_zip | char(10) | YES | | NULL | || cust_country | char(50) | YES | | NULL | || cust_contact | char(50) | YES | | NULL | || cust_email | char(255) | YES | | NULL | |+--------------+-----------+------+-----+---------+----------------+9 rows in set (0.00 sec) 展示数据表的详细索引信息 show index from 数据表:显示数据表的详细索引信息，包括PRIMARY KEY（主键）。 12345678mysql&gt; show index from customers;+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| customers | 0 | PRIMARY | 1 | cust_id | A | 5 | NULL | NULL | | BTREE | | | YES | NULL |+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+1 row in set (0.01 sec) 展示数据库的性能及统计信息 show table status [from db_name] [like ‘pattern’] \\G:该命令将输出Mysql数据库管理系统的性能及统计信息。 显示数据库 data_test 中所有表的信息 123456789101112mysql&gt; show table status from data_test;+--------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options | Comment |+--------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| customers | InnoDB | 10 | Dynamic | 5 | 3276 | 16384 | 0 | 0 | 0 | 10006 | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL | utf8_general_ci | NULL | | || orderitems | InnoDB | 10 | Dynamic | 11 | 1489 | 16384 | 0 | 16384 | 0 | NULL | 2019-05-26 10:15:02 | 2019-05-26 10:15:26 | NULL | utf8_general_ci | NULL | | || orders | InnoDB | 10 | Dynamic | 5 | 3276 | 16384 | 0 | 16384 | 0 | 20010 | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL | utf8_general_ci | NULL | | || productnotes | MyISAM | 10 | Dynamic | 14 | 135 | 1892 | 281474976710655 | 6144 | 0 | 115 | 2019-05-26 10:15:02 | 2019-05-26 10:15:26 | NULL | utf8_general_ci | NULL | | || products | InnoDB | 10 | Dynamic | 14 | 1170 | 16384 | 0 | 16384 | 0 | NULL | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL | utf8_general_ci | NULL | | || vendors | InnoDB | 10 | Dynamic | 6 | 2730 | 16384 | 0 | 0 | 0 | 1007 | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL | utf8_general_ci | NULL | | |+--------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+6 rows in set (0.02 sec) 表名以cus开头的表的信息 1234567mysql&gt; show table status from data_test like &quot;cus%&quot;;+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options | Comment |+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| customers | InnoDB | 10 | Dynamic | 5 | 3276 | 16384 | 0 | 0 | 0 | 10006 | 2019-05-26 10:15:02 | 2019-05-26 10:15:25 | NULL | utf8_general_ci | NULL | | |+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+1 row in set (0.00 sec) 表名以cus开头的表的信息;加上 \\G，查询结果按列打印;\\G后面不能再加分号;因为\\G在功能上等同于;如果加了分号，那么就是;;(2个分号)，SQL语法错误ERROR:No query specified 123456789101112131415161718192021mysql&gt; show table status from data_test like &quot;cus%&quot;\\G*************************** 1. row *************************** Name: customers Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 5 Avg_row_length: 3276 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: 10006 Create_time: 2019-05-26 10:15:02 Update_time: 2019-05-26 10:15:25 Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment:1 row in set (0.00 sec) 3. 数据类型数值类型mysql支持所有标准sql数值数据类型。 这些类型包括严格数值数据类型（integer、smallint、decimal和numeric），以及近似数值数据类型（float、real和double precisi键字int是integer的同义词，关键字dec是decimal的同义词。 bit数据类型保存位字段值，并且支持myisam、memory、innodb和bdb表。 作为sql标准的扩展，mysql也支持整数类型tinyint、mediumint和bigint。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 tinyint 1 字节 (-128，127) (0，255) 小整数值 smallint 2 字节 (-32 768，32 767) (0，65 535) 大整数值 mediumint 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 int 或 integer 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 bigint 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 float 4 字节 (-3.402 823 466 e+38，-1.175 494 351 e-38)，0，(1.175 494 351 e-38，3.402 823 466 351 e+38) 0，(1.175 494 351 e-38，3.402 823 466 e+38) 单精度浮点数值 double 8 字节 (-1.797 693 134 862 315 7 e+308，-2.225 073 858 507 201 4 e-308)，0，(2.225 073 858 507 201 4 e-308，1.797 693 134 862 315 7 e+308) 0，(2.225 073 858 507 201 4 e-308，1.797 693 134 862 315 7 e+308) 双精度 浮点数值 decimal decimal(m,d) 依赖于 m 和 d 的值 依赖于 m 和 d 的值 小数值 日期和时间类型表示时间值的日期和时间类型为 datetime、date、timestamp、time 和 year。 每个时间类型有一个有效值范围和一个 “零” 值，当指定不合法的 mysql 不能表示的值时使用 “零” 值。 timestamp 类型有专有的自动更新特性，将在后面描述。 类型 大小(字节) 范围 格式 用途 date 3 1000-01-01/9999-12-31 yyyy-mm-dd 日期值 time 3 ‘-838:59:59’/‘838:59:59’ hh:mm:ss 时间值或持续时间 year 1 1901/2155 yyyy 年份值 datetime 8 1000-01-01 00:00:00/9999-12-31 23:59:59 yyyy-mm-dd hh:mm:ss 混合日期和时间值 timestamp 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒北京时间 2038-1-19 11:14:07格林尼治时间2038-1-19 03:14:07 yyyymmdd hhmmss 混合日期和时间值，时间戳 字符串类型字符串类型指 char、varchar、binary、varbinary、blob、text、enum 和 set。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 char 0-255 字节 定长字符串 varchar 0-65535 字节 变长字符串 tinyblob 0-255 字节 不超过 255 个字符的二进制字符串 tinytext 0-255 字节 短文本字符串 blob 0-65 535 字节 二进制形式的长文本数据 text 0-65 535 字节 长文本数据 mediumblob 0-16 777 215 字节 二进制形式的中等长度文本数据 mediumtext 0-16 777 215 字节 中等长度文本数据 longblob 0-4 294 967 295 字节 二进制形式的极大文本数据 longtext 0-4 294 967 295 字节 极大文本数据 char 和 varchar 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 binary 和 varbinary 类似于 char 和 varchar，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 blob 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 blob 类型：tinyblob、blob、mediumblob 和 longblob。它们区别在于可容纳存储范围不同。 有 4 种 text 类型：tinytext、text、mediumtext 和 longtext。对应的这 4 种 blob 类型，可存储的最大长度不同，可根据实际情况选择。 注意： 1、一个汉字占多少长度与编码有关： UTF－8：一个汉字＝3个字节 GBK：一个汉字＝2个字节 2、varchar(n) 表示 n 个字符，无论汉字和英文，Mysql 都能存入 n 个字符，仅是实际字节长度有所区别 3、MySQL 检查长度，可用 SQL 语言来查看： 1select length(fieldname) from table_name 4. 创建数据表创建MySQL数据表需要以下信息： 表名 表字段名 定义每个表字段 语法以下为创建MySQL数据表的SQL通用语法： 1create table table_name (column_name column_type); 实例以下例子中我们将在 my_data 数据库中创建数据表students： 12345678910111213mysql&gt; create table if not exists students(id int unsigned auto_increment, name varchar(40) not null, adress varchar(100) , birthday date not null, primary key(id)) engine=innodb default charset=utf8mb4;Query OK, 0 rows affected (0.03 sec)mysql&gt; show columns from students;+----------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(40) | NO | | NULL | || adress | varchar(100) | YES | | NULL | || birthday | date | NO | | NULL | |+----------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 实例解析： 如果你不想字段为 null 可以设置字段的属性为 not null， 在操作数据库时如果输入该字段的数据为null ，就会报错。 auto_increment定义列为自增的属性，一般用于主键，数值会自动加1。 primary key关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 engine 设置存储引擎，charset 设置编码。 5. 删除数据表MySQL中删除数据表是非常容易操作的， 但是你再进行删除表操作时要非常小心，因为执行删除命令后所有数据都会消失。 语法以下为删除MySQL数据表的通用语法： 1drop table table_name; 实例以下实例中我们将删除 students 表: 12345mysql&gt; drop table students;Query OK, 0 rows affected (0.01 sec)mysql&gt; show tables;Empty set (0.00 sec) 6. 插入数据MySQL 表中使用 insert into SQL语句来插入数据。 语法以下为向MySQL数据表插入数据通用的 INSERT INTO SQL语法： 1insert into table_name ( field1, field2,...fieldN ) values ( value1, value2,...valueN ); insert 插入多条数据 1insert into table_name (field1, field2,...fieldn) values (valuea1,valuea2,...valuean),(valueb1,valueb2,...valuebn),(valuec1,valuec2,...valuecn)......; 如果数据是字符型，必须使用单引号或者双引号，如：”value”。 实例以下实例中我们将向 students 表插入数据: 123456789101112131415# 主键默认从1开始mysql&gt; insert into students (name,birthday) values(&quot;丽丽&quot;,&quot;1996-05-06&quot;);Query OK, 1 row affected (0.00 sec)# 主键设为0，即从最后一个id值自动增长mysql&gt; insert into students values(0,&quot;李明&quot;,null,&quot;1993-12-16&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into students values(10,&quot;张磊&quot;,&#x27;北京市海淀区&#x27;,&quot;1995-04-12&quot;);Query OK, 1 row affected (0.00 sec)# 主键不设置，从最后一个id值自动增长mysql&gt; insert into students set name=&quot;孙雨&quot;,adress=&#x27;河北省石家庄市&#x27;,birthday=&quot;1989-07-18&quot;;Query OK, 1 row affected (0.01 sec) 如果添加过主键自增（PRINARY KEY AUTO_INCREMENT）第一列在增加数据的时候，可以写为0或者null，这样添加数据可以自增 7. 条件语句 查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用where语句来设定查询条件。 where 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 以下为操作符列表，可用于 where 子句中。 你可以在 WHERE 子句中指定任何条件。 你可以使用 and 或者 or 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 delete 或者 update 命令。 下表中实例假定 A 为 10, B 为 20 操作符 描述 实例 = 等号，检测两个值是否相等，如果相等返回true (A = B) 返回false。 != 不等于，检测两个值是否相等，如果不相等返回true (A != B) 返回 true。 &gt; 大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true (A &gt; B) 返回false。 &lt; 小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true (A &lt; B) 返回 true。 &gt;= 大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true (A &gt;= B) 返回false。 &lt;= 小于等于号，检测左边的值是否小于于或等于右边的值, 如果左边的值小于或等于右边的值返回true (A &lt;= B) 返回 true。 如果我们想在 MySQL 数据表中读取指定的数据，where 子句是非常有用的。 使用主键来作为 where 子句的条件查询是非常快速的。 如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。 8. 查询数据MySQL 数据库使用SQL select语句来查询数据。 语法以下为在MySQL数据库中查询数据通用的 select 语法 1234select column_name,column_namefrom table_name[where Clause][limit N][ offset M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用where语句来设定查询条件。 select 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，select语句会返回表的所有字段数据 你可以使用 limit 属性来设定返回的记录数。 你可以通过offset指定select语句开始查询的数据偏移量。默认情况下偏移量为0。 实例以下实例我们将通过 SQL select 命令来获取 MySQL 数据表 students 的数据： 1234567891011121314151617181920212223242526272829303132333435363738394041424344mysql&gt; select * from students;+----+------+----------------+------------+| id | name | adress | birthday |+----+------+----------------+------------+| 1 | 丽丽 | NULL | 1996-05-06 || 2 | 李明 | NULL | 1993-12-16 || 10 | 张磊 | 北京市海淀区 | 1995-04-12 || 11 | 孙雨 | 河北省石家庄市 | 1989-07-18 |+----+------+----------------+------------+4 rows in set (0.00 sec)mysql&gt; select id,name from students limit 2 offset 1;+----+------+| id | name |+----+------+| 2 | 李明 || 10 | 张磊 |+----+------+2 rows in set (0.00 sec)mysql&gt; select * from students where id&gt;=10;+----+------+----------------+------------+| id | name | adress | birthday |+----+------+----------------+------------+| 10 | 张磊 | 北京市海淀区 | 1995-04-12 || 11 | 孙雨 | 河北省石家庄市 | 1989-07-18 |+----+------+----------------+------------+2 rows in set (0.00 sec)mysql&gt; select * from students where id&gt;=10 limit 1 offset 1;+----+------+----------------+------------+| id | name | adress | birthday |+----+------+----------------+------------+| 11 | 孙雨 | 河北省石家庄市 | 1989-07-18 |+----+------+----------------+------------+1 row in set (0.00 sec)mysql&gt; select * from students where name=&quot;李明&quot;;+----+------+--------+------------+| id | name | adress | birthday |+----+------+--------+------------+| 2 | 李明 | NULL | 1993-12-16 |+----+------+--------+------------+1 row in set (0.00 sec) 9. 修改数据如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL update 命令来操作。 语法以下是 update 命令修改 MySQL 数据表数据的通用 SQL 语法： 1update table_name set field1=new-value1, field2=new-value2 [where clause] 当我们需要将字段中的特定字符串批量修改为其他字符串时，可已使用以下操作： 1update table_name set field=replace(field, &#x27;old-string&#x27;, &#x27;new-string&#x27;) [where clause] 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。当你需要更新数据表中指定行的数据时 where 子句是非常有用的。 实例以下我们将在 SQL update 命令使用 where 子句来更新 students 表中指定的数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445mysql&gt; update students set adress=&quot;北京市昌平区&quot; where adress is null;Query OK, 2 rows affected (0.01 sec)Rows matched: 2 Changed: 2 Warnings: 0mysql&gt; select * from students;+----+------+----------------+------------+| id | name | adress | birthday |+----+------+----------------+------------+| 1 | 丽丽 | 北京市昌平区 | 1996-05-06 || 2 | 李明 | 北京市昌平区 | 1993-12-16 || 10 | 张磊 | 北京市海淀区 | 1995-04-12 || 11 | 孙雨 | 河北省石家庄市 | 1989-07-18 |+----+------+----------------+------------+4 rows in set (0.00 sec)mysql&gt; update students set adress=replace(adress, &quot;河北省石家庄&quot;,&quot;湖北省武汉&quot;) where id=11;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from students;+----+------+--------------+------------+| id | name | adress | birthday |+----+------+--------------+------------+| 1 | 丽丽 | 北京市昌平区 | 1996-05-06 || 2 | 李明 | 北京市昌平区 | 1993-12-16 || 10 | 张磊 | 北京市海淀区 | 1995-04-12 || 11 | 孙雨 | 湖北省武汉市 | 1989-07-18 |+----+------+--------------+------------+4 rows in set (0.00 sec)mysql&gt; update students set id=id-7 where id=10;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from students;+----+------+--------------+------------+| id | name | adress | birthday |+----+------+--------------+------------+| 1 | 丽丽 | 北京市昌平区 | 1996-05-06 || 2 | 李明 | 北京市昌平区 | 1993-12-16 || 3 | 张磊 | 北京市海淀区 | 1995-04-12 || 11 | 孙雨 | 湖北省武汉市 | 1989-07-18 |+----+------+--------------+------------+4 rows in set (0.00 sec) 10. 删除数据你可以使用 sql 的 delete from 命令来删除 mysql 数据表中的记录。 语法以下是 sql delete 语句从 mysql 数据表中删除数据的通用语法： 1delete from table_name [where clause] 如果没有指定 where 子句，mysql 表中的所有记录将被删除。 你可以在 where 子句中指定任何条件 您可以在单个表中一次性删除记录。当你想删除数据表中指定的记录时 where 子句是非常有用的。 实例这里我们将在 sql delete 命令中使用 where 子句来删除 mysql 数据表 students 所选的数据: 123456789101112mysql&gt; delete from students where id=11;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from students;+----+------+--------------+------------+| id | name | adress | birthday |+----+------+--------------+------------+| 1 | 丽丽 | 北京市昌平区 | 1996-05-06 || 2 | 李明 | 北京市昌平区 | 1993-12-16 || 3 | 张磊 | 北京市海淀区 | 1995-04-12 |+----+------+--------------+------------+3 rows in set (0.00 sec) delete，drop，truncate 都有删除表的作用，区别在于： 1、drop table table_name : 删除表全部数据和表结构，立刻释放磁盘空间，不管是 Innodb 和 MyISAM; 实例，删除学生表： 1drop table students; 2、truncate table table_name : 删除表全部数据，保留表结构，立刻释放磁盘空间 ，不管是 Innodb 和 MyISAM; 实例，删除学生表： 1truncate table students; 3、delete from table_name : 删除表全部数据，表结构不变，对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间; 实例，删除学生表： 1delete from students; 4、delete from table_name where xxx : 带条件的删除，表结构不变，不管是 innodb 还是 MyISAM 都不会释放磁盘空间; 实例，删除学生表中姓名为 “张三” 的数据： 1delete from student where name = &quot;张三&quot;; 5、delete 操作以后，使用 optimize table table_name 会立刻释放磁盘空间，不管是 innodb 还是 myisam; 实例，删除学生表中姓名为 “张三” 的数据： 1delete from student where name = &quot;张三&quot;; 实例，释放学生表的表空间： 1optimize table students; 6、delete from 表以后虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以使用这部分空间。 11. 包含条件我们知道在 mysql 中使用 sql select 命令来读取数据， 同时我们可以在 select 语句中使用 where 子句来获取指定的记录。 where 子句中可以使用等号 = 来设定获取数据的条件，如 “adress = ‘北京市昌平区’”。 但是有时候我们需要获取 adress 字段含有 “北京市” 字符的所有记录，这时我们就需要在 where 子句中使用 sql like 子句。 语法以下是 sql select 语句使用 like 子句从数据表中读取数据的通用语法： 1select field1, field2,...fieldn from table_name where field1 like condition1 [and [or]] filed2 = &#x27;somevalue&#x27; sql like 子句中使用百分号 %字符来表示任意字符，类似于unix或正则表达式中的星号 *。 如果没有使用百分号 %, like 子句与等号 = 的效果是一样的。 like 通常与 % 一同使用，类似于一个元字符的搜索。 可以使用 and 或者 or 指定一个或多个条件。 可以在 delete、select或 update 命令中使用 where…like 子句来指定条件。 实例以下我们将在 sql select 命令中使用 where…like 子句来从mysql数据表 students 中读取数据。 123456789mysql&gt; select * from students where adress like &quot;北京市%&quot;;+----+------+--------------+------------+| id | name | adress | birthday |+----+------+--------------+------------+| 1 | 丽丽 | 北京市昌平区 | 1996-05-06 || 2 | 李明 | 北京市昌平区 | 1993-12-16 || 3 | 张磊 | 北京市海淀区 | 1995-04-12 |+----+------+--------------+------------+3 rows in set (0.00 sec) 在 where like 的条件查询中，SQL 提供了四种匹配方式。 %：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。 _：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。 []：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。 [^]：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。 查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。 like 匹配/模糊匹配，会与 % 和 _ 结合使用。 123456&#x27;%a&#x27; //以a结尾的数据&#x27;a%&#x27; //以a开头的数据&#x27;%a%&#x27; //含有a的数据&#x27;_a_&#x27; //三位且中间字母是a的&#x27;_a&#x27; //两位且结尾字母是a的&#x27;a_&#x27; //两位且开头字母是a的 12. 关联查询MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 语法mysql union 操作符语法格式： 1234567select expression1, expression2, ... expression_nfrom tables[where conditions]union [all | distinct]select expression1, expression2, ... expression_nfrom tables[where conditions]; 参数 expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 where conditions: 可选， 检索条件。 distinct: 可选，删除结果集中重复的数据。默认情况下 union 操作符已经删除了重复数据，所以 distinct 修饰符对结果没啥影响。 all: 可选，返回所有结果集，包含重复数据。 实例下面的 SQL 语句从 “students” 和 “teachers” 表中选取所有不同的adress（只有不同的值）： 123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; select * from students;+----+------+--------------+------------+| id | name | adress | birthday |+----+------+--------------+------------+| 1 | 丽丽 | 北京市昌平区 | 1996-05-06 || 2 | 李明 | 北京市昌平区 | 1993-12-16 || 3 | 张磊 | 北京市海淀区 | 1995-04-12 |+----+------+--------------+------------+3 rows in set (0.00 sec)mysql&gt; select * from teachers;+----+--------+--------------+----------+| id | name | adress | birthday |+----+--------+--------------+----------+| 1 | 刘老师 | 北京市海淀区 | NULL || 2 | 孙老师 | 北京市朝阳区 | NULL || 3 | 常老师 | 北京市昌平区 | NULL |+----+--------+--------------+----------+3 rows in set (0.00 sec)mysql&gt; select adress from students union select adress from teachers ;+--------------+| adress |+--------------+| 北京市昌平区 || 北京市海淀区 || 北京市朝阳区 |+--------------+3 rows in set (0.00 sec)mysql&gt; select name from students where adress like &quot;%昌平区&quot; union select name from teachers where adress like &quot;%昌平区&quot; ;+--------+| name |+--------+| 丽丽 || 李明 || 常老师 |+--------+3 rows in set (0.00 sec) UNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据） 13. 排序我们知道从 mysql 表中使用 sql select 语句来读取数据。 如果我们需要对读取的数据进行排序，我们就可以使用 mysql 的 order by 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。 语法以下是 sql select 语句使用 order by 子句将查询数据排序后再返回数据： 1select field1, field2,...fieldn table_name1, table_name2... order by field1 [asc [desc][默认 asc]], [field2...] [asc [desc][默认 asc]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 asc 或 desc 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 where…like 子句来设置条件。 实例尝试以下实例，结果将按升序及降序排列。 1234567891011121314151617181920212223242526272829mysql&gt; select * from students where adress like &quot;北京市%&quot; order by birthday;+----+------+--------------+------------+| id | name | adress | birthday |+----+------+--------------+------------+| 2 | 李明 | 北京市昌平区 | 1993-12-16 || 3 | 张磊 | 北京市海淀区 | 1995-04-12 || 1 | 丽丽 | 北京市昌平区 | 1996-05-06 |+----+------+--------------+------------+3 rows in set (0.00 sec)mysql&gt; select * from students where adress like &quot;北京市%&quot; order by birthday desc;+----+------+--------------+------------+| id | name | adress | birthday |+----+------+--------------+------------+| 1 | 丽丽 | 北京市昌平区 | 1996-05-06 || 3 | 张磊 | 北京市海淀区 | 1995-04-12 || 2 | 李明 | 北京市昌平区 | 1993-12-16 |+----+------+--------------+------------+3 rows in set (0.00 sec)mysql&gt; select * from students where adress like &quot;北京市%&quot; order by birthday asc;+----+------+--------------+------------+| id | name | adress | birthday |+----+------+--------------+------------+| 2 | 李明 | 北京市昌平区 | 1993-12-16 || 3 | 张磊 | 北京市海淀区 | 1995-04-12 || 1 | 丽丽 | 北京市昌平区 | 1996-05-06 |+----+------+--------------+------------+3 rows in set (0.00 sec) 14. 分组group by 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 count, sum, avg等函数。 语法以下是gruop by语句的语法示例： 1select column_name, function(column_name) from table_name where column_name operator value group by column_name; 实例接下来我们使用 group by 语句 将数据表按名字进行分组，并统计每个商品有多少条记录： 1234567891011121314151617181920212223mysql&gt; select * from goods;+----+--------+------+| id | name | nums |+----+--------+------+| 1 | 西瓜 | 50 || 2 | 甜瓜 | 15 || 3 | 甜瓜 | 15 || 4 | 苹果 | 25 || 5 | 西瓜 | 25 || 6 | 西瓜 | 63 |+----+--------+------+6 rows in set (0.00 sec)mysql&gt; select name, count(name) from goods group by name;+--------+-------------+| name | count(name) |+--------+-------------+| 甜瓜 | 2 || 苹果 | 1 || 西瓜 | 3 |+--------+-------------+3 rows in set (0.00 sec) with rollup 可以实现在分组统计数据基础上再进行相同的统计（sum,avg,count…）。 例如我们将以上的数据表按商品名称进行分组，再统计每类商品的总数量，或者求其均值： 123456789101112131415161718192021mysql&gt; select name, sum(nums) as count_num from goods group by name;+--------+-----------+| name | count_num |+--------+-----------+| 甜瓜 | 30 || 苹果 | 25 || 西瓜 | 138 |+--------+-----------+3 rows in set (0.00 sec)mysql&gt; select name, avg(nums) as avg_num from goods group by name with rollup;+--------+---------+| name | avg_num |+--------+---------+| 甜瓜 | 15.0000 || 苹果 | 25.0000 || 西瓜 | 46.0000 || NULL | 32.1667 |+--------+---------+4 rows in set (0.00 sec) 我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法： 1select coalesce(a,b,c); 参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。 以下实例中如果名字为空我们使用总数代替： 1234567891011mysql&gt; select coalesce(name, &#x27;总计&#x27;) as 名称, sum(nums) as 数量 from goods group by name with rollup;+--------+--------+| 名称 | 数量 |+--------+--------+| 甜瓜 | 30 || 苹果 | 25 || 西瓜 | 138 || 总计 | 193 |+--------+--------+4 rows in set (0.00 sec) 15. 连接在前面的章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。 本章节我们将向大家介绍如何使用 mysql 的 join 在两个或多个表中查询数据。 你可以在 select, update 和 delete 语句中使用 mysql 的 join 来联合多表查询。 join 按照功能大致分为如下三类： inner join（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 left join（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 right join（右连接）： 与 left join 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 实例首先创建表，并添加测试数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273mysql&gt; create table web_counts(id int unsigned auto_increment primary key, web_name varchar(20) not null, nums int unsigned default 0) default charset=utf8;Query OK, 0 rows affected (0.10 sec)mysql&gt; create table web_info(id int unsigned auto_increment primary key, web_name varchar(20) not null, web_info varchar(50), create_time date not null) default charset=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; desc web_info;+-------------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || web_name | varchar(20) | NO | | NULL | || web_info | varchar(50) | YES | | NULL | || create_time | date | NO | | NULL | |+-------------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)mysql&gt; desc web_counts;+----------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || web_name | varchar(20) | NO | | NULL | || nums | int(10) unsigned | YES | | 0 | |+----------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql&gt; insert into web_counts values(0, &quot; 淘宝&quot;,1000);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into web_counts values(0, &quot;百度&quot;, 3000);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into web_counts values(0, &quot;腾讯&quot;, 2000);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into web_counts values(0, &quot;网易&quot;, 900);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from web_counts;+----+----------+------+| id | web_name | nums |+----+----------+------+| 1 | 淘宝 | 1000 || 2 | 百度 | 3000 || 3 | 腾讯 | 2000 || 4 | 网易 | 900 |+----+----------+------+4 rows in set (0.00 sec)mysql&gt; insert into web_info values(0, &quot;百度&quot;, &quot;搜索网站&quot;,&quot;1989-9-01&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into web_info values(0, &quot;腾讯&quot;, &quot;社交网站&quot;,&quot;1991-02-05&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into web_info values(0, &quot;网易&quot;, &quot;门户网站&quot;,&quot;1990-08-09&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into web_info values(0, &quot;新浪&quot;, &quot;社交网站&quot;,&quot;1993-05-12&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from web_info;+----+----------+--------------+-------------+| id | web_name | web_info | create_time |+----+----------+--------------+-------------+| 1 | 百度 | 搜索网站 | 1989-09-01 || 2 | 腾讯 | 社交网站 | 1991-02-05 || 3 | 网易 | 门户网站 | 1990-08-09 || 4 | 新浪 | 社交网站 | 1993-05-12 |+----+----------+--------------+-------------+4 rows in set (0.01 sec) 接下来我们就使用mysql的inner join(也可以省略 inner 使用 join，效果一样)来连接以上两张表来读取web_counts表中所有web_name字段在web_info表对应的字段值： 12345678910mysql&gt; select b.id, a.web_name, a.nums,b.web_info, b.create_time from web_counts a inner join web_info b on a.web_name=b.web_name;+----+----------+------+--------------+-------------+| id | web_name | nums | web_info | create_time |+----+----------+------+--------------+-------------+| 1 | 百度 | 3000 | 搜索网站 | 1989-09-01 || 2 | 腾讯 | 2000 | 社交网站 | 1991-02-05 || 3 | 网易 | 900 | 门户网站 | 1990-08-09 |+----+----------+------+--------------+-------------+3 rows in set (0.00 sec) 以上 SQL 语句等价于： 12345678910mysql&gt; select b.id, a.web_name, a.nums,b.web_info, b.create_time from web_counts a, web_info b where a.web_name=b.web_name;+----+----------+------+--------------+-------------+| id | web_name | nums | web_info | create_time |+----+----------+------+--------------+-------------+| 1 | 百度 | 3000 | 搜索网站 | 1989-09-01 || 2 | 腾讯 | 2000 | 社交网站 | 1991-02-05 || 3 | 网易 | 900 | 门户网站 | 1990-08-09 |+----+----------+------+--------------+-------------+3 rows in set (0.00 sec) mysql left join 与 join 有所不同。 mysql left join 会读取左边数据表的全部数据，即便右边表无对应数据。 1234567891011mysql&gt; select a.id, a.web_name, a.nums,b.web_info, b.create_time from web_counts a left join web_info b on a.web_name=b.web_name order by a.id;+----+----------+------+--------------+-------------+| id | web_name | nums | web_info | create_time |+----+----------+------+--------------+-------------+| 1 | 淘宝 | 1000 | NULL | NULL || 2 | 百度 | 3000 | 搜索网站 | 1989-09-01 || 3 | 腾讯 | 2000 | 社交网站 | 1991-02-05 || 4 | 网易 | 900 | 门户网站 | 1990-08-09 |+----+----------+------+--------------+-------------+4 rows in set (0.00 sec) mysql right join 会读取右边数据表的全部数据，即便左边边表无对应数据。 1234567891011mysql&gt; select b.id, b.web_name, a.nums,b.web_info, b.create_time from web_counts a right join web_info b on a.web_name=b.web_name order by b.id;+----+----------+------+--------------+-------------+| id | web_name | nums | web_info | create_time |+----+----------+------+--------------+-------------+| 1 | 百度 | 3000 | 搜索网站 | 1989-09-01 || 2 | 腾讯 | 2000 | 社交网站 | 1991-02-05 || 3 | 网易 | 900 | 门户网站 | 1990-08-09 || 4 | 新浪 | NULL | 社交网站 | 1993-05-12 |+----+----------+------+--------------+-------------+4 rows in set (0.01 sec) 16. 正则表达式mysql 正则表达式在前面的章节我们已经了解到mysql可以通过 like ...% 来进行模糊匹配。 mysql 同样也支持其他正则表达式的匹配， mysql中使用 regexp 操作符来进行正则表达式匹配。 下表中的正则模式可应用于 regexp 操作符中。 模式 描述 ^ 匹配输入字符串的开始位置。如果设置了 regexp 对象的 multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了regexp 对象的 multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。 [...] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^...] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。 `p1 p2` * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 &#123;n&#125; n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 &#123;n,m&#125; m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 实例了解以上的正则需求后，我们就可以根据自己的需求来编写带有正则表达式的sql语句。以下我们将列出几个小实例(表名：person_tbl )来加深我们的理解： 查找name字段中以’st’为开头的所有数据： 1mysql&gt; select name from person_tbl where name regexp &#x27;^st&#x27;; 查找name字段中以’ok’为结尾的所有数据： 1mysql&gt; select name from person_tbl where name regexp &#x27;ok$&#x27;; 查找name字段中包含’mar’字符串的所有数据： 1mysql&gt; select name from person_tbl where name regexp &#x27;mar&#x27;; 查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据： 1mysql&gt; select name from person_tbl where name regexp &#x27;^[aeiou]|ok$&#x27;; 17. NULL 值处理为了处理这种情况，mysql提供了三大运算符: is null: 当列的值是 null,此运算符返回 true。 is not null: 当列的值不为 null, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 null 时返回 true。 关于 null 的条件比较运算是比较特殊的。你不能使用 = null 或 != null 在列中查找 null 值 。 在 mysql 中，null 值与任何其它值的比较（即使是 null）永远返回 false，即 null = null 返回false 。 mysql 中处理 null 使用 is null 和 is not null 运算符。 实例在数据库my_data中创建student表，并插入相应数据 1234567891011121314151617181920212223242526mysql&gt; create table student(ID int unsigned auto_increment primary key,name varchar(10) not null,age int unsigned) default charset=utf8;Query OK, 0 rows affected (0.25 sec)mysql&gt; insert into student values(0, &quot;李华&quot;,25);Query OK, 1 row affected (0.04 sec)mysql&gt; insert into student values(0, &quot;敏柔&quot;,null);Query OK, 1 row affected (0.04 sec)mysql&gt; insert into student values(0, &quot;赵强&quot;,null);Query OK, 1 row affected (0.04 sec)mysql&gt; insert into student values(0, &quot;罗晴&quot;,23);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | 23 |+----+--------+------+4 rows in set (0.00 sec) 以下实例中你可以看到 = 和 != 运算符是不起作用的： 123456789101112131415161718192021mysql&gt; select id,name,age=null from student;+----+--------+----------+| id | name | age=null |+----+--------+----------+| 1 | 李华 | NULL || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | NULL |+----+--------+----------+4 rows in set (0.00 sec)mysql&gt; select id,name,age!=null from student;+----+--------+-----------+| id | name | age!=null |+----+--------+-----------+| 1 | 李华 | NULL || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | NULL |+----+--------+-----------+4 rows in set (0.00 sec) 查找数据表中 age 列是否为 null，必须使用 &lt;=&gt; 、is null 和 is not null，如下实例： 12345678910111213141516171819202122mysql&gt; select id,name,age is null from student;+----+--------+-------------+| id | name | age is null |+----+--------+-------------+| 1 | 李华 | 0 || 2 | 敏柔 | 1 || 3 | 赵强 | 1 || 4 | 罗晴 | 0 |+----+--------+-------------+4 rows in set (0.00 sec)mysql&gt; select id,name,age&lt;=&gt;null from student;+----+--------+------------+| id | name | age&lt;=&gt;null |+----+--------+------------+| 1 | 李华 | 0 || 2 | 敏柔 | 1 || 3 | 赵强 | 1 || 4 | 罗晴 | 0 |+----+--------+------------+4 rows in set (0.00 sec) 18.事务mysql 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 在 mysql 中只有使用了 innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 sql 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 一般来说，事务是必须满足4个条件（acid）：：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 mysql 命令行的默认设置下，事务都是自动提交的，即执行 sql 语句后就会马上执行 commit 操作。因此要显式地开启一个事务务须使用命令 begin 或 start transaction，或者执行命令 set autocommit=0，用来禁止使用当前会话的自动提交。 事务控制语句： begin 或 start transaction 显式地开启一个事务； commit 也可以使用 commit work，不过二者是等价的。commit 会提交事务，并使已对数据库进行的所有修改成为永久性的； rollback 也可以使用 rollback work，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； savepoint identifier，savepoint 允许在事务中创建一个保存点，一个事务中可以有多个 savepoint； release savepoint identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； rollback to identifier 把事务回滚到标记点； set transaction 用来设置事务的隔离级别。innodb 存储引擎提供事务的隔离级别有read uncommitted、read committed、repeatable read 和 serializable。 mysql 事务处理主要有两种方法：1、用 begin, rollback, commit来实现 begin 开始一个事务 rollback 事务回滚 commit 事务确认 2、直接用 set 来改变 mysql 的自动提交模式: set autocommit=0 禁止自动提交 set autocommit=1 开启自动提交 实例下面具体演示MySQL事务的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | 23 |+----+--------+------+4 rows in set (0.00 sec)mysql&gt; begin; # 开启事务Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into student values(0,&quot;寒梅&quot;,28); # 插入数据Query OK, 1 row affected (0.00 sec)mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | 23 || 5 | 寒梅 | 28 |+----+--------+------+5 rows in set (0.00 sec)mysql&gt; rollback; # 回滚Query OK, 0 rows affected (0.04 sec)mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | 23 |+----+--------+------+4 rows in set (0.00 sec)mysql&gt; insert into student values(0,&quot;寒梅&quot;,28); # 插入数据Query OK, 1 row affected (0.15 sec)mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | 23 || 6 | 寒梅 | 28 |+----+--------+------+5 rows in set (0.00 sec)mysql&gt; insert into student values(5,&quot;李磊&quot;,26);Query OK, 1 row affected (0.04 sec)mysql&gt; insert into student values(0,&quot;张雷&quot;,20);Query OK, 1 row affected (0.04 sec)mysql&gt; set autocommit=0; # 禁止自动提交Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into student values(0,&quot;韩美美&quot;,20);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from student;+----+-----------+------+| ID | name | age |+----+-----------+------+| 1 | 李华 | 25 || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | 23 || 5 | 李磊 | 26 || 6 | 寒梅 | 28 || 7 | 张雷 | 20 || 8 | 莉莉 | 20 || 9 | 韩美美 | 20 |+----+-----------+------+9 rows in set (0.00 sec)mysql&gt; rollback; # 回滚Query OK, 0 rows affected (0.16 sec)mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | NULL || 3 | 赵强 | NULL || 4 | 罗晴 | 23 || 5 | 李磊 | 26 || 6 | 寒梅 | 28 || 7 | 张雷 | 20 || 8 | 莉莉 | 20 |+----+--------+------+8 rows in set (0.00 sec)mysql&gt; update student set age=23 where name=&quot;敏柔&quot;; # 修改数据Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | 23 || 3 | 赵强 | NULL || 4 | 罗晴 | 23 || 5 | 李磊 | 26 || 6 | 寒梅 | 28 || 7 | 张雷 | 20 || 8 | 莉莉 | 20 |+----+--------+------+8 rows in set (0.00 sec)mysql&gt; savepoint point1; # 创建保存点Query OK, 0 rows affected (0.00 sec)mysql&gt; update student set age=22 where name=&quot;赵强&quot;;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | 23 || 3 | 赵强 | 22 || 4 | 罗晴 | 23 || 5 | 李磊 | 26 || 6 | 寒梅 | 28 || 7 | 张雷 | 20 || 8 | 莉莉 | 20 |+----+--------+------+8 rows in set (0.00 sec)mysql&gt; rollback to point1; # 回滚到保存点Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from student;+----+--------+------+| ID | name | age |+----+--------+------+| 1 | 李华 | 25 || 2 | 敏柔 | 23 || 3 | 赵强 | NULL || 4 | 罗晴 | 23 || 5 | 李磊 | 26 || 6 | 寒梅 | 28 || 7 | 张雷 | 20 || 8 | 莉莉 | 20 |+----+--------+------+8 rows in set (0.00 sec)mysql&gt; commit; # 事务提交Query OK, 0 rows affected (0.04 sec) 19. ALTER命令当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL alter命令。 删除表字段如下命令使用了 alter 命令及 drop 子句来删除以上创建表的 age 字段： 1234567891011121314151617181920212223mysql&gt; desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+----------------+| ID | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | YES | | NULL | |+-------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql&gt; alter table table_name drop field_name;Query OK, 0 rows affected (0.92 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+----------------+| ID | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.00 sec) 如果数据表中只剩余一个字段则无法使用drop来删除字段。 增加表字段mysql 中使用 add 子句来向数据表中添加列，如下实例在表 student 中添加 age 字段，并定义数据类型: 1234567891011121314mysql&gt; alter table student add age int unsigned not null;Query OK, 0 rows affected (0.53 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+----------------+| ID | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+-------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec) 执行以上命令后，field_name 字段会自动添加到数据表字段的末尾。 如果你需要指定新增字段的位置，可以使用mysql提供的关键字 first (设定位第一列)， after 字段名（设定位于某个字段之后）。 尝试以下 alter table 语句, 在执行成功后，使用 show columns 查看表结构的变化： 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; desc student;+-------+------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+-------+------------------+------+-----+---------+-------+2 rows in set (0.00 sec)mysql&gt; alter table student add id int unsigned auto_increment primary key first;Query OK, 0 rows affected (0.56 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+-------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql&gt; alter table student add class int unsigned after id;Query OK, 0 rows affected (0.54 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || class | int(10) unsigned | YES | | NULL | || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+-------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec) first 和 after 关键字可用于 add 与 modify 子句，所以如果你想重置数据表字段的位置就需要先使用 drop 删除字段然后使用 add 来添加字段并设置位置。 修改表字段如果需要修改字段类型及名称, 你可以在alter命令中使用 modify 或 change 子句 。 例如，把字段 class 的类型从 int unsigned 改为 varchar(10)，可以执行以下命令: 1234567891011121314151617181920212223242526mysql&gt; desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || class | int(10) unsigned | YES | | NULL | || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+-------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec)mysql&gt; alter table student modify class varchar(10);Query OK, 8 rows affected (0.69 sec)Records: 8 Duplicates: 0 Warnings: 0mysql&gt; desc student;+-------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || class | varchar(10) | YES | | NULL | || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+-------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 使用 change 子句, 语法有很大的不同。 在 change 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。 当你修改字段时，你可以指定是否包含值或者是否设置默认值。 如果你不设置默认值，mysql会自动设置该字段默认为 null。 123456789101112131415mysql&gt; alter table student change class class_room varchar(20) default &quot;203&quot;;Query OK, 0 rows affected (0.10 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc student;+------------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || class_room | varchar(20) | YES | | 203 | || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+------------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 你可以使用 alter 来修改字段的默认值，尝试以下实例： 123456789101112131415mysql&gt; alter table student alter class_room set default &quot;205&quot;;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc student;+------------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || class_room | varchar(20) | YES | | 205 | || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+------------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 你也可以使用 alter 命令及 drop子句来删除字段的默认值，如下实例： 1234567891011121314mysql&gt; alter table student alter class_room drop default;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc student;+------------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || class_room | varchar(20) | YES | | NULL | || name | varchar(10) | NO | | NULL | || age | int(10) unsigned | NO | | NULL | |+------------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 修改数据表修改数据表类型，可以使用 alter table 命令来完成。 尝试以下实例，我们将表 student 的类型修改为 MyISAM ，然后再修改为 InnoDB： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152mysql&gt; alter table student engine=myisam;Query OK, 8 rows affected (0.28 sec)Records: 8 Duplicates: 0 Warnings: 0mysql&gt; show table status like &quot;student&quot;\\G*************************** 1. row *************************** Name: student Engine: MyISAM Version: 10 Row_format: Dynamic Rows: 8 Avg_row_length: 20 Data_length: 160Max_data_length: 281474976710655 Index_length: 2048 Data_free: 0 Auto_increment: 9 Create_time: 2019-06-09 17:47:23 Update_time: 2019-06-09 17:47:23 Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment:1 row in set (0.00 sec)mysql&gt; alter table students engine=innodb;Query OK, 8 rows affected (0.76 sec)Records: 8 Duplicates: 0 Warnings: 0mysql&gt; show table status where name=&quot;students&quot;\\G*************************** 1. row *************************** Name: students Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 8 Avg_row_length: 2048 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: 9 Create_time: 2019-06-09 17:54:53 Update_time: 2019-06-09 17:54:53 Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment:1 row in set (0.00 sec) 如果需要修改数据表的名称，可以在 alter table 语句中使用 rename 子句来实现。 尝试以下实例将数据表 student 重命名为 students： 1234567891011mysql&gt; alter table student rename to students;Query OK, 0 rows affected (0.00 sec)mysql&gt; show tables;+-------------------+| Tables_in_my_data |+-------------------+| students |+-------------------+1 row in set (0.00 sec) 20. 临时表MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。 如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。 创建临时表使用temporary关键字创建临时表 12345678910111213141516171819202122232425262728293031mysql&gt; create temporary table class_room(room_id int unsigned primary key, class varchar(20) ) default charset=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into class_room values(205,&quot;九年级一班&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from class_room;+---------+-----------------+| room_id | class |+---------+-----------------+| 205 | 九年级一班 |+---------+-----------------+1 row in set (0.00 sec)mysql&gt; desc class_room;+---------+------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+------------------+------+-----+---------+-------+| room_id | int(10) unsigned | NO | PRI | NULL | || class | varchar(20) | YES | | NULL | |+---------+------------------+------+-----+---------+-------+2 rows in set (0.00 sec)mysql&gt; show tables;+-------------------+| Tables_in_my_data |+-------------------+| students |+-------------------+1 row in set (0.00 sec) 当你使用 show tables命令显示数据表列表时，你将无法看到 class_room表。 如果你退出当前mysql会话，再使用 select命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。 删除临时表默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 DROP TABLE 命令来手动删除临时表。 以下是手动删除临时表的实例： 123456mysql&gt; drop table class_room;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from class_room;ERROR 1146 (42S02): Table &#x27;my_data.class_room&#x27; doesn&#x27;t exist 21. 复制表如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用create table … select 命令，是无法实现的。 实例尝试以下实例来复制表 runoob_tbl 。 步骤一： 获取数据表的完整结构。 1234567891011121314mysql&gt; show create table students\\G;*************************** 1. row *************************** Table: studentsCreate Table: CREATE TABLE `students` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(10) NOT NULL, `class_room` varchar(20) DEFAULT &#x27;205&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf81 row in set (0.00 sec)ERROR:No query specified 步骤二： 修改SQL语句的数据表名，并执行SQL语句。 123mysql&gt; create table `student` (`id` int(10) unsigned not null auto_increment,`name` varchar(10) not null,`class_room` varchar(20) default &#x27;205&#x27;, primary key (`id`)) engine=innodb auto_increment=9 default charset=utf8;Query OK, 0 rows affected (0.59 sec) 步骤三： 执行完第二步骤后，你将在数据库中创建新的克隆表 student。 如果你想拷贝数据表的数据你可以使用 insert into… select 语句来实现。 12345678910111213141516171819mysql&gt; insert into student(id,name,class_room) select * from students;Query OK, 8 rows affected (0.00 sec)Records: 8 Duplicates: 0 Warnings: 0mysql&gt; select * from student;+----+--------+------------+| id | name | class_room |+----+--------+------------+| 1 | 李华 | 205 || 2 | 敏柔 | 205 || 3 | 赵强 | 205 || 4 | 罗晴 | 205 || 5 | 李磊 | 205 || 6 | 寒梅 | 205 || 7 | 张雷 | 205 || 8 | 莉莉 | 205 |+----+--------+------------+8 rows in set (0.00 sec) 22. 处理重复数据有些 MySQL 数据表中可能存在重复的记录，有些情况我们允许重复数据的存在，但有时候我们也需要删除这些重复的数据。 防止表中出现重复数据你可以在 MySQL 数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。 如果你想设置表中字段 id，name 数据不能重复，你可以设置双主键模式来设置数据的唯一性， 如果你设置了双主键，那么那个键的默认值不能为 NULL，可设置为 NOT NULL。如下所示： 12345678910111213mysql&gt; create table teachers(id int unsigned auto_increment, name varchar(10), gender varchar(5), primary key(id,name));Query OK, 0 rows affected (0.26 sec)mysql&gt; desc teachers;+--------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | PRI | NULL | || gender | varchar(5) | YES | | NULL | |+--------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec) 如果我们设置了唯一索引，那么在插入重复数据时，SQL 语句将无法执行成功,并抛出错。 insert ignore into 与 insert into 的区别就是 insert ignore 会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。 123456789mysql&gt; insert into teachers values(1, &quot;李磊&quot;, &quot;男&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into teachers values(1, &quot;李磊&quot;, &quot;男&quot;);ERROR 1062 (23000): Duplicate entry &#x27;1-李磊&#x27; for key &#x27;PRIMARY&#x27;mysql&gt; insert ignore into teachers values(1, &quot;李磊&quot;, &quot;男&quot;);Query OK, 0 rows affected, 1 warning (0.00 sec) INSERT IGNORE INTO 当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而 REPLACE INTO 如果存在 primary 或 unique 相同的记录，则先删除掉。再插入新记录。 1234567891011mysql&gt; replace into teachers values(1, &quot;李磊&quot;, &quot;女&quot;);Query OK, 2 rows affected (0.00 sec)mysql&gt; select * from teachers;+----+--------+--------+| id | name | gender |+----+--------+--------+| 1 | 李磊 | 女 |+----+--------+--------+1 row in set (0.00 sec) 另一种设置数据的唯一性方法是添加一个 UNIQUE 索引，如下所示： 123456789101112131415161718192021mysql&gt; create table person(first_name char(20) not null, last_name char(20) not null, gender char(10),unique (last_name, first_name)) charset=utf8;Query OK, 0 rows affected (0.25 sec)mysql&gt; insert ignore into person values(&quot;李&quot;, &quot;雷&quot;, &quot;男&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert ignore into person values(&quot;李&quot;, &quot;雷&quot;, &quot;男&quot;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; insert ignore into person values(&quot;李&quot;, &quot;丽&quot;, &quot;女&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from person;+------------+-----------+--------+| first_name | last_name | gender |+------------+-----------+--------+| 李 | 丽 | 女 || 李 | 雷 | 男 |+------------+-----------+--------+2 rows in set (0.00 sec) 统计重复数据以下我们将统计表中 first_name 和 last_name的重复记录数： 创建person_info表，并插入3条重复数据 123456789101112131415161718192021mysql&gt; create table person_info(id int unsigned primary key auto_increment,first_name char(20) not null, last_name char(20) not null, gender char(10)) charset=utf8;Query OK, 0 rows affected (0.29 sec)mysql&gt; insert ignore into person_info values(0,&quot;李&quot;, &quot;丽&quot;, &quot;女&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert ignore into person_info values(0,&quot;李&quot;, &quot;丽&quot;, &quot;女&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert ignore into person_info values(0,&quot;李&quot;, &quot;丽&quot;, &quot;女&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from person_info;+----+------------+-----------+--------+| id | first_name | last_name | gender |+----+------------+-----------+--------+| 1 | 李 | 丽 | 女 || 2 | 李 | 丽 | 女 || 3 | 李 | 丽 | 女 |+----+------------+-----------+--------+3 rows in set (0.00 sec) 查询重复数据 12345678mysql&gt; select count(*) as repetitions,last_name,first_name from person_info group by last_name, first_name having repetitions &gt; 1;+-------------+-----------+------------+| repetitions | last_name | first_name |+-------------+-----------+------------+| 3 | 丽 | 李 |+-------------+-----------+------------+1 row in set (0.00 sec) 以上查询将返回 person_info 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作： 确定哪一列包含的值可能会重复。 在列选择列表使用count(*)列出的那些列。 在group by子句中列出的列。 having子句设置重复数大于1。 过滤重复数据如果你需要读取不重复的数据可以在 select 语句中使用 distinct 关键字来过滤重复数据。 12345678mysql&gt; select distinct first_name,last_name from person_info;+------------+-----------+| first_name | last_name |+------------+-----------+| 李 | 丽 |+------------+-----------+1 row in set (0.00 sec) 你也可以使用 group by 来读取数据表中不重复的数据： 12345678mysql&gt; select first_name, last_name from person_info group by last_name, first_name;+------------+-----------+| first_name | last_name |+------------+-----------+| 李 | 丽 |+------------+-----------+1 row in set (0.01 sec) 删除重复数据如果你想删除数据表中的重复数据，你可以使用以下的SQL语句： 方法一先创建临时表tab,新表tab中的数据时从person_info表中分组查询出来的 123mysql&gt; create table tmp select last_name, first_name, gender from person_info group by last_name, first_name, gender;Query OK, 1 row affected (0.01 sec)Records: 1 Duplicates: 0 Warnings: 0 在表的第一位添加主键 1alter table tmp add column `id` bigint(20) primary key not null auto_increment comment &#x27;id&#x27; first; 删除原表 12mysql&gt; drop table person_info;Query OK, 0 rows affected (0.01 sec) 重命名为person_info 12mysql&gt; alter table tmp rename to person_info;Query OK, 0 rows affected (0.01 sec)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"数据库","slug":"技术/数据库","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"技术/数据库/mysql","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[{"name":"SQL语句","slug":"SQL语句","permalink":"https://www.bookandmusic.cn/tags/SQL%E8%AF%AD%E5%8F%A5/"}]},{"title":"Django基础(四)-路由","slug":"Django-4-路由","date":"2019-05-25T14:45:46.000Z","updated":"2021-06-12T06:31:17.640Z","comments":true,"path":"2019/05/25/django-4-lu-you/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/25/django-4-lu-you/","excerpt":"","text":"Django2.0 新增了在 urls.py 中 app_name 来指定 namespace。我们之前通过 reverse 函数来反向获取 url reverse 语法1reverse(&quot;&lt;namespace&gt;:&lt;url-name&gt;&quot;, kwargs=&#123;&quot;&lt;kwarg&gt;&quot;: &quot;&lt;val&gt;&quot;&#125;) 流程路由定义在项目的总路由中，可以通过指定namespace来确定应用 123urlpatterns = [ path(r&#x27;users/&#x27;, include((&#x27;users.urls&#x27;, &#x27;userss&#x27;)))] 更进一步,把 namespace 定义到被 include 的 子路由users/urls.py 中去使用 app_name 定义名称空间 123456789from django.urls import re_path, pathfrom users.views import RegisterView, LoginView, DetailView, IndexViewapp_name = &#x27;users&#x27;urlpatterns = [ path(&#x27;detail/&lt;int:uid&gt;/&#x27;, DetailView.as_view(), name=&quot;detail&quot;), path(&quot;&quot;, IndexView, name=&quot;index&quot;)] 反向解析现在我们仍然可以用 reverse 函数和模板中的 url 获取 URL 1234reverse(&quot;users:index&quot;)reverse(&quot;users:detail&quot;, kwargs=&#123;&quot;uid&quot;: 2020&#125;)&#123;% url &quot;users:index&quot; %&#125;&#123;% url &quot;users:detail&quot; uid=2020 %&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"django基础","slug":"django基础","permalink":"https://www.bookandmusic.cn/tags/django%E5%9F%BA%E7%A1%80/"},{"name":"namespace","slug":"namespace","permalink":"https://www.bookandmusic.cn/tags/namespace/"},{"name":"app_name","slug":"app-name","permalink":"https://www.bookandmusic.cn/tags/app-name/"},{"name":"reverse","slug":"reverse","permalink":"https://www.bookandmusic.cn/tags/reverse/"}]},{"title":"常见函数的时间复杂度","slug":"算法-时间复杂度-02_常见函数的时间复杂度","date":"2019-05-25T11:54:09.000Z","updated":"2021-01-25T02:59:08.000Z","comments":true,"path":"2019/05/25/suan-fa-shi-jian-fu-za-du-02-chang-jian-han-shu-de-shi-jian-fu-za-du/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/25/suan-fa-shi-jian-fu-za-du-02-chang-jian-han-shu-de-shi-jian-fu-za-du/","excerpt":"","text":"很多函数都有自己的很多方法，其中有些方法的功能类似，但是其复杂度有时却大不相同 本节我们将引入一个新模块 timeit ，其功能是来测试一小段 Python 代码的执行速度。 1、timeit1class timeit.Timer(stmt=&#x27;pass&#x27;, setup=&#x27;pass&#x27;,timer=&lt;timer function&gt;) Timer 是测量小段代码执行速度的类 stmt 是要测试的代码语句 (statment), 字符串类型, setup 是运行代码时需要的设置 , 字符串类型, 就是从 __main__ 引入需要的是的方法名 timer 参数是一个定时器函数, 与平台有关, 不用去管 timeit.Timer.timeit(numer=1000000)，numer-&gt; 测算次数, 返回平均耗时, 一个 float 类型的秒数 部分测试示例 测试结果 2、list 的内置函数时间复杂度 方法 复杂度 简介 index[x] O(1) 索引 index assignment O(1) 索引赋值 append O(1) 尾部追加 pop() O(1) 尾部弹出 pop(i) O(n) 指定位置弹出 n 列表长度, 最坏时间复杂度 insert(i, item) O(n) 指定位置添加 del operator O(n) 删除, 代表一个一个元素去清空 iteration O(n) 迭代 contains(in) O(n) 看谁是否在列表中, 需要遍历 get slice[x:y] O(k) 取切片, 从 x 取到 y, 一次定位到 x, 然后取到 y ,x 和 y 之间有多少就是 k del slice O(n) 删除切片 删除位置之后, 后面的元素都需要往前移动 set slice O(k) 设置切片, li[0:3] = [1, 2, 3, 4]k 是补充的东西数量 reverse O(n) 置返 concatenate O(k) 代表使用的 +, 把两个列表加到一起, k 是第二个列表中的元素 sort O(nlogn) 排序 multiply O(nk) 相乘 li=[1, 2] -&gt; n li * 10 -&gt; k 3、dict 的内置函数时间复杂度 方法 复杂度 简介 copy O(n) 复制 get item O(1) 取 set item O(1) 设置 delete item O(1) 删除键 contains(in) O(1) 包含 iteration O(n) 迭代","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"算法","slug":"技术/算法","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"},{"name":"时间复杂度","slug":"技术/算法/时间复杂度","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"}],"tags":[{"name":"时间复杂度","slug":"时间复杂度","permalink":"https://www.bookandmusic.cn/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"}]},{"title":"O标记法与常见时间复杂度","slug":"算法-时间复杂度-01_O 标记法与常见时间复杂度","date":"2019-05-25T11:54:09.000Z","updated":"2021-01-25T02:59:03.000Z","comments":true,"path":"2019/05/25/suan-fa-shi-jian-fu-za-du-01-o-biao-ji-fa-yu-chang-jian-shi-jian-fu-za-du/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/25/suan-fa-shi-jian-fu-za-du-01-o-biao-ji-fa-yu-chang-jian-shi-jian-fu-za-du/","excerpt":"","text":"算法 : 内功心法, 是解决问题的一种思想 1、时间复杂度 $T(n)$由于每台机器的性能有所差别，所有其执行相同代码的时间也长短不一，故而推出一种计量方式，统计代码执行基本运算（函数调用需要看其源码的基本运算）的数量（n) 来确定一个算法的优劣，其中基本运算的循环按乘法计算，顺序结构按加法计算，分支结构取最大值。 12345for a in range(0, 1000): for b in range(0, 1000): for c in range(0, 1000): if a+b+c == 1000 and a**2 + b**2 + c**2: print(&#x27;a,b,c,: &#123;&#125;, &#123;&#125;, &#123;&#125;&#x27;.format(a,b,c)) 上述代码的时间复杂度为$T = 1000 * 1000 * 1000 * 2$那么如果将上述代码中的 1000 改为 2000， 则$T = 2000 * 2000 * 2000 * 2$由于上述同样的代码由于不同的参数的 T 都不同，我们便将其统一成 N，这样上述代码的时间复杂度可以表示成：$T = N * N * N * 2$同样的我们抓住其主要 “矛盾” ，观其大，再将其简化成$T= N^3$这样同一段代码的时间复杂度便不会根据其参数而发生改变了。 2、大 $O$ 标记法 $O()$其实和求极限的原理相似，抓住问题的主要矛盾，忽略那些细枝末节，也就像前面的 $T$的最后的样子。 3、时间复杂度的几条基本规则 基本步骤: 即只有常数项, 算作 $O(1)$ 基本结构顺序, 条件, 循环 顺序结构: 按加法运算 循环结构: 乘法 分支结构: 取最大值 判断一个算法效率, 往往只需要关注操作数量的最高次项, 其他次要的忽略 没特殊说明, 分析的时间复杂度都是最坏时间复杂度 4、常见的时间复杂度 $T$ $O$ 名称 $12$ $O(1)$ 常数阶 $2n+3$ $O(n)$ 线性阶 $3n^2+2n+1$ $O(n^2)$ 平方阶 $5log2n+20$ $O(log(n))$ 对数阶 $2n+3nlog2n+19$ $O(nlog(n))$ $nlog(n)$ 阶 $6n^3+2n^2+3n+4$ $O(n^3)$ 立方阶 $2^n$ $O(2^n)$ 指数阶 $$O(1) &lt; O(log(n)) &lt; O(n) &lt; O(nlog(n)) &lt; O(n^2)&lt; O(n ^ 2log(n)) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$$","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"算法","slug":"技术/算法","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"},{"name":"时间复杂度","slug":"技术/算法/时间复杂度","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"}],"tags":[{"name":"时间复杂度","slug":"时间复杂度","permalink":"https://www.bookandmusic.cn/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"}]},{"title":"win10设置开机自启","slug":"系统-win10设置开机自启","date":"2019-05-25T02:45:27.000Z","updated":"2021-01-21T07:06:56.000Z","comments":true,"path":"2019/05/25/xi-tong-win10-she-zhi-kai-ji-zi-qi/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/25/xi-tong-win10-she-zhi-kai-ji-zi-qi/","excerpt":"","text":"刚开始接触 win10 的朋友肯定不知道在哪里把自己常用的软件设置成开机启动，因为你根本找不到前面的 xp、win7、win8，等里面的启动文件夹。 工具 / 原料 win10 系统电脑一台 方法 / 步骤 如果想要实现应用程序在所有的用户登录系统后都能自动启动，就把该应用程序的快捷方式放到 “系统启动文件夹” 里； 上面的方法有的朋友可能找不到路径，没有关系，你可以把上面的路径直接复制到地址栏里面打开即可。如下图 同样也可以用系统命令来打开 “启动文件夹”。在运行里面输入：shell:startup 或者输入：%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 上面那种命令都可以打开系统启动文件夹的；同样，打开之后把要启动的软件放进去即可。","categories":[{"name":"系统","slug":"系统","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"系统/Windows","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/Windows/"}],"tags":[{"name":"开机自启","slug":"开机自启","permalink":"https://www.bookandmusic.cn/tags/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/"}]},{"title":"win10 python2和python3共存问题","slug":"工具-win10 pyhton2和3共存","date":"2019-05-25T02:45:27.000Z","updated":"2021-01-23T15:13:23.000Z","comments":true,"path":"2019/05/25/gong-ju-win10-pyhton2-he-3-gong-cun/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/25/gong-ju-win10-pyhton2-he-3-gong-cun/","excerpt":"","text":"特别说明，本文是在 Windows64 位系统下进行的，32 位系统请下载相应版本的安装包，安装方法类似。 下载python安装包进入 python 官网，链接 https://www.python.org/ 选择 Downloads—&gt;Windows，点击进入就可以看到寻找想要的 python 版本 本文选择的是： Python3.5.2, 点击后面链接可直接下载，https://www.python.org/ftp/python/3.5.2/python-3.5.2rc1-amd64.exe Python2.7.9, 点击后面链接可直接下载，https://www.python.org/ftp/python/2.7.9/python-2.7.9.amd64.msi python3 安装 说明: 本文先安装 python3，然后安装 python2 首先选择安装目录，本文安装路径为 D:\\Python\\python35，然后点击下载好的 python3 软件包进行安装，具体流程如下： 在下图红色标记的地方 Add Python3.5 to PATH 前勾选，可以直接将 python3 添加到系统环境变量，然后在 Customize installation 中自定义安装路径。 直接 next 即可 下图中 Advanced Options 中没有默认勾选的根据自己的需要进行勾选，黄色标记为 VS 2015 及其以后版本需要的，如果你以后打算在 VS 2015 中配置 python 环境请勾选此项，点击 Browse 选择安装目录，然后点击 Install 进行安装。 等待如下安装过程 安装成功 点击关闭，查看 python3 安装情况，按 “Win + R” 快捷键，在打开的 “运行” 对话框中，输入 “cmd” 按回车，进入如下界面，输入 python 查看 python3 安装情况，显示 python 3.5.2 的版本信息，则安装成功，可以输入语句 print(1 + 1)进行测试。 python2 安装 点击 python2 安装包，点击运行，next，选择安装目录，本文安装路径为 D:\\Python\\python27，然后 next 下图黄色圈出的部分，显示不能够添加路径到系统变量，不能够直接使用 python 命令没有关系，先点击 next 进行安装，后面专门解决。 点击 finish 完成安装。至此，python2 和 python3 安装完毕。 特别说明：此时运行 “cmd” 命令进入 DOS 命令提示框，输入 python 仍然显示 python3 版本。 配置环境变量打开，控制面板 \\ 系统和安全 \\ 系统，选择高级系统设置，环境变量，选择 Path，点击编辑，新建，分别添加 D:\\Python\\python27 和 D:\\Python\\python27\\Scripts 到环境变量。 注意： python3 安装时可以选择自动添加到系统环境变量，如未选择，方法和 python2 添加过程相同。 重命名 python.exe 找到 python2 和 python3 的安装目录，修改 python2.7.9 和 python3.5.2 中 python.exe 和 pythonw.exe 的名称为 python2.exe、pythonw2.exe 和 python3.exe、pythonw3.exe。 然后在运行 cmd 命令，输入 python2 即可运行 python2.7.9 版本 输入 python3 即可运行 python3.5.2 版本 至此，python2 和 python3 安装完毕。 pip2 和 pip3 设置 Python 安装包需要用到包管理工具 pip，但是当同时安装 python2 和 python3 的时候，pip 只是其中一个版本，以下将提供一个修改方式，即重新安装两个版本的 pip，使得两个 python 版本的 pip 能够共存。 在 DOS 命令框输入命令，python2-m pip install –upgrade pip –force-reinstall，显示重新安装成功。 现在可以通过 pip2 -V 和 pip3-V 查看两个版本的 pip 信息，以后只需运行 pip2install XXX 和 pip3 install XXX 即可安装各自的 python 包。 至此，pip2 和 pip3 修改成功。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"工具/python","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/python/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.bookandmusic.cn/tags/Windows/"}]},{"title":"python内置函数","slug":"python函数-内置函数","date":"2019-05-25T02:45:27.000Z","updated":"2021-01-23T14:59:42.000Z","comments":true,"path":"2019/05/25/python-han-shu-nei-zhi-han-shu/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/25/python-han-shu-nei-zhi-han-shu/","excerpt":"","text":"python内置函数 Python 内置函数就是 python 标准库里（语言自身携带的）函数（公共函数）。 那么，接下来就来谈一谈 python 里的内置函数 1、abs() 此函数返回数字的绝对值。 1234a = 5b = -10print(abs(a)) #输出3print(abs(b)) #输出5 2、all() 此函数用于判断给定的可迭代参数 iterable 中的所有元素是否都不为 0、都不为 False 或者 iterable 都 为空,如果是返回 True, 否则返回 False。 1234567print(all([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])) # Trueprint(all([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;])) # Falseprint(all([0, 1,2, 3])) # Falseprint(all((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;))) # Falseprint(all((0, 1,2, 3))) # Falseprint(all([])) # Trueprint(all(())) # True 3、any() 函数用于判断给定的可迭代参数 iterable 是否全部为空对象,如果都为空、都为 0、或者都为 false，则返回 False,如果不都为空、不都为 0、不都为 false，则返回 True。 1234567print(any([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])) # Trueprint(any([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;])) # Trueprint(any([0, 1,2, 3])) # Trueprint(any((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;))) # Trueprint(any((0, 1,2, 3))) # Trueprint(any([])) # Falseprint(any(())) # False 4、bin() 返回一个整数 int 或者长整数 long int 的二进制表示。 12print(bin(10)) #0b1010print(bin(20)) #0b10100 5、bool() 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。 传入布尔类型时，按原值返回 参数如果缺省，则返回 False 传入字符串时，空字符串返回 False，否则返回 True 传入数值时，0 值返回 False，否则返回 True 传入元组、列表、字典等对象时，元素个数为空返回 False，否则返回 True. 1234567print(bool()) #Falseprint(bool(True)) #Trueprint(bool(&quot;&quot;)) #Falseprint(bool(&quot;123&quot;)) #Trueprint(bool(0)) #Falseprint(bool(1)) #Trueprint(bool([])) #False 若元祖和字典为空时 也为False ，不为空 则为True 6、chr() 用一个范围在 range(256)内的（就是 0～255）整数作参数，返回一个对应的字符。(只能输入数字) 123print(chr(65)) #Aprint(chr(97)) #aprint(chr(100)) #d 7、cmp(x,y) 函数用于比较 2 个对象，如果x &lt;y返回-1, 如果 x == y 返回 0, 如果 x&gt; y返回 1。（python3 已经删除了） 8、compile() 函数将一个字符串编译为字节代码。语法：compile(source, filename, mode[, flags[, dont_inherit]]) 1234import repattern=re.compile(&#x27;[a-zA-Z]&#x27;)result=pattern.findall(&#x27;as3SiOPdj#@23awe&#x27;)print(result) 9、complex(real,imag) 函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。 123print(complex(1, 2)) #(1 + 2j)print(complex(1)) #(1 + 0j)print(complex(&quot;3&quot;)) #(3+0j) 10、dict(**kwarg) 返回一个字典 123456789&gt;&gt;&gt;dict() # 创建空字典&#123;&#125;&gt;&gt;&gt; dict(a=&#x27;a&#x27;, b=&#x27;b&#x27;, t=&#x27;t&#x27;) # 传入关键字&#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#x27;b&#x27;, &#x27;t&#x27;: &#x27;t&#x27;&#125;&gt;&gt;&gt; dict(zip([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], [1, 2, 3])) # 映射函数方式来构造字典&#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125; &gt;&gt;&gt; dict([(&#x27;one&#x27;, 1), (&#x27;two&#x27;, 2), (&#x27;three&#x27;, 3)]) # 可迭代对象方式来构造字典&#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;&gt;&gt;&gt; 11、dir([object]) 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表； 带参数时，返回参数的属性、方法列表。 如果参数包含方法__dir__()，该方法将被调用。 如果参数不包含__dir__()，该方法将最大限度地收集参数信息。 12345&gt;&gt;&gt;dir() # 获得当前模块的属性列表[&#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;arr&#x27;, &#x27;myslice&#x27;]&gt;&gt;&gt; dir([ ]) # 查看列表的方法[&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__delitem__&#x27;, &#x27;__delslice__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__getslice__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__iadd__&#x27;, &#x27;__imul__&#x27;, &#x27;__init__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__reversed__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;, &#x27;__setitem__&#x27;, &#x27;__setslice__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;append&#x27;, &#x27;count&#x27;, &#x27;extend&#x27;, &#x27;index&#x27;, &#x27;insert&#x27;, &#x27;pop&#x27;, &#x27;remove&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;]&gt;&gt;&gt; 12、divmod(a, b) 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 123456&gt;&gt;&gt;divmod(7, 2)(3, 1)&gt;&gt;&gt; divmod(8, 2)(4, 0)&gt;&gt;&gt; divmod(1+2j,1+0.5j)((1+0j), 1.5j) 13、enumerate(sequence, [start=0]) 函数用于将一个可遍历的数据对象 (如列表、元组或字符串) 组合为一个索引序列，同时列出数据和数据下标，一般用在for 循环当中。 12345&gt;&gt;&gt;seasons = [&#x27;Spring&#x27;, &#x27;Summer&#x27;, &#x27;Fall&#x27;, &#x27;Winter&#x27;]&gt;&gt;&gt; list(enumerate(seasons))[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]&gt;&gt;&gt; list(enumerate(seasons, start=1)) # 下标从 1 开始[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)] 14、eval() 函数用来执行一个字符串表达式，并返回表达式的值。15、execfile() 函数可以用来执行一个文件。16、float() 函数用于将整数和字符串转换成浮点数。17、frozenset() 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。18、getattr() 函数用于返回一个对象属性值。19、hash() 用于获取取一个对象（字符串或者数值等）的哈希值。20、help() 函数用于查看函数或模块用途的详细说明。21、hex() 函数用于将 10 进制整数转换成 16 进制整数。22、id() 函数用于获取对象的内存地址。23、input() 输入函数24、int() 函数用于将一个字符串会数字转换为整型。25、isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。 isinstance() 与 type() 区别： type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。 26、len() 方法返回对象（字符、列表、元组等）长度或项目个数。27、list() 方法用于将元组转换为列表。28、locals() 函数会以字典类型返回当前位置的全部局部变量。29、long() 函数将数字或字符串转换为一个长整型。30、max() 方法返回给定参数的最大值，参数可以为序列。31、memoryview() 函数返回给定参数的内存查看对象 (Momory view)。32、min() 方法返回给定参数的最小值，参数可以为序列。33、oct() 函数将一个整数转换成 8 进制字符串。34、open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。35、ord() 函数与 chr() 函数相反，输入字符返回数字36、pow() 方法返回 xy（x 的 y 次方） 的值。函数是计算 x 的 y 次方，如果 z 在存在，则再对结果进行取模，其结果等效于 pow(x,y) %z37、print() 输出函数38、range() 函数可创建一个整数列表，一般用在 for 循环中。39、reload() 用于重新载入之前载入的模块。40、everse() 函数用于反向列表中元素。41、round() 方法返回浮点数 x 的四舍五入值。42、set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。43、str() 函数将对象转化字符串44、sum() 方法对系列进行求和计算。45、tuple() 元组 tuple() 函数将列表转换为元组。46、type() 返回对象类型。47、unichr() 该函数和 chr() 函数功能基本一样， 只不过是返回 unicode 的字符。48、vars() 函数返回对象 object 的属性和属性值的字典对象。49、xrange() 函数用法与 range 完全相同，所不同的是生成的不是一个数组，而是一个生成器。50、import() 函数用于动态加载类和函数 。如果一个模块经常变化就可以使用 import() 来动态载入。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"内置函数","slug":"内置函数","permalink":"https://www.bookandmusic.cn/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"}]},{"title":"python正则匹配","slug":"python高级-正则匹配","date":"2019-05-23T12:51:32.000Z","updated":"2021-01-23T14:58:20.000Z","comments":true,"path":"2019/05/23/python-gao-ji-zheng-ze-pi-pei/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/23/python-gao-ji-zheng-ze-pi-pei/","excerpt":"","text":"正则匹配 题目描述： 现公司要开发一个业务管理系统，要求注册环节的密码需要提示用户其安全等级，密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分；此外，密码的组成可以由字母，数字，以及符号构成。 以下为密码分数判断选项，每项判断只能拿一个分项： 密码长度: 5 分: 小于等于4个字符 10 分: 5到7字符 25 分: 大于等于8个字符 字母: 0 分: 没有字母 10 分: 全都是小（大）写字母 20 分: 大小写混合字母 数字: 0 分: 没有数字 10 分: 1个数字 20 分: 大于1个数字 符号: 0 分: 没有符号 10 分: 1个符号 25 分: 大于1个符号 奖励: 2 分: 字母和数字 3 分: 字母、数字和符号 5 分: 大小写字母、数字和符号 最后的评分标准: 大于等于90: 非常安全 大于等于80: 安全 大于等于70: 非常强 大于等于 60: 强 大于等于 50: 一般 大于等于 25: 弱 大于等于0: 非常弱 当用户输入一个密码字符串后，判断密码等级，并输出 输入描述： 1b12A3%$123 输出： 1非常安全 代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import redef s1(password): if re.match(r&quot;.&#123;,4&#125;$&quot;, password): return 5 if re.match(r&quot;.&#123;5,7&#125;$&quot;, password): return 10 if re.match(r&quot;.&#123;8,&#125;$&quot;, password): return 25def s2(password): if re.match(r&quot;[^a-zA-Z]*$&quot;, password): return 0 if re.match(r&quot;([a-z]*$)|([A-Z]*$)&quot;, password): return 10 if re.match(r&quot;.*(?=.*[a-z])(?=.*[A-Z]).*$&quot;, password): return 20def s3(password): if re.match(r&quot;[^\\d]*$&quot;, password): return 0 if re.match(r&quot;[^\\d]*[\\d][^\\d]*$&quot;, password): return 10 if re.match(r&quot;.*[\\d]+.*[\\d]+.*$&quot;, password): return 20def s4(password): if re.match(r&quot;[^!@#$%^&amp;*?]*$&quot;, password): return 0 if re.match(r&quot;[^!@#$%^&amp;*?]*[!@#$%^&amp;*?][^!@#$%^&amp;*?]*$&quot;, password): return 10 if re.match(r&quot;.*[!@#$%^&amp;*?]+.*[!@#$%^&amp;*?]+.*$&quot;, password): return 20def s5(password): if re.match(r&quot;.*(?=.*\\d.*$)(?=.*[!@#$%^&amp;*?].*$)(?=.*[a-z].*$)(?=.*[A-Z].*$).*$&quot;, password): return 5 if re.match(r&quot;(?=.*\\d.*$)(?=.*[!@#$%^&amp;*?].*$)(?=.*[a-zA-Z].*$).*$&quot;, password): return 3 if re.match(r&quot;.*(?=.*[\\d].*$)(?=.*[a-zA-Z].*$).*$&quot;, password): return 2password = input(&quot;请输入密码：&quot;)ret = sum((s1(password), s2(password), s3(password), s4(password), s5(password)))if ret &gt;= 90: print(&quot;非常安全&quot;)elif ret &gt;= 80: print(&quot;安全&quot;)elif ret &gt;= 70: print(&quot;非常强&quot;)elif ret &gt;= 60: print(&quot;强&quot;)elif ret &gt;= 50: print(&quot;一般&quot;)elif ret &gt;= 25: print(&quot;弱&quot;)else: print(&quot;非常弱&quot;)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.bookandmusic.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"python多任务机制","slug":"python高级-进程、线程、协程","date":"2019-05-17T12:53:32.000Z","updated":"2021-01-23T14:53:36.000Z","comments":true,"path":"2019/05/17/python-gao-ji-jin-cheng-xian-cheng-xie-cheng/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/17/python-gao-ji-jin-cheng-xian-cheng-xie-cheng/","excerpt":"","text":"python 线程与进程简介1. 进程与线程的历史我们都知道计算机是由硬件和软件组成的。 硬件中的 CPU 是计算机的核心，它承担计算机的所有任务。 操作系统是运行在硬件之上的软件，是计算机的管理者，它负责资源的管理和分配、任务的调度。 程序是运行在系统上的具有某种功能的软件，比如说浏览器，音乐播放器等。 每次执行程序的时候，都会完成一定的功能，比如说浏览器帮我们打开网页，为了保证其独立性，就需要一个专门的管理和控制执行程序的数据结构——进程控制块。 进程就是一个程序在一个数据集上的一次动态执行过程。 进程一般由程序、数据集、进程控制块三部分组成。 我们编写的程序用来描述进程要完成哪些功能以及如何完成； 数据集则是程序在执行过程中所需要使用的资源； 进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 在早期的操作系统里，计算机只有一个核心，进程是执行程序的最小单位，任务调度采用时间片轮转的抢占式方式进行进程调度。 每个进程都有各自的一块独立的内存，保证进程彼此间的内存地址空间的隔离。 随着计算机技术的发展，进程出现了很多弊端： 一是进程的创建、撤销和切换的开销比较大 二是由于对称多处理机（对称多处理机（SymmetricalMulti-Processing）又叫 SMP，是指在一个计算机上汇集了一组处理器 (多 CPU)，各 CPU 之间共享内存子系统以及总线结构）的出现，可以满足多个运行单位，而多进程并行开销过大。 这个时候就引入了线程的概念。 线程也叫轻量级进程，它是一个基本的 CPU 执行单元，也是程序执行过程中的最小单元，由线程 ID、程序计数器、寄存器集合 和堆栈共同组成。 线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。 线程没有自己的系统资源，只拥有在运行时必不可少的资源。 但线程可以与同属与同一进程的其他线程共享进程所拥有的其他资源。 2. 进程与线程之间的关系 线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。 线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息 (如程序计数器、一组寄存器和栈)。 3. 守护线程与守护进程的区别 强调：运行完毕，并非是终止 线程与进程运行完毕的区别： 主进程运行完毕指的是主进程代码运行完毕 主线程运行完毕指的是所在的进程内的所有非守护线程运行完毕后，主线程才算运行完毕 守护进程：主进程代码运行完毕，守护进程也就结束 (守护的是主进程) 主进程要等非守护进程都运行完毕后再回收子进程的资源（否则会产生僵尸进程）才结束 主进程等子进程是因为主进程要给子进程收尸（代用wait方法向操作系统发起回收资源信号（pid号，状态信息）） 守护线程：非守护线程代码运行完毕，守护线程也就结束 (守护的是非守护线程) 主线程在其他非守护线程运行完毕后才算结束（守护线程在此时就会被回收） 强调：主线程也是非守护线程（进程包含了线程） 总结:主线程的结束意味着进程结束，进程整体的资源都会被回收，而进程必须保证非守护线程都运行完毕后才能结束 守护进程：主进程代码运行完毕，守护进程也就结束 守护线程：非守护线程运行完毕，守护线程结束 python 线程Threading 用于提供线程相关的操作，线程是应用程序中工作的最小单元。 1、threading 模块threading 模块建立在 _thread 模块之上。thread 模块以低级、原始的方式来处理和控制线程，而 threading 模块通过对 thread 进行二次封装，提供了更方便的 api 来处理线程。 12345678910111213141516171819import threadingimport timedef worker(num): &quot;&quot;&quot; thread worker function :return: &quot;&quot;&quot; time.sleep(3) print(&quot;The num is %d&quot; % num) returnif __name__ == &#x27;__main__&#x27;: for i in range(5): t = threading.Thread(target=worker, args=(i,), name=&quot;t.%d&quot; % i) t.start() 上述代码创建了5个”前台”线程，然后控制器就交给了CPU，CPU根据指定算法进行调度，分片执行指令。 Thread参数介绍： group：参数未使用，默认值为None。 target：表示调用对象，即子线程要执行的任务。 args：表示调用的位置参数元组。 kwargs：表示调用对象的字典。如kwargs = {‘name’:Jack, ‘age’:18}。 name：子进程名称。 daemon：设置为守护线程(True)或非守护线程(默认：False) Thread属性方法说明 方法/属性 说明 start() 激活线程。使用该方法启动一个子线程，线程名就是我们定义的name，想启动多线程，就必须使用此方法 run() 线程被cpu调度后自动执行线程对象的run方法,直接使用该方法并不启动一个新线程，就是在主线程中调用了一个普通函数而已 ident 获取线程的标识符。线程标识符是一个非零整数，只有在调用了start()方法之后该属性才有效，否则它只返回None。 name 获取或设置线程的名称 getName() 获取线程的名称 setName() 设置线程的名称 is_alive() 判断线程是否为激活状态 isAlive() 判断线程是否为激活状态 setDaemon() 设置为守护线程或非守护线程；默认值为False，如果设置为True，代表该进程为后台守护线程；当非守护线程(不只是主线程)终止时，该线程也随之终止；并且设置为True后，该线程不能创建子线程，设置该属性设置必须在start()之前 isDaemon() 判断是否为守护线程 join() 阻塞等待该线程执行完毕，该方法主要让主线程阻塞等待所有子线程执行完毕 2、线程锁threading.RLock和threading.Lock由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，CPU接着执行其他线程。为了保证数据的准确性，引入了锁的概念。所以，可能出现如下问题： 假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加1000000次，g_num的最终的结果应该为2000000。 但是由于是多线程同时操作，有可能出现下面情况： 在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0然后t2对得到的值进行加1并赋给g_num，使得g_num=1然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确，锁的出现解决了这个问题。 123456789101112131415161718192021222324252627282930313233343536import threadingg_num = 0lock = threading.Lock() #创建锁def work1(num): global g_num for i in range(num): lock.acquire() # 加锁 g_num += 1 lock.release() # 解锁 print(&quot;----in work1, g_num is %d---&quot; % g_num)def work2(num): global g_num for i in range(num): lock.acquire() g_num += 1 lock.release() print(&quot;----in work2, g_num is %d---&quot; % g_num)if __name__ == &#x27;__main__&#x27;: print(&quot;---线程创建之前g_num is %d---&quot; % g_num) t1 = threading.Thread(target=work1, args=(1000000,)) t2 = threading.Thread(target=work2, args=(1000000,)) t1.start() t2.start() t1.join() t2.join() print(&quot;2个线程对同一个全局变量操作之后的最终结果是:%s&quot; % g_num) 3、threading.RLock和threading.Lock 的区别 RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。 如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的锁。 Lock多次加锁演示 123456import threadinglock = threading.Lock() #Lock对象lock.acquire()lock.acquire() #产生了死锁。lock.release()lock.release() RLock多次加锁演示 123456import threadingrLock = threading.RLock() #RLock对象rLock.acquire()rLock.acquire() #在同一线程内，程序不会堵塞。rLock.release()rLock.release() 4、threading.Event通过threading.Event()可以创建一个事件管理标志，该标志（event）默认为False，event对象主要有四种方法可以调用： event.wait(timeout=None)：调用该方法的线程会被阻塞，如果设置了timeout参数，超时后，线程会停止阻塞继续执行； event.set()：将event的标志设置为True，调用wait方法的所有线程将被唤醒； event.clear()：将event的标志设置为False，调用wait方法的所有线程将被阻塞； event.isSet()：判断event的标志是否为True。 12345678910111213141516import threadingdef do(event): print(&#x27;start&#x27;) event.wait() print(&#x27;execute&#x27;)event_obj = threading.Event()for i in range(10): t = threading.Thread(target=do, args=(event_obj,)) t.start()event_obj.clear()inp = input(&#x27;input:&#x27;)if inp == &#x27;true&#x27;: event_obj.set() 5、threading.ConditionPython提供的Condition对象提供了对复杂线程同步问题的支持。 Condition被称为条件变量，除了提供与Lock类似的acquire和release方法外，还提供了wait和notify方法。 Condition的处理流程如下： 首先acquire一个条件变量，然后判断一些条件。 如果条件不满足则wait； 如果条件满足，进行一些处理改变条件后，通过notify方法通知其他线程，其他处于wait状态的线程接到通知后会重新判断条件。 不断的重复这一过程，从而解决复杂的同步问题。 Condition的基本原理如下：可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池。线程通过acquire获得Condition对象，当调用wait方法时，线程会释放Condition内部的锁并进入blocked状态，同时在waiting池中记录这个线程。当调用notify方法时，Condition对象会从waiting池中挑选一个线程，通知其调用acquire方法尝试取到锁。 Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。 除了notify方法外，Condition对象还提供了notifyAll方法，可以通知waiting池中的所有线程尝试acquire内部锁。由于上述机制，处于waiting状态的线程只能通过notify方法唤醒，所以notifyAll的作用在于防止有的线程永远处于沉默状态。 Condition的案例演示如下：演示条件变量同步的经典问题是生产者与消费者问题：假设有一群生产者(Producer)和一群消费者（Consumer）通过一个市场来交互产品。生产者的”策略“是如果市场上剩余的产品少于1000个，那么就生产100个产品放到市场上；而消费者的”策略“是如果市场上剩余产品的数量多余100个，那么就消费3个产品。 用Condition解决生产者与消费者问题的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on Wed Nov 28 17:15:29 2018@author: 18665&quot;&quot;&quot;import threadingimport timeclass Producer(threading.Thread): # 生产者函数 def run(self): global count while True: if con.acquire(): # 当count 小于等于1000 的时候进行生产 if count &gt; 1000: con.wait() else: count = count+100 msg = self.name+&#x27; produce 100, count=&#x27; + str(count) print(msg) # 完成生成后唤醒waiting状态的线程， # 从waiting池中挑选一个线程，通知其调用acquire方法尝试取到锁 con.notify() con.release() time.sleep(1)class Consumer(threading.Thread): # 消费者函数 def run(self): global count while True: # 当count 大于等于100的时候进行消费 if con.acquire(): if count &lt; 100: con.wait() else: count = count-5 msg = self.name+&#x27; consume 5, count=&#x27;+str(count) print(msg) con.notify() # 完成生成后唤醒waiting状态的线程， # 从waiting池中挑选一个线程，通知其调用acquire方法尝试取到锁 con.release() time.sleep(1)count = 500con = threading.Condition()def test(): for i in range(2): p = Producer() p.start() for i in range(5): c = Consumer() c.start()if __name__ == &#x27;__main__&#x27;: test() 6、queue模块queue.Queue 就是消息队列，可以利用它实现线程间的安全通信。 123456789101112import queueq = queue.Queue(maxsize=0) # 构造一个先进显出队列，maxsize指定队列长度，为0 时，表示队列长度无限制。q.join() # 等到队列为kong的时候，在执行别的操作q.qsize() # 返回队列的大小 （不可靠）q.empty() # 当队列为空的时候，返回True 否则返回False （不可靠）q.full() # 当队列满的时候，返回True，否则返回False （不可靠）q.put(item, block=True, timeout=None) # 将item放入Queue尾部，item必须存在，可以参数block默认为True,表示当队列满时，会等待队列给出可用位置，为False时为非阻塞，此时如果队列已满，会引发queue.Full 异常。 可选参数timeout，表示 会阻塞设置的时间，过后，如果队列无法给出放入item的位置，则引发 queue.Full 异常q.get(block=True, timeout=None) # 移除并返回队列头部的一个值，可选参数block默认为True，表示获取值的时候，如果队列为空，则阻塞，为False时，不阻塞，若此时队列为空，则引发 queue.Empty异常。 可选参数timeout，表示会阻塞设置的时候，过后，如果队列为空，则引发Empty异常。q.put_nowait(item) # 等效于 put(item,block=False)q.get_nowait() # 等效于 get(item,block=False) 代码如下： 1234567891011121314151617181920212223242526import queueimport threadingimport timemessage = queue.Queue(3)def producer(): for i in range(10): message.put(i) print(&quot;PUT&gt;&gt;&gt;%d&quot; % i)def consumer(): for i in range(10): msg = message.get() print(&quot;GET&gt;&gt;&gt;%d&quot; % msg) time.sleep(1)if __name__ == &#x27;__main__&#x27;: t1 = threading.Thread(target=producer) t2 = threading.Thread(target=consumer) t1.start() t2.start() Python 进程1、multiprocess模块process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。 1语法：Process([group [, target [, name [, args [, kwargs]]]]]) 123456789101112131415161718import multiprocessingimport timedef worker(num): &quot;&quot;&quot; process worker function :return: &quot;&quot;&quot; time.sleep(3) print(&quot;The num is %d&quot; % num) returnif __name__ == &#x27;__main__&#x27;: for i in range(5): t = multiprocessing.Process(target=worker, args=(i,), name=&quot;t.%d&quot; % i) t.start() Process参数介绍： group：参数未使用，默认值为None。 target：表示调用对象，即子进程要执行的任务。 args：表示调用的位置参数元组。 kwargs：表示调用对象的字典。如kwargs = {‘name’:Jack, ‘age’:18}。 name：子进程名称。 daemon：设置为守护进程(True)或非守护进程(默认：False) Process属性方法介绍 方法/属性 说明 start() 启动进程，调用进程中的run()方法。 run() 进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 。 terminate() 强制终止进程，不会进行任何清理操作。如果该进程终止前，创建了子进程，那么该子进程在其强制结束后变为僵尸进程；如果该进程还保存了一个锁那么也将不会被释放，进而导致死锁。使用时，要注意。 is_alive() 判断某进程是否存活，存活返回True，否则False。 join([timeout]) 主线程等待子线程终止。timeout为可选择超时时间；需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程 。 daemon 默认值为False，如果设置为True，代表该进程为后台守护进程；当该进程的父进程终止时，该进程也随之终止；并且设置为True后，该进程不能创建子进程，设置该属性必须在start()之前 name 进程名称。 pid 进程pid exitcode 进程运行时为None，如果为-N，表示被信号N结束了。 authkey 进程身份验证，默认是由os.urandom()随机生成32字符的字符串。这个键的用途是设计涉及网络连接的底层进程间的通信提供安全性，这类连接只有在具有相同身份验证才能成功。 注意: 在进程python的设计里面只有主进程可以接收input()的输入，子进程没有输入模式，运行直接报错 更坑的是进程池，表面上不会出错，但是input()函数一旦进入无法退出，一直在接收输入的数据 2、消息队列multiprocess.Queue可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序 Queue属性方法说明 方法/属性 说明 get( [ block [ ,timeout ] ] ) 返回q中的一个元素。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。 get_nowait( ) 同q.get(False)方法。 put(item [, block [,timeout ] ] ) 将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。 q.qsize() 返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。 q.empty() 如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。 q.full() 如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。。 其他方法(了解) q.close() 关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。 q.cancel_join_thread() 不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。 q.join_thread() 连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。 3、进程池为什么要有进程池?进程池的概念。 在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？ 在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。 multiprocess.Pool模块1语法：Pool([numprocess [,initializer [, initargs]]]) Pool参数介绍 numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值 initializer：是每个工作进程启动时要执行的可调用对象，默认为None initargs：是要传给initializer（可迭代）的参数组 Pool主要方法介绍 方法/属性 说明 apply(func [, args [, kwargs]]) 在一个池工作进程中执行func(args,*kwargs),然后返回结果。’需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用apply()函数或者使用p.apply_async() apply_async(func [, args [, kwargs]]) 在一个池工作进程中执行func(args,*kwargs),然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。 close() 关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成 terminate() 不管任务是否完成，立即停止工作进程。在对pool对象进程垃圾回收的时候，会立即调用terminate() jion() 等待所有工作进程退出。此方法只能在close（）或teminate()之后调用 其他方法(了解） 方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法 obj.get() 返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。 obj.ready() 如果调用完成，返回True obj.successful() 如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常 obj.wait([timeout]) 等待结果变为可用。 obj.terminate() 立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数 进程池中的Queue如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue() Python 协程协程，又称微线程，纤程。英文名Coroutine。协程是python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（理解为需要的资源）。 为啥说它是一个执行单元，因为它自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。 通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定 1. 协程和线程差异在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。 2. 实现方式 yield 123456789101112131415161718192021222324import timedef work1(): while True: print(&quot;----work1---&quot;) yield time.sleep(0.5)def work2(): while True: print(&quot;----work2---&quot;) yield time.sleep(0.5)def main(): w1 = work1() w2 = work2() while True: next(w1) next(w2)if __name__ == &quot;__main__&quot;: main() greenlet 为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单 安装方式使用如下命令安装greenlet模块: 1sudo pip3 install greenlet 12345678910111213141516171819202122#coding=utf-8from greenlet import greenletimport timedef test1(): while True: print &quot;---A--&quot; gr2.switch() time.sleep(0.5)def test2(): while True: print &quot;---B--&quot; gr1.switch() time.sleep(0.5)gr1 = greenlet(test1)gr2 = greenlet(test2)#切换到gr1中运行gr1.switch() gevent greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent 其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。 由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。 安装方式使用如下命令安装gevent模块: 1pip3 install gevent 在gevent中不能直接使用time.sleep类似的方法，要么使用gevent.sleep，要么利用gevent.monkey打补丁 123456789101112131415from gevent import monkeyimport geventimport randomimport timedef coroutine_work(coroutine_name): for i in range(10): print(coroutine_name, i) time.sleep(random.random())gevent.joinall([ gevent.spawn(coroutine_work, &quot;work1&quot;), gevent.spawn(coroutine_work, &quot;work2&quot;)]) 获得进程和线程信息想要获取线程和进程相关信息，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-&quot;&quot;&quot;获得线程, 进程 ID,NAME总结:&quot;&quot;&quot;import threadingimport psutilimport osimport datetime# 1 获取线程ID,NAMEt = threading.currentThread()# 线程IDprint(&#x27;Thread id : %d&#x27; % t.ident)# 线程NAMEprint(&#x27;Thread name : %s&#x27; % t.getName())# 2 获取线程ID,NAMEpid = os.getpid()p = psutil.Process(pid)print(&#x27;----------------&#x27;)# 进程IDprint(&#x27;Process id : %d&#x27; % pid)# 进程NAMEprint(&#x27;Process name : %s&#x27; % p.name())# 获取进程bin路径print(&#x27;Process bin path : %s&#x27; % p.exe())# 获取pid对应的路径print(&#x27;Process path : %s&#x27; % p.cwd())# 进程状态print(&#x27;Process status : %s&#x27; % p.status())# 进程运行时间print(&#x27;Process creation time : %s&#x27; % datetime.datetime.fromtimestamp(p.create_time()).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))# CPU使用情况print(p.cpu_times())# 内存使用情况print(&#x27;Memory usage : %s%%&#x27; % p.memory_percent())# 硬盘读取信息print(p.io_counters())# 打开进程socket的namedutples列表print(p.connections())# 此进程的线程数print(&#x27;Process number of threads : %s&#x27; % p.num_threads())","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"系统","slug":"技术/python/系统","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://www.bookandmusic.cn/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://www.bookandmusic.cn/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"协程","slug":"协程","permalink":"https://www.bookandmusic.cn/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"多任务","slug":"多任务","permalink":"https://www.bookandmusic.cn/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/"}]},{"title":"03-HTTP 报文内的 HTTP 信息","slug":"网络通信-03_HTTP 报文内的 HTTP 信息","date":"2019-05-09T11:56:09.000Z","updated":"2021-01-21T07:07:06.000Z","comments":true,"path":"2019/05/09/wang-luo-tong-xin-03-http-bao-wen-nei-de-http-xin-xi/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/09/wang-luo-tong-xin-03-http-bao-wen-nei-de-http-xin-xi/","excerpt":"","text":"HTTP 通信过程包括从客户端发往服务器端的请求以及从服务端返回客户端的响应。 1、HTTP 报文就是一大串通信过程里经过 HTTP 处理后添加的报文。其大致分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分，通常并不一定要有报文主体。 2、编码提升传输速率报文主体和实体主体的差异 报文：HTTP 通信的基本单位，8 位组字节流组成，通过 HTTP 通信传输。 实体：请求或响应的有效载荷数据被传输，内容由实体首部和实体主体组成。 HTTP 报文主体用于传输请求或响应的实体主体。一般情况，报文主体等于实体主体，但是传输中进行编码操作的时候，实体主体内容发生变化。 压缩传输的内容编码HTTP 协议中的内容编码功能就像用压缩软件压缩东西一样，对实体内容进行编码压缩，内容编码后的实体由客户端接受并解码。这可以压缩传输内容，加快传输速度。常见的内容编码有 gzip、compress、deflate、identity（不编码）。 分割发送的分块传输编码HTTP 通信过程中，请求的编码实体资源尚未传输完成之前，浏览器无法显示请求页面，传输大容量数据时候，通过数据分割成多块，能让浏览器逐步显示页面。这就是分块传输编码（Chunked Transfer Coding）。它将实体主体分成多个部分，每一块用十六进制来标记，最后一块使用0（CR+LF)来标记。传输给客户端，由客户端进行解码恢复。 3、发送多种数据的多部分对象集合MIME（Multipurpose Internet Mail Extensions, 多用途因特网邮件扩展），它允许邮件处理文本，图片，视频等多个不同类型的数据，这使我们可以在邮件里写入文字并添加多分附件成为了现实。例如：图片等二进制数据以 ASCII 码字符串编码方式表名，就是利用 MIME 来标记数据类型，在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。相应的，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体，通常在图片或文本文件等上传时使用。多部分对象集合包括： multipart/form-data 在 Web 表单文件上传使用 multipart/byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。 HTTP 报文使用这个多部分对象集合的时候，需要在首部添加 Content-type 字段。使用 boundary 字符串来划分多部分在 boundary 字符串指定的各个实体的起始行之前插入--标记（--AaB03x、--THis_STRING_SEPARATES)在多部分对象集合对应的字符串的最后插入--标记（--AaB03x--） 多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在部分中潜逃使用多部分对象集合。 4、获取部分内容的范围请求过去，用户下载东西中断了必须要从头下载，为了解决这问题，要实现该功能需要指定下载的实体范围，指定范围发送的请求叫做范围请求（Range Request)对一份 10000 字节大小的资源，如果使用范围请求，可以只请求 5001~10000 字节内的资源。这样就算中断了，也可以向服务端指明自己需要的资源字节范围，这些需要在首部字段中表名。形式如下： Range : bytes = 5001 - 100005001 到 10000 的Range : bytes = 5001 -5001 到之后全部的Range : bytes = -3000, 5000 - 7000从头到 3000， 5000 到 7000 的 针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文，另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文，如果服务器无法响应请求，返回状态码 200 OK和完整的实体内容。 5、内容协商返回最合适的内容同一个 Web 网站可能有存着多分相同内容的页面，如中文版和英文版，内容虽然相同，单语言不同。当浏览器默认语言为哪种，访问相同的 URI 的 Web 页面时，会对应返回哪种语言的 Web 页面，这样的机制就叫做内容协商（Content Negotiation）。这协商的请求会包含在首部字段 Accept Accept-Charset Accept-Encoding Accept-Language Content-Language 类型：服务器驱动协商（Server-driven Negotiation)服务器通过请求的首部字段为参考自动处理，但以浏览器直接发送的信息不一定能筛选出最优的内容。客户端驱动协商（Agent-driven Negotiation)用户从浏览器显示的可选项列表中选择， 还可以利用 JS 脚本在 Web 页面自动进行上述选择。透明协商（Transparent Negotiation)上两种方法的结合体。 自我回顾1、HTTP 报文是什么？大致分为哪两部分？2、提升编码传输速率的方法有哪些？3、如何发送多部分对象集合？4、如何进行断点传输？5、内容协商机制是什么？","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"网络通信","slug":"技术/网络通信","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"TCP","slug":"技术/网络通信/TCP","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.bookandmusic.cn/tags/HTTP/"},{"name":"TCP","slug":"TCP","permalink":"https://www.bookandmusic.cn/tags/TCP/"}]},{"title":"02-简单介绍 HTTP 协议结构","slug":"网络通信-02_简单介绍 HTTP 协议结构","date":"2019-05-09T11:55:09.000Z","updated":"2021-01-21T07:07:03.000Z","comments":true,"path":"2019/05/09/wang-luo-tong-xin-02-jian-dan-jie-shao-http-xie-yi-jie-gou/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/09/wang-luo-tong-xin-02-jian-dan-jie-shao-http-xie-yi-jie-gou/","excerpt":"","text":"首先，应用 HTTP 协议时，必定有客户端和服务器端。其中，发起请求的是客户端，响应请求并返回的是服务端。 1、请求报文请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。 2、响应报文服务器以响应的形式返回处理结果。 200 OK 是状态码（status code）和 原因短语。下一行是创建相应的日期，是首部字段 (header field) 的一个属性。下一行是返回内容的总长度。下一行是返回内容的类型。空行后的是资源实体的主体内容。 3、HTTP 是无状态（stateless）协议。 HTTP 自身不对请求和相应之间的通信状态进行保存，即不对发送过的请求或响应进行持久化处理。 这是为了更快地处理大量事务，确保协议的可伸缩性。 这一技术的问题就是当访问一家网站的多个页面时，无法保存其登陆状态，所以根据这一问题，引入了 Cookie 技术来管理状态。 4、HTTP 方法 下面就简单介绍一下常用的几种方法，GET、POST 和 HEAD 除此之外的还有 PUT、DELETE、OPTIONS、TRACE 和 CONNECT，这些不太常用，所以不在这里赘述了。 GET 获取资源。请求已被 URI 识别的资源，就是经过服务器解析后返回的响应内容，文本就保持原样返回，如果是可执行程序，就返回结果。 POST 传输实体主体。 HEAD 获得报文首部。和 GET 一样，但是不返回主体部分，只用于确认 URI 的有效性和资源更新的日期等。 注意：方法名区分大小写，注意要用大写字母。 5、持久化连接 当请求的资源有很多时，会发生多次的 TCP 连接和断开过程，增加了通信量的开销。于是产生了持久链接（HTTP Persistent connections）。 特点： 只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 6、管线化 持久化连接需要等待上一个发送请求得到响应之后才能发送下一个请求，但是管线化技术可以直接发送，这样就能同时并发发送多个请求。 7、Cookie 状态管理。为了解决 HTTP 的无状态，Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。具体实现是 Cookie 根据响应报文内 Set-Cookie 的首部字段信息，通知客户端保存 Cookie，当下一次再像该服务器发送请求，客户端会自动在请求报文中添加 Cookie 值后发送。服务端发现客户端发送的 Cookie 后，回去检查对比记录，得到状态信息。 自我回顾1、请求报文、响应报文的基本组成？2、什么是无状态协议，怎么解决的？3、HTTP 的基本方法？分别有什么功能？4、为了加快资源访问速度出现了什么方法？","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"网络通信","slug":"技术/网络通信","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"TCP","slug":"技术/网络通信/TCP","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.bookandmusic.cn/tags/HTTP/"},{"name":"TCP","slug":"TCP","permalink":"https://www.bookandmusic.cn/tags/TCP/"}]},{"title":"经典排序算法总结与实现","slug":"算法-排序","date":"2019-05-09T11:54:09.000Z","updated":"2021-01-25T02:58:58.000Z","comments":true,"path":"2019/05/09/suan-fa-pai-xu/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/09/suan-fa-pai-xu/","excerpt":"","text":"经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，整理并用Python实现了七大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。之所以用Python实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。 本篇博客所有排序实现均默认从小到大。 一、冒泡排序 BubbleSort介绍冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序逆序就把他们交换过来。 步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 不过针对上述实现过程还有两种优化方案。 优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。 优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。 源代码1234567891011121314151617181920212223242526272829303132333435363738def bubble_sort(ary): n = len(ary) #获得数组的长度 for i in range(n): for j in range(1,n-i): if ary[j-1] &gt; ary[j] : #如果前者比后者大 ary[j-1],ary[j] = ary[j],ary[j-1] #则交换两者 return ary#优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。#用一个标记记录这个状态即可。def bubble_sort2(ary): n = len(ary) for i in range(n): flag = 1 #标记 for j in range(1,n-i): if ary[j-1] &gt; ary[j] : ary[j-1],ary[j] = ary[j],ary[j-1] flag = 0 if flag : #全排好序了，直接跳出 break return ary#优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。# 因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。def bubble_sort3(ary): n = len(ary) k = n #k为循环的范围，初始值n for i in range(n): flag = 1 for j in range(1,k): #只遍历到最后交换的位置即可 if ary[j-1] &gt; ary[j] : ary[j-1],ary[j] = ary[j],ary[j-1] k = j #记录最后交换的位置 flag = 0 if flag : break return ary 二、选择排序 SelectionSort介绍选择排序无疑是最简单直观的排序。它的工作原理如下。 步骤 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 源代码123456789def select_sort(ary): n = len(ary) for i in range(0,n): min = i #最小元素下标标记 for j in range(i+1,n): if ary[j] &lt; ary[min] : min = j #找到最小值的下标 ary[min],ary[i] = ary[i],ary[min] #交换两者 return ary 三、插入排序 InsertionSort介绍插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果被扫描的元素（已排序）大于新元素，将该元素后移一位 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 排序演示 源代码1234567891011121314def insert_sort(ary): n = len(ary) for i in range(1,n): if ary[i] &lt; ary[i-1]: temp = ary[i] index = i #待插入的下标 for j in range(i-1,-1,-1): #从i-1 循环到 0 (包括0) if ary[j] &gt; temp : ary[j+1] = ary[j] index = j #记录待插入下标 else : break ary[index] = temp return ary 四、希尔排序 ShellSort介绍：希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。 步骤：希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 123413 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序： 123410 14 73 25 2313 27 94 33 3925 59 94 65 8245 将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序： 12345610 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为： 12345610 14 1325 23 3327 25 5939 65 7345 94 8294 最后以1步长进行排序（此时就是简单的插入排序了）。 源代码12345678910111213def shell_sort(ary): n = len(ary) gap = round(n/2) #初始步长 , 用round四舍五入取整 while gap &gt; 0 : for i in range(gap,n): #每一列进行插入排序 , 从gap 到 n-1 temp = ary[i] j = i while ( j &gt;= gap and ary[j-gap] &gt; temp ): #插入排序 ary[j] = ary[j-gap] j = j - gap ary[j] = temp gap = round(gap/2) #重新设置步长 return ary 五、归并排序 MergeSort介绍归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。 先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。 再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。 排序演示 源代码12345678910111213141516171819202122def merge_sort(ary): if len(ary) &lt;= 1 : return ary num = int(len(ary)/2) #二分分解 left = merge_sort(ary[:num]) right = merge_sort(ary[num:]) return merge(left,right) #合并数组def merge(left,right): &#x27;&#x27;&#x27;合并操作， 将两个有序数组left[]和right[]合并成一个大的有序数组&#x27;&#x27;&#x27; l,r = 0,0 #left与right数组的下标指针 result = [] while l&lt;len(left) and r&lt;len(right) : if left[l] &lt; right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += left[l:] result += right[r:] return result 六、快速排序 QuickSort介绍快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。 步骤 从数列中挑出一个元素作为基准数。 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。 再对左右区间递归执行第二步，直至各区间只有一个数。 排序演示 源代码1234567891011121314151617181920def quick_sort(ary): return qsort(ary,0,len(ary)-1)def qsort(ary,left,right): #快排函数，ary为待排序数组，left为待排序的左边界，right为右边界 if left &gt;= right : return ary key = ary[left] #取最左边的为基准数 lp = left #左指针 rp = right #右指针 while lp &lt; rp : while ary[rp] &gt;= key and lp &lt; rp : rp -= 1 while ary[lp] &lt;= key and lp &lt; rp : lp += 1 ary[lp],ary[rp] = ary[rp],ary[lp] ary[left],ary[lp] = ary[lp],ary[left] qsort(ary,left,lp-1) qsort(ary,rp+1,right) return ary 七、堆排序 HeapSort介绍：堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。 二叉堆具有以下性质： 父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。 步骤 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0...n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。 排序演示 源代码1234567891011121314151617181920212223242526def heap_sort(ary) : n = len(ary) first = int(n/2-1) #最后一个非叶子节点 for start in range(first,-1,-1) : #构造大根堆 max_heapify(ary,start,n-1) for end in range(n-1,0,-1): #堆排，将大根堆转换成有序数组 ary[end],ary[0] = ary[0],ary[end] max_heapify(ary,0,end-1) return ary#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点#start为当前需要调整最大堆的位置，end为调整边界def max_heapify(ary,start,end): root = start while True : child = root*2 +1 #调整节点的子节点 if child &gt; end : break if child+1 &lt;= end and ary[child] &lt; ary[child+1] : child = child+1 #取较大的子节点 if ary[root] &lt; ary[child] : #较大的子节点成为父节点 ary[root],ary[child] = ary[child],ary[root] #交换 root = child else : break 总结下面为七种经典排序算法指标对比情况：","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"算法","slug":"技术/算法","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"技术/算法/排序","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.bookandmusic.cn/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"01—了解web及网络基础","slug":"网络通信-01_了解 Web 及网络基础","date":"2019-05-09T11:54:09.000Z","updated":"2021-01-25T02:59:28.000Z","comments":true,"path":"2019/05/09/wang-luo-tong-xin-01-liao-jie-web-ji-wang-luo-ji-chu/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/09/wang-luo-tong-xin-01-liao-jie-web-ji-wang-luo-ji-chu/","excerpt":"","text":"HTTP 的出现主要是为了解决文本传输的难题 TCP/IP 协议族：是互联网相关的各类协议族的总称 重要的一点是分层: 应用层、传输层、网络层、数据链路层 层次化的优点：1、修改某个地方只用改相应的层2、设计变简单，各层管理自己的职责 分层管理应用层：决定向用户提供应用服务时通信的活动，FTP(File Transfer Protocol) 文件传输协议、DNS(Domain Name System) 域名系统、HTTP(HyperText Transfer Protocol)传输层：提供处于网络连接中两台计算机之间的数据传输。TCP(Transmission Control Protocol) 传输控制协议、UDP(User Data Protocol) 用户数据报协议网络层（网络互联层）：处理在网络上流动的数据包（数据包是网络传输的最小数据单位）。该层规定了通过怎样的路径（传输路线）到达对方计算机，并传递数据。作用就是在与对方计算机之间通过多台计算机或网络设备进行传输时，选择一条传输路线。链路层（数据链路层、网络接口层）：用来处理网络的硬件部分。包括控制操作系统、硬件设备驱动、NIC（Network Interface Card，网络适配器）、光纤等物理课件部分（连接器等一切传输媒介）。 通信传输流 应用发请求通过 TCP 处理报文进行分隔发送给网络层网络层增加 MAC 地址给链路, 之后反向操作, 请求数据的时候每一层处理完成后会给这个数据加上这个层的首部信息, 相反, 处理请求的时候, 每处理一层就删除一个首部, 这叫做数据信息的封装 (encapsulate)。 IP、TCP 和 DNSIP 协议：IP（Internet Protocol）网络协议处于网络层。几乎所有使用网络的系统都会用到 IP 协议。IP 不是 IP 地址，IP 只是一种协议名称。 作用：把各种数据包传给对方，保证能传送到达需要多种条件，其中最重要的是 IP 地址和 MAC（Media Access Control Address) 地址。 IP 地址：指明节点被分配到的地址 MAC 地址： 网卡所属的固定地址 IP 地址可以和 MAC 地址进行配对，IP 可变，但 MAC 基本不会更改。 不同局域网之间的通信需要经过多次中转，在中转时会利用下一站中转设备的 MAC 地址来搜索下一个中转目标，这时会采用 ARP 协议（Addres s Resolution Protocol)，这是用于解析地址的协议，可以根据对方 IP 地址就能反查处对应的 MAC 地址。 信息传输的时候，并不是从一开始就设计好精确的路线，而是边走边瞧，到下一个中转点会自动判断下一个中转点，这叫做路由选择（routing） TCP 协议按层次位于传输层, 提供可靠的字节流服务 (Byte Stream Service), 意思是为了方便传输, 将大块数据分割成以报文段(segment) 为单位的数据包进行管理可靠的传输服务是指，能够把数据准确可靠的传给对方。 如何确保数据到达目标 三次握手（three—way handshaking）策略 发送端先发送一个带有 SYN（synchronize 同步）标识的数据包给对方 对方接收到后回传一个带有 SYN/ACK（acknowledgement)标识的数据包已传达确认信息 最后发送端再传回一个带有 ACK 标识的数据包代表 “握手” 结束。 若期间在某个过程莫名中断, TCP 协议会在此以相同顺序发送相同数据包。 DNS 服务 DNS 服务是和 HTTP 一样位于应用层, 提供域名到 IP 地址之间的解析服务。 计算机可以有 IP 地址, 又可以有主机名和域名。比如可以使用 www.baidu.com 访问百度，也可以使用 119.75.217.109 访问百度。DNS 协议就是可以查询其对应关系的协议。 各种协议与 HTTP 协议的关系 客户端发出对某 www. 网站的请求, 通过 DNS 协议获取对应的 IP 地址, 在通过 HTTP 协议生成请求报文, 通过 TCP 进行分隔划分成数据包, 通过三次握手把每个报文段可靠的传给对方, 再通过 IP 协议分配 IP 地址和 MAC 地址, 一遍中转一遍传送, 对方通过 IP 协议接收一段段报文, 通过 TCP 协议再一段段重组, 在通过 HTTP 协议对这些内容进行处理请求信息, 把请求结果再像上边的过程走回客户端。一次完整的传输就结束了。 URI 和 URL URL（Uniform Resource Locator) 统一资源定位符，就是 Web 浏览器访问 web 页面时候的网页地址，http://www.baidu.com URI（Uniform Resource Identifier) 统一资源标识符 Uniform 规定统一格式可方便处理多种不同类型资源。 Resouce 资源定义是 “可标识的任何东西”。 Identifier 可标识的对象。也称作标识符。 综上，URI 就是由某协议方案表示的资源的定位标识符，其中，访问资源所使用的协议类型， HTTP 协议时，协议方案就是 http，除此还有 ftp、mailto、telent、file 等。 URI 用字符串标识某一互联网资源，URL 表示资源的地点，可见 URL 是 URI 的子集。 URI 格式绝对 URI 格式： 可选项：登录信息、服务器端口号、查询字符串、片段标识符 自我回顾1、HTTP、TCP/IP、DNS、URL、URI 分别是什么?2、TCP/IP 协议为什么进行分层管理，又分为哪些层?3、客户端到服务端的请求过程是什么?4、三次握手怎么进行的?5、各个协议的关系是什么？ 注： 本文图片均来自《图解 HTTP》一书","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"网络通信","slug":"技术/网络通信","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"TCP","slug":"技术/网络通信/TCP","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.bookandmusic.cn/tags/HTTP/"},{"name":"TCP","slug":"TCP","permalink":"https://www.bookandmusic.cn/tags/TCP/"}]},{"title":"time与timeit 模块","slug":"python模块-time-timeit-模块","date":"2019-05-03T12:14:29.000Z","updated":"2021-01-23T15:07:25.000Z","comments":true,"path":"2019/05/03/python-mo-kuai-time-timeit-mo-kuai/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/03/python-mo-kuai-time-timeit-mo-kuai/","excerpt":"","text":"一、time 模块1. 时间表现形式 timestamp：时间戳，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量 struct_time： 时间元组，共有九个元素组 format time： 格式化时间，已格式化的结构使时间更具可读性。包括自定义格式和固定格式2. 时间格式转换图 3. 常用方法 获取当前时间戳 12345In [26]: time.time()Out[26]: 1556888776.3707364In [25]: time.mktime(time.localtime()) # 元组-&gt;时间戳Out[25]: 1556888742.0 当前时间的 struct_time 形式 12345678910111213141516In [1]: import time In [2]: time.localtime() Out[2]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=20, tm_min=48, tm_sec=32, tm_wday=4, tm_yday=123, tm_isdst=0) In [29]: time.localtime(time.time()) # 时间戳-&gt;元组 Out[29]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=21, tm_min=12, tm_sec=6, tm_wday=4, tm_yday=123, tm_isdst=0) In [22]: time.gmtime() Out[22]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=13, tm_min=3, tm_sec=21, tm_wday=4, tm_yday=123, tm_isdst=0) In [30]: time.gmtime(time.time()) # 时间戳-&gt;元组 Out[30]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=13, tm_min=12, tm_sec=21, tm_wday=4, tm_yday=123, tm_isdst=0)In [34]: time.strptime(a, &quot;%a %b %d %H:%M:%S %Y&quot;) # 字符串-&gt;元组Out[34]: time.struct_time(tm_year=2019, tm_mon=5, tm_mday=3, tm_hour=21, tm_min=9, tm_sec=25, tm_wday=4, tm_yday=123, tm_isdst=-1) 当前时间的字符串形式 1234567891011121314151617In [3]: time.ctime()Out[3]: &#x27;Fri May 3 20:49:30 2019&#x27;In [27]: time.ctime(time.time()) # 时间戳-&gt;字符串Out[27]: &#x27;Fri May 3 21:08:20 2019&#x27;In [4]: time.asctime()Out[4]: &#x27;Fri May 3 20:49:45 2019&#x27;In [28]: time.asctime(time.localtime()) # 元组-&gt;默认字符串Out[28]: &#x27;Fri May 3 21:09:25 2019&#x27;In [7]: time.strftime(&#x27;%Y-%m-%d %H:%M&quot;%S&#x27;, time.localtime()) # 元组-&gt;格式化字符串Out[7]: &#x27;2019-05-03 20:52&quot;47&#x27;In [31]: time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime())Out[31]: &#x27;Fri May 03 21:15:50 2019&#x27; 4. 耗时统计 time.perf_counter() 调用一次 perf_counter()，从计算机系统里随机选一个时间点A，计算其距离当前时间点B1有多少秒 当第二次调用该函数时，默认从第一次调用的时间点A算起，距离当前时间点B2有多少秒 两个函数取差，即实现从时间点B1到B2的计时功能 time.process_time() 返回当前进程执行 CPU 的时间总和，不包含睡眠时间 由于返回值的基准点是未定义的 只有连续调用的结果之间的差才是有效的 time.time() 连续两次生成的时间戳之差即为耗时12345678910111213141516171819import timedef test(): time.sleep(2)start1 = time.perf_counter()start2 = time.time()start3 = time.process_time()test()finish1 = time.perf_counter()finish2 = time.time()finish3 = time.process_time()t1 = finish1 - start1t2 = finish2 - start2t3 = finish3 - start3print(t1)print(t2)print(t3) 结果为：1231.9998265000000002 # perf_counter2.000767946243286 # time0.0 # process_time","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"模块","slug":"技术/python/模块","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E6%A8%A1%E5%9D%97/"}],"tags":[{"name":"时间模块","slug":"时间模块","permalink":"https://www.bookandmusic.cn/tags/%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/"}]},{"title":"装饰器","slug":"python函数-装饰器","date":"2019-05-02T06:30:27.000Z","updated":"2021-01-23T15:05:25.000Z","comments":true,"path":"2019/05/02/python-han-shu-zhuang-shi-qi/","link":"","permalink":"https://www.bookandmusic.cn/2019/05/02/python-han-shu-zhuang-shi-qi/","excerpt":"","text":"返回函数 python的常识，函数和其他任何东西一样，都是对象。这意味着可以将函数当做实参传递给函数，或者在函数中将函数作为返回值返回。 123456789def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sumf = lazy_sum(1, 3, 5, 7, 9)f() 闭包闭包是“返回函数”的一个典型应用 闭包的定义： 在一个外函数(outer)中定义了一个内函数(inner) 内函数里运用了外函数的临时变量 并且外函数的返回值是内函数的引用 闭包的使用，可以隐藏内部函数的工作细节，只给外部使用者提供一个可以执行的内部函数的引用。 12345678910111213141516#闭包函数的实例 # outer是外部函数 a和b都是外函数的临时变量 def outer( a ): b = 10 def inner(): # inner是内函数 print(a+b) #在内函数中 用到了外函数的临时变量 return inner # 外函数的返回值是内函数的引用 # 在这里我们调用外函数传入参数5 #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数 demo = outer(5) # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量 # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数 demo() # 15 inner函数修改outer函数变量 123456789101112131415def createCounter(): i = 0 def counter(): nonlocal i # 指定外部函数的局部变量 i = i + 1 return i return countercounterA = createCounter()print(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5counterB = createCounter()if [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]: print(&#x27;测试通过!&#x27;)else: print(&#x27;测试失败!&#x27;) 装饰器装饰器介绍要了解python中@装饰器的作用，首先要记住这么几点： 装饰器符号@属于语法糖 什么意思呢？ 就是说，我不按照@装饰器的语法要求来写，而是按照一般python的语法要求来写完全可以。 那么用@装饰器的格式来写的目的就是为了书写简单方便 注意：装饰器是用于拓展已有函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，实际上就是利用闭包语法实现的。 装饰器语法装饰器的作用是什么呢？ 简单的理解就是：装饰原有的函数。什么意思呢？ 比如有一个函数func(a, b)，它的功能是求a,b的差值 现在有一个新需求，就是想对函数功能再装饰下，求完差值后再取绝对值，但是不能能修改原有函数，这时候就需要装饰器装饰函数 1234567891011121314&quot;&quot;&quot;函数闭包实现求差值之后，再求绝对值&quot;&quot;&quot;def func(a, b): return a- bdef abs_num(func): def inner(a, b): ret = func(a, b) return abs(ret) return inner@abs_numfunc(2, 3) 当abs_num装饰函数func时，类似于将函数func作为参数传给abs_num,并将返回值即内层函数(inner)名重新赋值给变量func 当调用函数func时，实质是调用内层函数inner，在内层函数中执行func函数，即最原始的函数func 装饰器分类被装饰函数有参数123456789101112131415def outer(func): def inner(x, y): func(x, y) # 新版的 func 才是 原来的 add return inner@outerdef add(x, y): print(x + y)add(1, 2) # 新版的 add 是 内层 inner# add(1, 2) ====&gt; inner(1, 2) ====&gt; func(1, 2) ===&gt; 3 被装饰函数 有参数，inner和 func需要同样的参数 被装饰函数有返回值1234567891011121314151617181920def outer(func): def inner(x, y): r = func(x, y) # 装饰器装饰之后， func才是真正的add求和函数 r += 10 # 将两数之和再加 10 return r return inner@outerdef add(x, y): return x + y# 在装饰器中 对函数的执行结果 加10 处理r = add(10, 200) # add实际是innerprint(r) 被装饰函数有返回值， inner需要将 func 的结果 返回 被装饰的函数有不定长参数12345678910111213141516def set_func(func): def call_func(*args, **kwargs): # func(args, kwargs),此时得到的是元组和字典 # func(*args, **kwargs),此时则是把元素拆包为单个数值和键值对 return func(*args, **kwargs) return call_func@set_funcdef s(a, b, *args, **kwargs): print(a, b, args, kwargs)s(12, 50, 34, c=20, d=56) 形参 *args：接收多余的参数，得到元组(args) **kwargs:接收多余的关键字参数，得到字典(kwargs) 实参 *args：对元组(args)进行拆包，得到单个数值 **kwargs：对字典(kwargs)拆包，得到单个的键值对 多个装饰器装饰函数 多个装饰器装饰同一个函数，装饰顺序和执行顺序正好相反 装饰器函数的执行顺序和装饰器的顺序有关 12345678910111213141516171819202122232425262728def set_func1(func): print(&quot;这是测试1...&quot;) def call_func1(): print(&quot;这是装饰器1...&quot;) return func() return call_func1def set_func2(func): print(&quot;这是测试2...&quot;) def call_func2(): print(&quot;这是装饰器2...&quot;) return func() return call_func2@set_func1@set_func2def s(): print(&quot;hello...&quot;)s() 代码从上到下，依次执行，同时装饰器是用来装饰函数的 执行到装饰器set_func1时，无法装饰，先跳过 执行装饰器set_func2时，装饰原始函数s， 先执行set_func2,输出”这是测试2…”， 然后得到s = call_func2(s)，此时的s是原始函数s 然后装饰器set_func1装饰新得到的函数s = call_func2(s) 先执行set_func1,输出”这是测试1…” 然后得到s = call_func1(s)，此时的s是新得到的函数s = call_func2(s) 最后得到函数s = call_func1(call_func(s)) 最后执行函数s 先执行call_func1,输出”这是装饰器1…” 再执行call_func2,输出”这是装饰器2…” 最后执行原始函数s，输出”hello…” 装饰器带参1234567891011121314def set_pars(pars): def set_func(func): def call_func(): print(&quot;這是測試級別%d&quot; % pars) return func() return call_func return set_func@set_pars(10) # 装饰分两步def s(): print(&quot;hello...&quot;)s() 装饰器带参时，装饰函数过程分两步： 将参数传给函数set_pars，进行执行 将函数返回结果作为函数s的装饰器进行装饰 类装饰器123456789101112131415161718class Test(object): def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): &#x27;&#x27;&#x27; 魔法方法__call__可以将对象设置为可调用对象（callable）,允许一个类的实例像函数一样被调用 &#x27;&#x27;&#x27; print(&quot;这是类装饰器...&quot;) return self.func(*args, **kwargs)@Test # s = Test(s)def s(*args, **kwargs): print(&quot;hello python...&quot;)s() 自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号()应用到某个对象身上都可称之为可调用对象 判断对象是否为可调用对象可以用函数 callable 如果在类中实现了 call 方法，那么实例对象也将成为一个可调用对象 示例装饰器处理响应值函数input_str中，会获取用户输入字符串，并返回其结果，利用装饰器将其字符串先加上&lt;b&gt;&lt;/b&gt;标签，再添加&lt;i&gt;&lt;/i&gt;标签，如：&lt;i&gt;&lt;b&gt;hello&lt;/b&gt;&lt;/&gt;。注意：利用双层装饰器实现。 12345678910111213141516171819def set_func_b(func): def call_func(): return &quot;&lt;b&gt;&quot; + func() + &quot;&lt;/b&gt;&quot; return call_funcdef set_func_i(func): def call_func(): return &quot;&lt;i&gt;&quot; + func() + &quot;&lt;/i&gt;&quot; return call_func@set_func_i@set_func_bdef input_str(): str = input(&quot;输入：&quot;) return strprint(input_str()) 装饰器限频请实现一个装饰器,限制该函数被调用的频率,如10秒一次 123456789101112131415161718192021222324import timedef set_time(t): def set_num(func): dic = &#123;&quot;last_time&quot;: 0, &quot;time_interval&quot;: t&#125; def call_func(): now_time = time.time() finall_time = dic[&quot;last_time&quot;] + dic[&quot;time_interval&quot;] if finall_time &lt;= now_time: dic[&quot;last_time&quot;] = now_time ret = func() return ret else: print(&quot;还有%.2fs才能调用该函数&quot; % (finall_time - now_time)) return call_func return set_num@set_time(5)def s(): print(&quot;hello...&quot;) 请实现一个装饰器,限制该函数每个间隔被调用的频率,如1分钟5次 1234567891011121314151617181920212223242526272829303132333435363738import timedef set_time(t, n): def set_num(func): dic = &#123;&quot;last_time&quot;: 0, &quot;time_interval&quot;: t, &quot;num&quot;: 0&#125; def call_func(): now_time = time.time() finall_time = dic[&quot;last_time&quot;] + dic[&quot;time_interval&quot;] # 代表可以重新调用的时间 finall_num = dic[&quot;num&quot;] # 代表调用的次数 if finall_num &lt; n: # 当次数不满足时，可以继续调用 if finall_num == 0: dic[&quot;last_time&quot;] = now_time dic[&quot;num&quot;] += 1 return func() elif now_time &gt;= finall_time: # 已经超出时间，可以重新调用 dic[&quot;num&quot;] = 0 dic[&quot;last_time&quot;] = 0 return func() else: print(&quot;还有%.2fs才能调用该函数&quot; % (finall_time - now_time)) return call_func return set_num@set_time(60, 5)def s(): print(&quot;hello...&quot;)s()s()s()time.sleep(2)s()","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"https://www.bookandmusic.cn/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"闭包","slug":"闭包","permalink":"https://www.bookandmusic.cn/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"Git操作","slug":"工具-Git操作","date":"2019-03-31T04:15:27.000Z","updated":"2021-01-25T02:56:53.000Z","comments":true,"path":"2019/03/31/gong-ju-git-cao-zuo/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/31/gong-ju-git-cao-zuo/","excerpt":"","text":"Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，开发人员必备技能。 1. 安装Git windows：到git官网上下载, Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 1sudo apt-get install git 安装好后，用git --version 来查看一下版本 2. 基本操作 3. 远程仓库密钥配置1. GitHub密钥配置1.1. 设置身份信息git设置身份信息 123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;your@email.com&quot; 1.2. 删除.ssh文件夹（直接搜索该文件夹）下的known_hosts(手动删除即可，不需要git） 1.3. 创建密钥终端输入命令 1ssh-keygen -t rsa -C &quot;your@email.com&quot;（请填你设置的邮箱地址） 接着出现： 123Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 请直接按下回车 然后系统会自动在.ssh文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打id_rsa.pub 将全部的内容复制 1.4. 添加公钥打开https://github.com/，登陆你的账户，进入设置 进入ssh设置 点击 New SSH key 在key中将刚刚复制的粘贴进去 最后点击Add SSH key 1.5. 测试在终端输入 1ssh -T git@github.com 你将会看到： 123The authenticity of host &#x27;github.com (207.97.227.239)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 输入 yes 1Hi humingx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 如果看到Hi后面是你的用户名，就说明成功了。 2. Gitee仓库密钥配置类似 重装系统之后,git push的时候会出现问题:The authenticity of host &#39;github.com (13.229.188.59)&#39; can&#39;t be established.，原因是本地仓库和远程的SSH不匹配 解决办法：重新配置仓库密钥即可。 4. 本地仓库关联远程仓库 已有仓库 12cd existing_git_repogit remote add origin https://gitee.com/bookandmusic/test.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 1git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支source推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 新建git仓库，并关联远程仓库 12345678mkdir testcd testgit inittouch README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://gitee.com/bookandmusic/test.gitgit push -u origin master 用git进行push操作的时候，报fatal: TaskCanceledException encountered.的解决方法 解决方法如下： 1git config --global credential.helper manager 之后再push一切正常","categories":[{"name":"工具","slug":"工具","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"工具/Git","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.bookandmusic.cn/tags/Git/"},{"name":"密钥","slug":"密钥","permalink":"https://www.bookandmusic.cn/tags/%E5%AF%86%E9%92%A5/"},{"name":"远程仓库关联","slug":"远程仓库关联","permalink":"https://www.bookandmusic.cn/tags/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/"}]},{"title":"Node.js环境配置","slug":"工具-Nodejs环境配置","date":"2019-03-31T03:58:35.000Z","updated":"2021-01-25T02:56:48.000Z","comments":true,"path":"2019/03/31/gong-ju-nodejs-huan-jing-pei-zhi/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/31/gong-ju-nodejs-huan-jing-pei-zhi/","excerpt":"","text":"简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 Node.js版本管理 手动安装nvm 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash 1wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash 运行以上任一命令将下载一个脚本并运行它。 该脚本会将nvm存储库克隆到~/.nvm,并尝试将以下代码段中的源代码行添加到正确的配置文件（~/.bash_profile, ~/.zshrc, ~/.profile, 或 ~/.bashrc） 12export NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 修改nvm默认镜像源 用国内镜像快速安装node,把环境变量 NVM_NODEJS_ORG_MIRROR加入到正确的配置文件（~/.bash_profile,~/.zshrc, ~/.profile, 或 ~/.bashrc） 1export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm命令 123456789101112131415nvm version # 查看当前的版本nvm ls-remote # 列出所有可以安装的node版本号nvm install stable # 安装最新稳定版本nvm install &lt;version&gt; # 安装指定版本号的nodenvm use &lt;version&gt; # 切换使用指定的版本nodenvm ls # 列出所有已经安装的node版本nvm current # 当前node版本nvm alias default &lt;version&gt; # 指定默认的node版本nvm alias &lt;name&gt; &lt;version&gt; # 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm uninstall &lt;version&gt; 卸载指定的版本 Node.js包管理 安装包管理工具: npm、cnpm、yarn 123npm -g install npm@next # npm升级npm install -g cnpm --registry=https://registry.npm.taobao.org # cnpm安装npm install -g yarn # yarn安装 查看已安装的所有全局包 12345npm list -g --depth=0cnpm list -g --depth=0yarn global list 安装包 12345npm install -g &lt;package&gt;cnpm install -g &lt;package&gt;yarn global add &lt;package&gt; 卸载包 12345npm uninstall -g &lt;package&gt;cnpm uninstall -g &lt;package&gt;yarn global remove &lt;package&gt; 更新包 1npm update &lt;package&gt; 更新本地包 12npm upgrade --saveyarn upgrade 其他一些常用的命令 1234567npm config get registry # 查看npm当前镜像源npm config set registry https://registry.npm.taobao.org/ # 设置npm镜像源为淘宝镜像yarn config get registry # 查看yarn当前镜像源yarn config set registry https://registry.npm.taobao.org/ # 设置yarn镜像源为淘宝镜像 Node.js镜像管理 直接编辑npm的配置文件 1npm config edit 直接修改registry的地址 1234sass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/electron_mirror=https://npm.taobao.org/mirrors/electron/registry=https://registry.npm.taobao.org 用代码更改npm的配置文件 1npm config set registry http://registry.npm.taobao.org 这段代码即将镜像改为淘宝镜像 使用nrm管理registry地址 安装nrm 1npm install -g nrm 查看镜像列表 1nrm ls 切换镜像 1nrm use taobao 在nrm添加自己的镜像地址 123nrm add r_name r_url# r_name镜像名字 # r_url镜像地址 删除 1nrm del r_name 测试镜像的相应速度 1nrm test r_name 第三方脚手架 vue 3.0(Node最新版) 123npm install -g @vue/cli# ORyarn global add @vue/cli vue2.0 Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 1npm install -g @vue/cli-init 或者直接安装vue-cli脚手架 1cnpm install -g vue-cli http-server 利用http-server，开启本地服务 1cnpm install -g http-server 123456http-server -c-1 （⚠️只输入http-server的话，更新了代码后，页面不会同步更新）Starting up http-server, serving ./Available on: http://127.0.0.1:8080 http://192.168.8.196:8080Hit CTRL-C to stop the server hexo-cli 1cnpm install -g hexo-cli gitbook-cli 1cnpm install -g gitbook-cli","categories":[{"name":"工具","slug":"工具","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/"},{"name":"NodeJs","slug":"工具/NodeJs","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://www.bookandmusic.cn/tags/NodeJs/"},{"name":"npm","slug":"npm","permalink":"https://www.bookandmusic.cn/tags/npm/"},{"name":"nvm","slug":"nvm","permalink":"https://www.bookandmusic.cn/tags/nvm/"},{"name":"yarn","slug":"yarn","permalink":"https://www.bookandmusic.cn/tags/yarn/"}]},{"title":"GitBook教程","slug":"教程-GitBook教程","date":"2019-03-31T03:58:35.000Z","updated":"2021-01-25T02:57:21.000Z","comments":true,"path":"2019/03/31/jiao-cheng-gitbook-jiao-cheng/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/31/jiao-cheng-gitbook-jiao-cheng/","excerpt":"","text":"GitBook 是一个基于Node.js的命令行工具，可以使用Markdown来制作电子书，并利用Git/Github发布。 支持输出静态站点、PDF、eBook、HTML网页等格式。 安装 GitBook 需要 Node 环境，具体怎么安装 Node 这里就不多说了。 安装 GitBook123npm install -g gitbook-cli# ORyarn global add gitbook-cli 检查是否安装成功 1gitbook -V 导出电子书打开到 gitbook 的目录下 1、输出静态网页12345678$ gitbook serve .Press CTRL+C to quit ...Starting build ...Successfuly built !Starting server ...Serving book on http://localhost:4000 这时候就可以打开 http://localhost:4000：进行预览 同时在项目的目录中多了一个 _book 的文件夹，其中的文件就是生成的静态网页的内容。 2、导出 PDF在项目的目录中执行 1gitbook pdf . 项目目录下就会生成 book.pdf 3、导出 epub在项目目录中执行 1gitbook epub . 项目目录下就会生成 book.epub 解决静态网页不能跳转问题 在导出的文件夹目录下找到gitbook-&gt;theme.js文件 找到下面的代码搜索if(m)for(n.handler&amp;&amp; 将if(m)改成if(false) 1if(false)for(n.handler&amp;&amp;(i=n,n=i.handler,o=i.selector),o&amp;&amp;de.find.matchesSelector(Ye,o),n.guid||(n.guid=de.guid++),(u=m.events)||(u=m.events=&#123;&#125;),(a=m.handle)||(a=m.handle=function(t)&#123;return&quot;undefined&quot;!=typeof de&amp;&amp;de.event.triggered!==t.type?de.event.dispatch.apply(e,arguments):void 0&#125;),t=(t||&quot;&quot;).match(qe)||[&quot;&quot;],l=t.length;l--;)s=Ze.exec(t[l])||[],h=g=s[1],d=(s[2]||&quot;&quot;).split(&quot;.&quot;).sort(),h&amp;&amp;(f=de.event.special[h]||&#123;&#125;,h=(o?f.delegateType:f.bindType)||h,f=de.event.special[h]||&#123;&#125;,c=de.extend(&#123;type:h,origType:g,data:r,handler:n,guid:n.guid,selector:o,needsContext:o&amp;&amp;de.expr.match.needsContext.test(o),namespace:d.join(&quot;.&quot;)&#125;,i),(p=u[h])||(p=u[h]=[],p.delegateCount=0,f.setup&amp;&amp;f.setup.call(e,r,d,a)!==!1||e.addEventListener&amp;&amp;e.addEventListener(h,a)),f.add&amp;&amp;(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),o?p.splice(p.delegateCount++,0,c):p.push(c),de.event.global[h]=!0)&#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://www.bookandmusic.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"GitBook","slug":"GitBook","permalink":"https://www.bookandmusic.cn/tags/GitBook/"}]},{"title":"小故事","slug":"生活-小故事","date":"2019-03-23T14:13:30.000Z","updated":"2021-01-25T02:58:41.000Z","comments":true,"path":"2019/03/23/sheng-huo-xiao-gu-shi/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/23/sheng-huo-xiao-gu-shi/","excerpt":"","text":"关于晚安的事有一天，天堂放假，一个天使来到人间，为了化解自己的无聊，对一个女孩说，我可以实现你一个愿望，权利，金钱，美貌，爱情……女孩想得很认真，天使有些害怕，如果她说一些他实现不了的愿望，会很没面子。总之一定要让她看到天使是多么厉害，我要她崇拜我，我要让她感激我。“我想每天睡前都能听到你对我说晚安！”天使惊讶于如此简单的愿望，忽然有一种大材小用的感慨。“好，这很容易！”天使根本没有多想，就如此轻易的答应了。女孩也就欢欣雀跃，满心期待着愿望一天一天实现。晚上，在qq上，天使对女孩说：“晚安！”还画了一个：”*”，说这是给她的晚安kiss。女孩也就满足的睡去，梦都散发着甜甜的味道。也偶尔，网关断了，天使也会打个电话给她，对她说晚安，并在电话的另一端亲她的额头，祝她好梦。不知是从何时开始，天使要开始忙自己的事情了，他或许是太忙了，连说晚安的时间都没有了。于是，每天晚上，女孩都满怀期待的等着自己的晚安，却每晚都在失落中入睡，梦里，女孩站在远远的地方，看着忙碌的天使，他或许忙得忘记了晚安的约定，或许等他有空了，他会把亏欠的晚安都补给她。最终，天使忙得都忘记了女孩，终于永远的飞走了，带着那许多亏欠的晚安。很久之后，天堂放假的日子，一大群天使来到人间，他们问女孩，我们可以每人帮你实现一个愿望，权利，金钱，美貌，爱情。……女孩却没有说出自己的愿望，她知道，这是个简单到无法实现的愿望，哪怕是天使，也不能。 人生26岁你看着身边的人都结了婚，婚礼的份子钱逐年递增。春节回家，父母从带你串亲戚，变成了带你去见相亲对象，见了十几个姑娘，你每次都觉得和那个她，差了一点。 28岁你遇到了一个和你遭遇差不多的姑娘，你们有一搭没一搭地聊着。她说：你还不错，你喝了一口可乐说：你也是。你还不确定喜不喜欢她，双方家长就已经摆好了订婚宴。结婚的前一周，你和朋友出去喝酒。你说：不想结婚，朋友说：你啊，就是想太多，谁不是这么过来的？ 29岁你们终于结了婚，婚礼办得不大不小，朋友来得不多不少。攒了几年想要去实现理想的钱，搭在了这一场百人的私人庙会上。婚礼进行到中间，司仪带着标准的商业化微笑，对着台下的亲朋喊道，要不要让他们亲一个，台下那些人跟着一起起哄。不知道为什么，你简简单单地亲了一口，俩人恢复到了一开始的站位。你小声说了一句：我爱你。那个昨天还看不惯你倒腾模型的新娘，愣了一下说：我也爱你。你不确定她是不是对你说的，就像你不确定是不是对她说的一样。婚礼结束后，并没有你想象得浪漫，你听着外屋的新娘一笔一笔地算着份子钱。想着不过才两年，怎么就变成这样了。想着想着，洞房夜就睡着了 30岁她怀孕了，辞掉了工作，在家养胎。你在公司逐渐有了点地位，手里管着十来个人，独立负责一个项目。结婚前陪嫁的那辆20万左右的车也变成了你一个人的独享，但你依然不敢放松。每次加班，电话那头都是抱怨与委屈。但你不能争辩什么，谁让她怀了你的孩子。在这一刻，不论是她的父母还是你的父母，都无条件地站在这一边。 31岁孩子落地了，前前后后连孕检加上住院费花了10万块钱，不过无所谓，你看着你的孩子，怎么看怎么喜欢。高兴得仿佛这是你的新生。 32岁这是人生最不愿意重复的一年，平均睡眠3小时，孩子每一个小时都要闹腾一次，第二天拖着睡不醒的眼睛去上班。老板说你上班不干活，回家媳妇说你不干活。你想了半天不明白，那谁干活呢？那辆开了3年的车，成为了你真正的家，你不在抱怨路上拥堵的交通，你甚至开始希望再多堵一会。回到家，你关了发动机，在车上点了一根烟。这是你每天最幸福的十分钟，车前是功名利禄，车尾是柴米油盐。35岁你因为身体越来越差，加班越来越少，晋升的速度也越来越缓慢 。那天下班，媳妇告诉你，孩子要上幼儿园了，双语的一个月3000，你皱了皱眉头，那边就已经不耐烦了。“四单元的老王家孩子，一个月6000”“你已经这样了，你想让孩子也输？”你没说话，回屋给媳妇转了6000块钱。这笔钱，你原本打算，给自己过个生日，买台新电脑。 38岁孩子上了一年级，老师说一年级最关键，打好基础很重要。你笑着说，是是是，老师您多照顾。新生接待的老师看着你不明事理的脸，给你指了一条明路，课外辅导班，一个月2200。 40岁孩子上了三年级，老师说，三年级，最关键，承上启下很重要。你笑着说：是是是，正打算再报个补习班。 44岁孩子上了初中，有一天回到家，他对你说，爸爸，我想学钢琴。你没什么犹豫的，你以为这些年，你已经习惯了。但那句“爸爸现在买不起”你始终说不出口，好在孩子比较懂事。他说：爸爸没事，要不我先学陶笛也可以，你看着这么懂事的孩子，却开心不起来。 46岁孩子上了一个不好不差的高中，有一天你在开会，接到了老师的电话，电话里说你的孩子在学校打架了，叫你去一趟。你唯唯诺诺地和那个比你还小5岁的领导请了个假。到学校又被老师训了一通，无非台词就是那一句，你们做家长的就知道工作，能不能陪陪孩子。你看着这个老师，有点可笑。好像当时说，家长在外辛苦点，多赚点钱让孩子多补补课的和他不是一个人。 50岁孩子上了大学，很争气，是一个一本。他学的专业你有点看不懂，你只知道工作不一定好找而且学费还死贵。你和他深夜想聊聊，准备了半斤白酒，一碟花生米，你说着那些曾经你最讨厌的话。――还是要为以后工作着想，挑个热门的专业，活着比热爱重要。你们从交流变成了争吵，你发现，你老了，老到可能都打不过这个18岁的孩子，你说不过他，只能说一句：我是你爸爸！孩子看着你，知道再怎么争辩都没用，这场确立你最后威严的酒局不欢而散。你听得不真切，在孩子回自己屋的路上好像叨叨了一句，我不想活得像你一样。怎么就哭了呢？50岁的人了。一定是酒太辣了，对不对，一定是酒太辣了。 55岁孩子工作了，似乎有一点理解你了，但你却反了过来，你说不要妥协。 56岁孩子也结婚了，你问他喜欢那个姑娘么。他愣了愣说：喜欢吧 60岁辛苦了一辈子，想出去走走，身边的那个人过了30年，你依旧分不清到底喜不喜欢。你们开始规划旅游路线，这么多年了，你们还是存在分歧，还是在争吵。某个瞬间，你觉得，这样可能也挺好。一切都准备好了，儿子说：爸妈，我工作太忙了，可以帮我照顾一下孩子么。你们退了机票，又回到了30年前。 70岁孩子的孩子也长大了，不用天天操心了，你下定决心说：一定要去玩一趟。可是手边的拐杖，只能支持你走到楼下的花园。 75岁你在医院的病床上，身边聚满了人，你迷迷糊糊的看见医生摇了摇头。周围那些人神情肃穆，你明白了，你要死掉了。你没有感到一丝害怕，你突然问自己，我到底是什么时候死掉的呢？你想起来30岁的那场婚礼，原来，那时候你就死掉了吧。依照惯例，死前的3秒，你的大脑要走马灯，倒叙你这75个年头的一生，画面一张一张地过。1秒2秒两秒过去了，你面无表情地看着这两秒内的回忆。第3秒，突然你笑了，原来已经回到了15岁的那一年。你看见一个男孩，他叼着一袋牛奶，背着书包。从另一个女孩家的阳台下跑过，那个男孩朝窗户里看了看。那是15岁的你暗恋的那个女孩子，你想不起来她长什么样子了，最后一秒你努力地回忆着，然后终于笑了出来。3秒过去了身边的人突然间开始嚎啕大哭，你可能听不清了，你最后听到的嘈杂的声音，是一群十五六的少年起着哄说的――答应他，答应他，答应他。","categories":[{"name":"生活","slug":"生活","permalink":"https://www.bookandmusic.cn/categories/%E7%94%9F%E6%B4%BB/"},{"name":"感悟","slug":"生活/感悟","permalink":"https://www.bookandmusic.cn/categories/%E7%94%9F%E6%B4%BB/%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"https://www.bookandmusic.cn/tags/%E6%84%9F%E6%82%9F/"}]},{"title":"来来来，你能猜出来吗","slug":"生活-笑话-一","date":"2019-03-23T14:11:27.000Z","updated":"2021-01-21T07:06:37.000Z","comments":true,"path":"2019/03/23/sheng-huo-xiao-hua-yi/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/23/sheng-huo-xiao-hua-yi/","excerpt":"","text":"来来来，你能猜出来吗 考试前，小红对小明说，如果这次你能考全班第一，现在就和你啪啪啪。全班同学都听到了，考卷发下来后，大家都默默的把笔放下，打算交白卷。小明眼泛泪光，看着虎背熊腰200斤的小红，默默的把试卷撕碎吃了！小红微微一笑，在自己的试卷上写下了小明的名字。老师改卷的时候把唯一一份写答案的试卷扔进了碎纸机，毕竟她是小明的母亲，校长在门缝里看到了，偷偷把一张试卷写满，写上了小明的名字，毕竟他和小红妈妈的艺术照还在小红手里，教育局长发现了试卷，把它点着烧了，他满意的看着火光想起了小明嫩滑滑的身体。市长收到消息，偷天换日般的把小刚的试卷换成小明的，毕竟小红有了小明就不会再来打扰他了。省长坐在办公室默默的注视着屏幕上显示出来的市长的一举一动，一道命令下去，学校办公室着火了，毕竟小明可是他的儿子。然而大家都不知道副校长早就把试卷偷偷的拿到了自己的办公室然后走向书架后面的暗门跪在了小红的面前，小红一边脱下假面具和看起来两百斤的厚的衣服露出了倾国倾城的面容和苗条的身材一边用风铃般的声音说着“关于爱情我们永远都不知道他会发生些什么”副校长顺从的说着“是啊是啊”随即含住了小红那比自己还大的丁丁，陶醉的闭上了眼","categories":[{"name":"生活","slug":"生活","permalink":"https://www.bookandmusic.cn/categories/%E7%94%9F%E6%B4%BB/"},{"name":"笑话","slug":"生活/笑话","permalink":"https://www.bookandmusic.cn/categories/%E7%94%9F%E6%B4%BB/%E7%AC%91%E8%AF%9D/"}],"tags":[{"name":"笑话","slug":"笑话","permalink":"https://www.bookandmusic.cn/tags/%E7%AC%91%E8%AF%9D/"}]},{"title":"Hexo博客配置教程","slug":"教程-Hexo博客配置教程","date":"2019-03-23T13:51:51.000Z","updated":"2021-01-25T02:58:34.000Z","comments":true,"path":"2019/03/23/jiao-cheng-hexo-bo-ke-pei-zhi-jiao-cheng/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/23/jiao-cheng-hexo-bo-ke-pei-zhi-jiao-cheng/","excerpt":"","text":"实现Hexo + GitHub 搭建博客。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 注意: 查看文档以获取更多信息。如果使用Hexo时遇到任何问题，可以在故障排除中找到答案，或者可以在GitHub上询问。 hexo教程 git和nodejs安装好后，就可以安装hexo了 12npm install hexo-cli -gnpm install hexo --save 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo 1hexo init 创建一个新帖子 1$ hexo new &quot;我的新帖子&quot; 更多信息：写作 运行服务器 1$ hexo server 更多信息：服务器 生成静态文件 1$ hexo generate 更多信息：生成 部署到远程站点 1$ hexo deploy 更多信息：部署 Hexo中添加本地图片 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件 等待一小段时间后，再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。","categories":[{"name":"教程","slug":"教程","permalink":"https://www.bookandmusic.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.bookandmusic.cn/tags/Hexo/"}]},{"title":"Flask易错点","slug":"Flask易错点","date":"2019-03-22T14:58:58.000Z","updated":"2021-06-12T06:36:07.459Z","comments":true,"path":"2019/03/22/flask-yi-cuo-dian/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/22/flask-yi-cuo-dian/","excerpt":"","text":"装饰器123@app.route(&quot;/&quot;)def index(): return &quot;index page&quot; 123def index(): return &quot;index page&quot;app.route(&quot;/&quot;)(index) 装饰器不仅仅是定义时可以用，还可以在定义完再使用 自定义正则转换器及蓝图12345678910from werkzeug.routing import BaseConverter# 定义正则转换器class ReConverter(BaseConverter): def __init__(self, url_map, regex): # 调用父类初始化方法 super(ReConverter, self).__init__(url_map) # 重新赋值 self.regex = regex 12# 添加自定义的转换器 app.url_map.converters[&quot;re&quot;] = ReConverter 1234567891011121314from flask import Blueprint, current_apphtml = Blueprint(&quot;web_html&quot;, __name__)@html.route(&quot;/&lt;re(r&#x27;.*&#x27;):file_name&gt;&quot;)def web_html(file_name): if not file_name: file_name = &quot;index.html&quot; if file_name != &quot;favicon.ico&quot;: file_name = &quot;html/&quot; + file_name return current_app.send_static_file(file_name) 12# 注册蓝图app.register_blueprint(html) 登录装饰器1234567891011121314151617# 定义验证登录状态的装饰器def login_required(view_func): # wraps函数的作用是将wrapper内层函数的属性设置为被装饰函数view_func的属性 @functools.wraps(view_func) def wrapper(*args, **kwargs): # 判断用户登录状态 user_id = session.get(&quot;user_id&quot;) # 如果用户是登录状态，则执行登录状态 if user_id is not None: # 将user_id保存到g对象中，在视图函数中，可以通过g对象获取保存数据 g.user_id = user_id return view_func(*args, **kwargs) # 如果未登录，则返回未登录信息 else: return jsonify(errno=RET.SESSIONERR, errmsg=&quot;用户未登录&quot;) return wrapper","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Flask","slug":"技术/python/Flask","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Flask/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"https://www.bookandmusic.cn/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"正则转换器","slug":"正则转换器","permalink":"https://www.bookandmusic.cn/tags/%E6%AD%A3%E5%88%99%E8%BD%AC%E6%8D%A2%E5%99%A8/"}]},{"title":"Django基础(一)-项目流程","slug":"Django-1-项目流程","date":"2019-03-22T14:45:46.000Z","updated":"2021-06-12T06:31:02.114Z","comments":true,"path":"2019/03/22/django-1-xiang-mu-liu-cheng/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/22/django-1-xiang-mu-liu-cheng/","excerpt":"","text":"基本流程使用命令django-admin startproject djangodemo,创建Django项目 12345678|-- djangodemo| |-- __init__.py # 说明booktest是一个python包。| |-- settings.py # 项目的配置文件。| |-- urls.py # 进行url路由的配置。| |-- wsgi.py # web服务器和Django交互的入口。||-- manage.py # 项目的管理文件。 使用命令python manage.py startapp books, 创建DjangoApp 123456|- books |- __init__.py # 说明目录是一个Python模块。 |- models.py # 写和数据库项目的内容, 设计模型类。 |- views.py # 接收请求，进行处理，与M和T进行交互，返回应答。定义处理函数，视图函数。 |- tests.py # 写测试代码的文件。 |- admin.py # 网站后台管理相关的文件。 项目配置 修改项目根目下的settings.py文件 注册App123456789INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;books&#x27;, # 应用名 ] 配置数据库12345678910111213DATABASES = &#123; &#x27;default&#x27;: &#123; # &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;, # &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;), &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;djangodemo&#x27;, # 使用的数据库名字，数据库必须手动创建 &#x27;USER&#x27;: &#x27;root&#x27;, # 连接mysql的用户名 &#x27;PASSWORD&#x27;: &#x27;mysql&#x27;, # 用户名对应的密码 &#x27;HOST&#x27;: &#x27;localhost&#x27;, # 指定mysql数据库所在电脑的IP &#x27;PORT&#x27;: 3306, # mysql服务器的端口号 &#125; &#125; 注意: mysql数据库链接驱动，django2.x之后，官方建议使用 mysqlclient,若非要使用 pymysql，还需要如下配置 在与settings.py同级的__init__.py文件中添加: 12import pymysqlpymysql.install_as_MySQLdb() 配置模板目录12345678910111213141516# 在项目根目录下, 新建模板目录 templatesTEMPLATES = [ &#123; &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;, &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &quot;templates&quot;)], &#x27;APP_DIRS&#x27;: True, &#x27;OPTIONS&#x27;: &#123; &#x27;context_processors&#x27;: [ &#x27;django.template.context_processors.debug&#x27;, &#x27;django.template.context_processors.request&#x27;, &#x27;django.contrib.auth.context_processors.auth&#x27;, &#x27;django.contrib.messages.context_processors.messages&#x27;, ], &#125;, &#125;,] 配置静态资源1234# 静态资源展示的url前缀STATIC_URL = &#x27;/static/&#x27;# 静态资源存放的目录，需要先创建static目录STATICFILES_DIRS = [os.path.join(BASE_DIR, &#x27;static&#x27;)] 本地化配置12345LANGUAGE_CODE = &#x27;zh-hans&#x27;TIME_ZONE = &#x27;Asia/Shanghai&#x27;USE_TZ = True # 设置为True， 数据库存储默认使用UTC时区，设置为False， 使用本地时区 配置HOST地址1ALLOWED_HOSTS = [&quot;*&quot;] # 允许客户端通过服务器的任何ip(本地ip和网络ip)访问服务器 创建后台超级管理员 进入manage.py目录下，使用命令python manage.py createsuperuser来进行创建 接下来输入用户名称 : Username(leave bkank to use &#39;administrator&#39;): root 然后是输入邮箱（QQemail等都可以）: Email address：xxxx@xxx.com 输入密码（输入密码时不会显示出来，并且长度必须超过八位才行）: Password：******** 确认密码 : Password(again)：******** 当两次密码输入相同且超过八位的时候，就会提示创建超级用户成功 : Superuser created successfully 数据模型创建模型类在应用books目录下的models.py文件中创建模型类 123456789101112131415161718192021222324252627282930313233from django.db import models# Create your models here.class BookInfo(models.Model): title = models.CharField(max_length=20) pub_date = models.DateField() read = models.IntegerField(default=0) comment = models.IntegerField(default=0) # 删除标记 isDelete = models.BooleanField(default=False) class Meta: db_table = &#x27;tb_books&#x27; # 指定表名 verbose_name = &#x27;图书&#x27; # 后台显示表名 verbose_name_plural = verbose_name def __str__(self): return self.title # 查询对象时，显示信息class HeroInfo(models.Model): name = models.CharField(max_length=20) gender = models.BooleanField(default=False) comment = models.CharField(max_length=200) book = models.ForeignKey(&#x27;BookInfo&#x27;, on_delete=models.CASCADE) isDelete = models.BooleanField(default=False) class Meta: db_table = &#x27;tb_heros&#x27; # 指定表名 verbose_name = &#x27;英雄&#x27; # 后台显示表名 verbose_name_plural = verbose_name def __str__(self): return self.name # 查询对象时，显示信息 模型类生成表 生成迁移文件python manage.py makemigrations 迁移文件生成表python manage.py migrate,生成表名的默认格式：应用名_模型类名小写,可以指定表名 Admin后台管理在应用book下的admin.py中注册模型类。 告诉djang框架根据注册的模型类来生成对应表管理页面。 123456789101112131415from book.models import BookInfofrom book.models import HeroInfo# 后台管理相关文件# Register your models here.class BookInfoAdmin(admin.ModelAdmin): &quot;&quot;&quot;图书模型管理类&quot;&quot;&quot; list_display = [&#x27;id&#x27;, &#x27;book_title&#x27;, &#x27;book_pub_date&#x27;]class HeroInfoAdmin(admin.ModelAdmin): list_display = [&#x27;id&#x27;, &#x27;hero_name&#x27;, &#x27;hero_sex&#x27;, &#x27;hero_comment&#x27;, &#x27;hero_book&#x27;]# 注册模型类admin.site.register(BookInfo, BookInfoAdmin)admin.site.register(HeroInfo, HeroInfoAdmin) 模板在 templates目录下 创建 hero_list.html, 展示所有 英雄信息 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;英雄列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &#123;% for hero in heroes %&#125; # 类似python的for循环和if判断 &#123;% if not hero.isDelete %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; hero.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; hero.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; hero.gender &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; hero.comment &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; hero.book &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endif %&#125; &#123;% endfor %&#125;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 视图在 books APP目录下的 views.py中创建自己的 视图函数 123456from django.shortcuts import renderfrom books.models import *def hero_list_view(request): heros = HeroInfo.objects.all() # 利用模型类查询全部数据 return render(request, &#x27;hero_list.html&#x27;, context=&#123;&#x27;heros&#x27;: heros&#125;) # 利用render函数渲染模板 路由在 项目同名目录的 urls.py中配置路由 1234567from django.urls import pathfrom book.views import *urlpatterns = [ path(&#x27;heroes/&#x27;, hero_list_view)] 项目启动 只能通过本地ip访问 : python manage.py runserver 浏览器输入127.0.0.1:8000访问服务器 可以通过网络ip访问 : python manage.py runserver 0.0.0.0:8000 浏览器输入网络ip:8000访问服务器，同时需要搭配 settings.py中的配置参数使用","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"}],"tags":[{"name":"django基础","slug":"django基础","permalink":"https://www.bookandmusic.cn/tags/django%E5%9F%BA%E7%A1%80/"}]},{"title":"python异常","slug":"python高级-异常","date":"2019-03-22T14:38:25.000Z","updated":"2021-01-23T14:54:17.000Z","comments":true,"path":"2019/03/22/python-gao-ji-yi-chang/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/22/python-gao-ji-yi-chang/","excerpt":"","text":"自定义异常类型1234567891011121314151617# 自定义错误类型class ArgsException(Exception): def __init__(self, num, num_type): self.num = num # 用来描述参数个数 self.num_type = num_type # 用户描述参数类型num1 = input(&quot;输入数字:&quot;)num2 = input(&quot;输入数字:&quot;)try: if num1.isdigit() is False or num2.isdigit() is False: # 错误类型的实例对象 raise ArgsException(2, &quot;int&quot;) # raise 异常类型 -&gt; 主动抛出异常except ArgsException as ret: print(&quot;需要%d个%s参数&quot; % (ret.num, ret.num_type))","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"异常","slug":"异常","permalink":"https://www.bookandmusic.cn/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"python魔法方法","slug":"python面向对象-魔法方法","date":"2019-03-22T14:22:33.000Z","updated":"2021-01-23T15:06:30.000Z","comments":true,"path":"2019/03/22/python-mian-xiang-dui-xiang-mo-fa-fang-fa/","link":"","permalink":"https://www.bookandmusic.cn/2019/03/22/python-mian-xiang-dui-xiang-mo-fa-fang-fa/","excerpt":"","text":"据说，Python 的对象天生拥有一些神奇的方法，它们总被双下划线所包围，他们是面向对象的 Python 的一切。 他们是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。 Python 的魔术方法非常强大，然而随之而来的则是责任。了解正确的方法去使用非常重要！","categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"魔法方法","slug":"魔法方法","permalink":"https://www.bookandmusic.cn/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"技术/python","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/"},{"name":"web","slug":"技术/python/web","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/web/"},{"name":"Flask","slug":"技术/python/Flask","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Flask/"},{"name":"模块","slug":"技术/python/模块","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E6%A8%A1%E5%9D%97/"},{"name":"DRF","slug":"技术/python/DRF","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/DRF/"},{"name":"工具","slug":"工具","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"工具/Git","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/Git/"},{"name":"Django","slug":"技术/python/Django","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/Django/"},{"name":"系统","slug":"系统","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"Mac","slug":"系统/Mac","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/Mac/"},{"name":"vue","slug":"技术/vue","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/vue/"},{"name":"linux","slug":"系统/linux","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/linux/"},{"name":"网络通信","slug":"技术/网络通信","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"TCP","slug":"技术/网络通信/TCP","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCP/"},{"name":"系统","slug":"技术/python/系统","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E7%B3%BB%E7%BB%9F/"},{"name":"基础","slug":"技术/python/基础","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/python/%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"技术/数据库","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"技术/数据库/redis","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"},{"name":"mysql","slug":"技术/数据库/mysql","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"JS","slug":"技术/JS","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/JS/"},{"name":"python","slug":"工具/python","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/python/"},{"name":"算法","slug":"技术/算法","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"},{"name":"时间复杂度","slug":"技术/算法/时间复杂度","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"Windows","slug":"系统/Windows","permalink":"https://www.bookandmusic.cn/categories/%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"排序","slug":"技术/算法/排序","permalink":"https://www.bookandmusic.cn/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"NodeJs","slug":"工具/NodeJs","permalink":"https://www.bookandmusic.cn/categories/%E5%B7%A5%E5%85%B7/NodeJs/"},{"name":"教程","slug":"教程","permalink":"https://www.bookandmusic.cn/categories/%E6%95%99%E7%A8%8B/"},{"name":"生活","slug":"生活","permalink":"https://www.bookandmusic.cn/categories/%E7%94%9F%E6%B4%BB/"},{"name":"感悟","slug":"生活/感悟","permalink":"https://www.bookandmusic.cn/categories/%E7%94%9F%E6%B4%BB/%E6%84%9F%E6%82%9F/"},{"name":"笑话","slug":"生活/笑话","permalink":"https://www.bookandmusic.cn/categories/%E7%94%9F%E6%B4%BB/%E7%AC%91%E8%AF%9D/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://www.bookandmusic.cn/tags/JWT/"},{"name":"JWS","slug":"JWS","permalink":"https://www.bookandmusic.cn/tags/JWS/"},{"name":"itsdangerous","slug":"itsdangerous","permalink":"https://www.bookandmusic.cn/tags/itsdangerous/"},{"name":"pyjwt","slug":"pyjwt","permalink":"https://www.bookandmusic.cn/tags/pyjwt/"},{"name":"图片上传","slug":"图片上传","permalink":"https://www.bookandmusic.cn/tags/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"},{"name":"unittest","slug":"unittest","permalink":"https://www.bookandmusic.cn/tags/unittest/"},{"name":"django test","slug":"django-test","permalink":"https://www.bookandmusic.cn/tags/django-test/"},{"name":"mock","slug":"mock","permalink":"https://www.bookandmusic.cn/tags/mock/"},{"name":"element-ui","slug":"element-ui","permalink":"https://www.bookandmusic.cn/tags/element-ui/"},{"name":"axios","slug":"axios","permalink":"https://www.bookandmusic.cn/tags/axios/"},{"name":"Git","slug":"Git","permalink":"https://www.bookandmusic.cn/tags/Git/"},{"name":"haystack","slug":"haystack","permalink":"https://www.bookandmusic.cn/tags/haystack/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://www.bookandmusic.cn/tags/Elasticsearch/"},{"name":"DRF","slug":"DRF","permalink":"https://www.bookandmusic.cn/tags/DRF/"},{"name":"Celery","slug":"Celery","permalink":"https://www.bookandmusic.cn/tags/Celery/"},{"name":"单文件导入配置项","slug":"单文件导入配置项","permalink":"https://www.bookandmusic.cn/tags/%E5%8D%95%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E9%85%8D%E7%BD%AE%E9%A1%B9/"},{"name":"异步操作","slug":"异步操作","permalink":"https://www.bookandmusic.cn/tags/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"},{"name":"ORM操作","slug":"ORM操作","permalink":"https://www.bookandmusic.cn/tags/ORM%E6%93%8D%E4%BD%9C/"},{"name":"django基础","slug":"django基础","permalink":"https://www.bookandmusic.cn/tags/django%E5%9F%BA%E7%A1%80/"},{"name":"CLI","slug":"CLI","permalink":"https://www.bookandmusic.cn/tags/CLI/"},{"name":"终端工具","slug":"终端工具","permalink":"https://www.bookandmusic.cn/tags/%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7/"},{"name":"Vue","slug":"Vue","permalink":"https://www.bookandmusic.cn/tags/Vue/"},{"name":"组件通信","slug":"组件通信","permalink":"https://www.bookandmusic.cn/tags/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"},{"name":"中间件","slug":"中间件","permalink":"https://www.bookandmusic.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"邮件","slug":"邮件","permalink":"https://www.bookandmusic.cn/tags/%E9%82%AE%E4%BB%B6/"},{"name":"缓存","slug":"缓存","permalink":"https://www.bookandmusic.cn/tags/%E7%BC%93%E5%AD%98/"},{"name":"分页","slug":"分页","permalink":"https://www.bookandmusic.cn/tags/%E5%88%86%E9%A1%B5/"},{"name":"JWE","slug":"JWE","permalink":"https://www.bookandmusic.cn/tags/JWE/"},{"name":"图片","slug":"图片","permalink":"https://www.bookandmusic.cn/tags/%E5%9B%BE%E7%89%87/"},{"name":"样式","slug":"样式","permalink":"https://www.bookandmusic.cn/tags/%E6%A0%B7%E5%BC%8F/"},{"name":"deepin","slug":"deepin","permalink":"https://www.bookandmusic.cn/tags/deepin/"},{"name":"nvidia","slug":"nvidia","permalink":"https://www.bookandmusic.cn/tags/nvidia/"},{"name":"TCP","slug":"TCP","permalink":"https://www.bookandmusic.cn/tags/TCP/"},{"name":"WEB Server","slug":"WEB-Server","permalink":"https://www.bookandmusic.cn/tags/WEB-Server/"},{"name":"高并发","slug":"高并发","permalink":"https://www.bookandmusic.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"短连接","slug":"短连接","permalink":"https://www.bookandmusic.cn/tags/%E7%9F%AD%E8%BF%9E%E6%8E%A5/"},{"name":"长连接","slug":"长连接","permalink":"https://www.bookandmusic.cn/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"},{"name":"API","slug":"API","permalink":"https://www.bookandmusic.cn/tags/API/"},{"name":"RESTful","slug":"RESTful","permalink":"https://www.bookandmusic.cn/tags/RESTful/"},{"name":"引用计数","slug":"引用计数","permalink":"https://www.bookandmusic.cn/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"name":"分代回收","slug":"分代回收","permalink":"https://www.bookandmusic.cn/tags/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6/"},{"name":"标记清除","slug":"标记清除","permalink":"https://www.bookandmusic.cn/tags/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4/"},{"name":"序列化","slug":"序列化","permalink":"https://www.bookandmusic.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"反序列化","slug":"反序列化","permalink":"https://www.bookandmusic.cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"递归函数","slug":"递归函数","permalink":"https://www.bookandmusic.cn/tags/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"},{"name":"lambda","slug":"lambda","permalink":"https://www.bookandmusic.cn/tags/lambda/"},{"name":"匿名函数","slug":"匿名函数","permalink":"https://www.bookandmusic.cn/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"name":"高阶函数","slug":"高阶函数","permalink":"https://www.bookandmusic.cn/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"name":"sorted","slug":"sorted","permalink":"https://www.bookandmusic.cn/tags/sorted/"},{"name":"map","slug":"map","permalink":"https://www.bookandmusic.cn/tags/map/"},{"name":"reduce","slug":"reduce","permalink":"https://www.bookandmusic.cn/tags/reduce/"},{"name":"filter","slug":"filter","permalink":"https://www.bookandmusic.cn/tags/filter/"},{"name":"LEGB","slug":"LEGB","permalink":"https://www.bookandmusic.cn/tags/LEGB/"},{"name":"作用域","slug":"作用域","permalink":"https://www.bookandmusic.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"global","slug":"global","permalink":"https://www.bookandmusic.cn/tags/global/"},{"name":"nonlocal","slug":"nonlocal","permalink":"https://www.bookandmusic.cn/tags/nonlocal/"},{"name":"CSRF","slug":"CSRF","permalink":"https://www.bookandmusic.cn/tags/CSRF/"},{"name":"状态码","slug":"状态码","permalink":"https://www.bookandmusic.cn/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.bookandmusic.cn/tags/HTTP/"},{"name":"ORM模型类","slug":"ORM模型类","permalink":"https://www.bookandmusic.cn/tags/ORM%E6%A8%A1%E5%9E%8B%E7%B1%BB/"},{"name":"redis命令","slug":"redis命令","permalink":"https://www.bookandmusic.cn/tags/redis%E5%91%BD%E4%BB%A4/"},{"name":"office","slug":"office","permalink":"https://www.bookandmusic.cn/tags/office/"},{"name":"vue","slug":"vue","permalink":"https://www.bookandmusic.cn/tags/vue/"},{"name":"v-on","slug":"v-on","permalink":"https://www.bookandmusic.cn/tags/v-on/"},{"name":"Js事件","slug":"Js事件","permalink":"https://www.bookandmusic.cn/tags/Js%E4%BA%8B%E4%BB%B6/"},{"name":"事件修饰符","slug":"事件修饰符","permalink":"https://www.bookandmusic.cn/tags/%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"事件绑定","slug":"事件绑定","permalink":"https://www.bookandmusic.cn/tags/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"name":"错误说明","slug":"错误说明","permalink":"https://www.bookandmusic.cn/tags/%E9%94%99%E8%AF%AF%E8%AF%B4%E6%98%8E/"},{"name":"router","slug":"router","permalink":"https://www.bookandmusic.cn/tags/router/"},{"name":"ES6","slug":"ES6","permalink":"https://www.bookandmusic.cn/tags/ES6/"},{"name":"var","slug":"var","permalink":"https://www.bookandmusic.cn/tags/var/"},{"name":"let","slug":"let","permalink":"https://www.bookandmusic.cn/tags/let/"},{"name":"const","slug":"const","permalink":"https://www.bookandmusic.cn/tags/const/"},{"name":"箭头函数","slug":"箭头函数","permalink":"https://www.bookandmusic.cn/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"name":"virtualenv","slug":"virtualenv","permalink":"https://www.bookandmusic.cn/tags/virtualenv/"},{"name":"pipenv","slug":"pipenv","permalink":"https://www.bookandmusic.cn/tags/pipenv/"},{"name":"conda","slug":"conda","permalink":"https://www.bookandmusic.cn/tags/conda/"},{"name":"虚拟环境","slug":"虚拟环境","permalink":"https://www.bookandmusic.cn/tags/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"name":"pip","slug":"pip","permalink":"https://www.bookandmusic.cn/tags/pip/"},{"name":"跨域","slug":"跨域","permalink":"https://www.bookandmusic.cn/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"权限","slug":"权限","permalink":"https://www.bookandmusic.cn/tags/%E6%9D%83%E9%99%90/"},{"name":"认证","slug":"认证","permalink":"https://www.bookandmusic.cn/tags/%E8%AE%A4%E8%AF%81/"},{"name":"限流","slug":"限流","permalink":"https://www.bookandmusic.cn/tags/%E9%99%90%E6%B5%81/"},{"name":"auth","slug":"auth","permalink":"https://www.bookandmusic.cn/tags/auth/"},{"name":"user","slug":"user","permalink":"https://www.bookandmusic.cn/tags/user/"},{"name":"参数发送","slug":"参数发送","permalink":"https://www.bookandmusic.cn/tags/%E5%8F%82%E6%95%B0%E5%8F%91%E9%80%81/"},{"name":"主键约束","slug":"主键约束","permalink":"https://www.bookandmusic.cn/tags/%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F/"},{"name":"唯一约束","slug":"唯一约束","permalink":"https://www.bookandmusic.cn/tags/%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F/"},{"name":"用户管理","slug":"用户管理","permalink":"https://www.bookandmusic.cn/tags/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"name":"mysql软件操作","slug":"mysql软件操作","permalink":"https://www.bookandmusic.cn/tags/mysql%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"Json","slug":"Json","permalink":"https://www.bookandmusic.cn/tags/Json/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.bookandmusic.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"varbinary","slug":"varbinary","permalink":"https://www.bookandmusic.cn/tags/varbinary/"},{"name":"binary","slug":"binary","permalink":"https://www.bookandmusic.cn/tags/binary/"},{"name":"char","slug":"char","permalink":"https://www.bookandmusic.cn/tags/char/"},{"name":"varchar","slug":"varchar","permalink":"https://www.bookandmusic.cn/tags/varchar/"},{"name":"float","slug":"float","permalink":"https://www.bookandmusic.cn/tags/float/"},{"name":"decimal","slug":"decimal","permalink":"https://www.bookandmusic.cn/tags/decimal/"},{"name":"SQL语句","slug":"SQL语句","permalink":"https://www.bookandmusic.cn/tags/SQL%E8%AF%AD%E5%8F%A5/"},{"name":"namespace","slug":"namespace","permalink":"https://www.bookandmusic.cn/tags/namespace/"},{"name":"app_name","slug":"app-name","permalink":"https://www.bookandmusic.cn/tags/app-name/"},{"name":"reverse","slug":"reverse","permalink":"https://www.bookandmusic.cn/tags/reverse/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"https://www.bookandmusic.cn/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"开机自启","slug":"开机自启","permalink":"https://www.bookandmusic.cn/tags/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/"},{"name":"Windows","slug":"Windows","permalink":"https://www.bookandmusic.cn/tags/Windows/"},{"name":"内置函数","slug":"内置函数","permalink":"https://www.bookandmusic.cn/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.bookandmusic.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"线程","slug":"线程","permalink":"https://www.bookandmusic.cn/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://www.bookandmusic.cn/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"协程","slug":"协程","permalink":"https://www.bookandmusic.cn/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"多任务","slug":"多任务","permalink":"https://www.bookandmusic.cn/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/"},{"name":"排序","slug":"排序","permalink":"https://www.bookandmusic.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"时间模块","slug":"时间模块","permalink":"https://www.bookandmusic.cn/tags/%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/"},{"name":"装饰器","slug":"装饰器","permalink":"https://www.bookandmusic.cn/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"闭包","slug":"闭包","permalink":"https://www.bookandmusic.cn/tags/%E9%97%AD%E5%8C%85/"},{"name":"密钥","slug":"密钥","permalink":"https://www.bookandmusic.cn/tags/%E5%AF%86%E9%92%A5/"},{"name":"远程仓库关联","slug":"远程仓库关联","permalink":"https://www.bookandmusic.cn/tags/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/"},{"name":"NodeJs","slug":"NodeJs","permalink":"https://www.bookandmusic.cn/tags/NodeJs/"},{"name":"npm","slug":"npm","permalink":"https://www.bookandmusic.cn/tags/npm/"},{"name":"nvm","slug":"nvm","permalink":"https://www.bookandmusic.cn/tags/nvm/"},{"name":"yarn","slug":"yarn","permalink":"https://www.bookandmusic.cn/tags/yarn/"},{"name":"GitBook","slug":"GitBook","permalink":"https://www.bookandmusic.cn/tags/GitBook/"},{"name":"感悟","slug":"感悟","permalink":"https://www.bookandmusic.cn/tags/%E6%84%9F%E6%82%9F/"},{"name":"笑话","slug":"笑话","permalink":"https://www.bookandmusic.cn/tags/%E7%AC%91%E8%AF%9D/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.bookandmusic.cn/tags/Hexo/"},{"name":"正则转换器","slug":"正则转换器","permalink":"https://www.bookandmusic.cn/tags/%E6%AD%A3%E5%88%99%E8%BD%AC%E6%8D%A2%E5%99%A8/"},{"name":"异常","slug":"异常","permalink":"https://www.bookandmusic.cn/tags/%E5%BC%82%E5%B8%B8/"},{"name":"魔法方法","slug":"魔法方法","permalink":"https://www.bookandmusic.cn/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"}]}